\maketitle

\begin{abstract}
  We generalize semi\naive{} evaluation from Datalog to Datafun and prove it
  correct.
\end{abstract}

\section{Strategy}

We first generalize Datafun's \Poset{} semantics to any category with
appropriate structures (\cref{sec:datafun-models}). We construct such a
category, \CP{}, whose objects are posets equipped with a notion of increasing
changes, and whose morphisms are monotone maps possessing \emph{derivatives}
relating input and output changes (\cref{sec:changeposets}). We show this
``incremental'' semantics agrees with Datafun's standard semantics
(\cref{sec:incremental}). We give a static transformation on Datafun that
reinterprets the discreteness comonad to compute derivatives, and uses these to
speed up fixed point computations. Finally, we prove this semi\naive{}
evaluation transform correct.

% TODO: more section links once I finish them.


\section{Notation and conventions}

\begin{enumerate}
\item Adjacency $f\<x$ denotes the function $f$ applied to an argument $x$.

\item I write $f \then g$ for the composition of morphisms $f : A \to B$ and $g
  : B \to C$. This is the reverse of the usual composition operator, $g \circ
  f$.

\item I write $\subst{e}{x \substo f}$ to mean ``$e$ with all free occurrences of $x$
  replaced by $f$ ($\alpha$-varying as necessary to avoid capture)''.

  \newcommand\iexpr{\phi}
\item I write $(\iexpr_i)_i$ for the tuple or sequence $(\iexpr_1,
  ..., \iexpr_n)$, leaving $n$ unspecified. For example,

  \nopagebreak[2]
  \[ (2^ix + y_i)_i \quad\text{means}\quad
  (2^1x + y_1,~ 2^2x + y_2,~ ...,~ 2^nx + y_n) \]

  \noindent
  I also use this notation with other braces, eg. $\fork{\iexpr_i}_i =
  \fork{\iexpr_0, ..., \iexpr_n}$.

\item $\expO A B$ denotes the exponential $B^A$ in a cartesian closed category.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their \emph{``fork''} $\fork{f_i}_i : A \to \textstyle\prod_{i} B_i$
  uniquely satisfies $\fork{f_i}_i \then \pi_i = f_i$. Dually, given $f_i : A_i
  \to B$ in a category with finite sums, their \emph{``split''} $\krof{f_i}_i :
  \sum_i A_i \to B$ uniquely satisfies $\injc_i \then \krof{f_i}_i = f_i$.
  %
  So in particular, $\termI : A \to \termO$ is the unique map into the terminal
  object and $\initE : \initO \to B$ the unique map out of the initial object.

\item The comonad $\iso : \Poset \to \Poset$ takes a poset to the
  \emph{discrete} poset on the same elements, defined:

  \begin{eqnarray*}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{eqnarray*}
\end{enumerate}


\input{seminaive/fig1-core-datafun.tex}
\input{seminaive/fig2-surface-syntax.tex}
\input{seminaive/fig3-desugaring.tex}
\input{seminaive/fig4-desugaring-higher-order-semilattice}
\input{seminaive/fig5-desugaring-pattern-matching}


\section{Surface syntax and its desugaring}

We present Datafun in two layers: a simpler \emph{core}
(\cref{fig:core-datafun}) and a more liberal \emph{surface}
(\cref{fig:surface-syntax}) whose extensions are desugared into core terms
(\crefrange{fig:desugaring}{fig:desugaring-pattern-matching}).
%
The simpler core terms are easier to \emph{analyse}, so our semantics and static
transformations consume core terms; conversely, surface terms are easier to
\emph{construct}, so we use them in example programs and in the outputs of our
static transformations.

The specific surface features we add are:
\begin{enumerate}
\item Let-bindings.

\item Booleans, ordered $\efalse < \etrue$. Since sum types are ordered
  disjointly, booleans are instead desugared into sets of empty tuples, with
  $\efalse = \emptyset$ and $\etrue = \eset{\etuple{}}$. \todo{TODO: explain
    $(\eisEmpty e)$}.

\item Pattern matching on tuples and boxes. \todo{TODO: explain $\prim{split}$.}

\item In the core language, semilattice operations ($\bot$, $e \vee f$, and
  \kwname{for}-loops) are permitted only at \emph{first-order} semilattice types
  $\eqt L$. This limitation is lifted in the surface language using
  $\eta$-expansion (\cref{fig:desugaring-higher-order-semilattice}).

\item In the core language, we express fixed point computations using what
  amounts to a higher-order operator $\prim{fix} : \isof{(\fixt L \to \fixt L)}
  \to \fixt L$. In the surface language there is a more convenient binding form,
  $\efixisd x e$.

\end{enumerate}


\section{Datafun models}
\label{sec:datafun-models}

The \emph{``standard''} model of Datafun interprets types as posets and terms as
monotone maps. Generalizing this, we can interpret Datafun terms into any
bicartesian closed category \catC{} equipped with the following structures:

\begin{enumerate}
\item A \emph{``discreteness''} comonad $\tuple{\disco{}, \varepsilon, \delta}$
  equipped with distributive morphisms:

  \nopagebreak[2]
  \begin{align*}
    \discox &: \prod_i \discof{A_i} \to \disco \prod_i A_i
    &
    \discosum &: \disco \sum_i A_i \to \sum_i \discof{A_i}
  \end{align*}

\item A \emph{``finite powerset''} functor \(\pfin : \catC \to \catC\) equipped
  with morphism families:

  \nopagebreak[2]
  \begin{align*}
    \morph{singleton} &: \isof A \to \pfinof{A} &
    \morph{isEmpty} &: \discof{\pfinof{\termO}} \to \termO + \termO
  \end{align*}

  %% \noindent
  %% and, moreover, for any objects $\G,A$, semilattice object $L$, and morphism
  %% $f : \G \x \isof A \to L$, a ``collecting'' morphism \( \pcollect{f} : \G \x
  %% \pfinof A \to L \).

\item \emph{Equality}, \emph{semilattice}, and \emph{fixed point objects}, which
  must interpret first-order, semilattice, and fixed point types respectively.
  Letting $\eqt A$ be an equality object, $L$ be a semilattice object, and
  $\fixt L$ be a fixed point object, these must have morphisms:

  \nopagebreak[2]
  \begin{align*}
    \morph{eq} &: \isof{\eqt A} \x \isof{\eqt A} \to \pfinof\termO
    &
    \morph{join}_n &: L^n \to L
    &
    \morph{fix} &: \isof{(\expO{\fixt L}{\fixt L})} \to \fixt L
  \end{align*}

\item To interpret \kwname{for}-loops, for any objects $\G, A$ and any
  semilattice object $L$ we require a family of morphisms $\pcollect{f}$:

  \nopagebreak[2]
  \[
    \infer{f : \G \x \isof A \to L}
          {\pcollect{f} : \G \x \pfinof{A} \to L}
  \]

%% , Given objects $\G, A$, a semilattice equality type $\eqt L$, and
%%   a morphism $f : \G \x \isof{A} \to \den{\eqt L}$, we require a morphism
%%   $\pcollect{f} : \G \x \pfinof{A} \to \den{\eqt L}$. Or, abusing inference rule
%%   notation:
%%   %
%%   \[
%%     \infer{f : \G \x \isof A \to \den{\eqt L}}
%%           {\pcollect{f} : \G \x \pfinof{A} \to \den{\eqt L}}
%%   \]

\end{enumerate}

\noindent
\Cref{fig:semantics} shows how to interpret Datafun into any Datafun
model. The standard semantics is an instance of this, letting \catC{} be
\Poset{}, \iso{} be \iso{}, and \pfin{} be the finite powerset functor.
\todo{TODO: explain in more detail?}

Since we have not imposed any laws, there is no useful general equational theory
of Datafun models. Instead, our approach is to relate the models we construct to
the standard model and use \emph{its} equational theory.


\input{seminaive/fig6-semantics}


\section{The category \CP}
\label{sec:changeposets}

Objects $A$ of \CP{} are tuples $\tuple{\vals A, \chgs A, \updfn_A,
  \composefn_A}$, where:

\begin{itemize}
\item $\vals A$ is a poset of values.

\item $\chgs A$ is a poset of changes.

\item $\updfn_A : \vals A \x \chgs A \pto \vals A$ is a \emph{partial} map
  taking a value and a change to an updated value. When $x \upd \dx$ is defined,
  we say \dx\ is a \emph{valid} change to $x$. It is often convenient to notate
  $x \upd \dx = y$ relationally, as $\valid\dx x y$ (``\dx\ sends $x$ to $y$''),
  or more briefly as $\vld\dx x y$.

\item $\composefn_A : \chgs A \x \chgs A \to \chgs A : \Poset$ is a monotone
  change composition operator.
\end{itemize}

\noindent
These must satisfy the following conditions:

\nopagebreak[2]
\begin{align*}
  x \le y &\impliedby \ex{\dx} \vld{\dx} x y
  & \text{sound for increases}\\
  x \le y &\implies \ex{\dx} \vld{\dx} x y
  & \text{complete for increases}\\
  \vld\dx x y \wedge \vld\dy y z &\implies \vld{\dx\compose\dy} x z
  & \text{correctness of composition}
\end{align*}

\noindent Completeness for increases is equivalent (via choice) to the existence
of an operator $x \changeto_A y$, defined for $x \le y : \vals A$, such that
$\valid{x \changeto y} x y$.\footnote{Our $x \changeto y$ is effectively the
  incremental $\fn$-calculus' $y \ominus x$, but defined only when $x \le y$.}
In particular, every $x$ has a \emph{zero change}, $\zero_x = x \changeto
x$. However, changes (including zero changes) are not necessarily unique: for a
given $x,y$ there may be many $\dx$ such that $\valid\dx x y$.

Morphisms $f : \CP(A, B)$ are differentiable maps $f : \Poset(\vals A, \vals
B)$. A map is differentiable if it has a derivative $\deriv f : \vals A \to
\Poset(\chgs A, \chgs B)$ such that:

\nopagebreak[2]
\[ \vld{\dx} x y \implies \vld{\deriv f\<x\<\dx}{f\<x}{f\<y}\]

\noindent Or, equivalently:

\nopagebreak[2]
\[ f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

\noindent
The same morphism may have many different derivatives; all that matters is that
one exist.

Identity and composition morphisms in \CP{} are inherited from \Poset{}, so we
need only exhibit their derivatives. These follow a variant of the chain rule:

\nopagebreak[2]
\begin{align*}
  \deriv\id \<x\<\dx &= \dx
  & \deriv{(g \circ f)} \<x\<\dx &= \deriv g \<(f\<x) \<(\deriv f\<x\<\dx)
\end{align*}

\noindent
It's easy to see these functions are monotone in \dx\ as required.


\subsection{The functor \valfn}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals A$
and morphisms $f$ to themselves. The structures we will build in \CP{} will
usually (but not always!) \emph{refine} those in \Poset, in the sense of
commuting with \valfn. For example, for cartesian products, $\vals{(A \x B)} =
\vals A \x \vals B$ and $\vals{\fork{f,g}} = \fork{\vals f, \vals g}$.
%
For brevity, we omit the ``value components'' of our constructions when they are
inherited in this way from \Poset.


\subsection{Cartesian structure}
\label{sec:CP-cartesian}

\CP\ has all finite products and sums. The value-level structure is inherited
from \Poset\ along \valfn. The change-poset structure is also inherited from
\Poset, while the projection and injection's derivatives operate pointwise on
changes:

\nopagebreak[2]
\begin{align*}
  \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
  \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
  %\label{eqn:delta-distributes-over-sums-and-products}
  \\
  \deriv\pi_i\<x\<\dx &= \pi_i\<\dx & \deriv\injc_i\<x\<\dx &= \inj i \dx
\end{align*}

\noindent Updates are pointwise, noting that $(\inj i x \upd \inj j \dx)$ is
undefined for $i \ne j$:

\nopagebreak[2]
\begin{align*}
  (x_i)_i \upd (\dx_i)_i &= (x_i \upd \dx_i)_i &
  \inj i x \upd \inj i \dx &= \inj i (x \upd \dx)
\end{align*}

\noindent
Soundness \& completeness for increases follow directly from the pointwise
orderings of products \& coproducts in \Poset{}. In particular, the $\changetofn$
operator is given by:

\nopagebreak[2]
\begin{align*}
  (x_i)_i \changeto (y_i)_i &= (x_i \changeto y_i)_i &
  \inj i x \changeto \inj i y &= \inj i (x \changeto y)
\end{align*}

\noindent Finally, change composition is also pointwise --- mostly:

\nopagebreak[2]
\begin{align*}
  (\dx_i)_i \compose (\dy_i)_i &= (\dx_i \compose \dy_i)_i &
  \inj i \dx \compose \inj j \dy &=
  \begin{cases}
    \inj i (\dx \compose \dy) &\text{if}~i=j\\
    \inj i \dx &\text{otherwise}
  \end{cases}
\end{align*}

\noindent
However, for sums we must also handle changes with distinct tags. Recall that
composition is correct if, when $\valid\dx x y$ and $\valid\dy y z$, we have
$\valid{\dx\compose\dy} x z$. But if $i \ne j$, then
%
there \emph{are} no $x,y,z$ such that $\valid{\inj i \dx} x y$ and $\valid{\inj j \dy} y z$.
%
This case is \emph{dead code}; the only guarantee we need is monotonicity with
respect to \dx\ and \dy, so it suffices to simply return the left argument.

Correctness of the other cases follows directly from correctness of each $\composefn_{A_i}$.


\subsection{Exponentials}
\label{sec:CP-exponentials}

The values $\vals{(\expO A B)}$ of the exponential object are the
\emph{differentiable} monotone maps $\CP(A, B)$, ordered pointwise. Because we
require differentiability, \valfn\ does \emph{not} commute with exponentials:
$\vals{(\expO A B)} \ne \expO{\vals A}{\vals B}$.
%
Meanwhile, the changes $\chgs{(\expO A B)}$ are maps $\vals A \to \Poset(\chgs
A, \chgs B)$, ordered pointwise. The update relation and change composition must
be very carefully defined, so we examine them at length below.

\subsubsection{Updating functions}

The update relation is:

\nopagebreak[2]
\begin{equation}\label{eqn:function-update}
  \vld{\df}{f}{g} : \expO A B
  \iff \fa{\vld\dx x y} \vld{\df\<x\<\dx} {f\<x} {g\<y}
\end{equation}

\noindent However, recall that $\upd$ must be a partial function: supposing
$\valid\df f g$ and $\valid\df f h$, we must show $g = h$. So consider any $x :
A$. \Cref{eqn:function-update} applied to $\valid{\zero_x} x x$ yields

\nopagebreak[2]
\[ \vld{\df \<x \<\zero_x}{f \<x}{g\<x}
\quad\text{and}\quad \vld{\df \<x \<\zero_x}{f \<x}{h\<x} \]

\noindent
Then by functionality of $\updfn_B$ we have $g\<x = h\<x$, and thus $g = h$.

Although this shows that \cref{eqn:function-update} defines a partial function,
one may wonder what it actually \emph{does} (when it is defined). So let's
rewrite \cref{eqn:function-update} in terms of $\upd_{\expO A B}$:

\nopagebreak[2]
\[ f \upd \df = g \iff \fa{x \upd \dx = y} f\<x \upd \df\<x\<\dx = g\<y \]

\noindent Substituting away $g$ and $y$, this implies that for all valid
\dx, \df:

\nopagebreak[2]
\[
f\<x \upd \df\<x\<\dx = (f \upd \df) \<(x \upd \dx)
\]

\noindent In particular, letting $\dx = \zero_x$ and swapping sides, we get:

\nopagebreak[2]
\[ (f \upd \df) \<x = f\<x \upd \df\<x\<\zero_x \]

\noindent
\todo{TODO: explain why this does not suffice as a \emph{definition} of
  $\updfn_{\expO A B}$ --- in particular, they don't explain when $f \upd \df$
  is defined! It's \emph{not} simply when $x \mapsto f\<x \upd \df\<x\<\dx$ is
  monotone, for example. Can I find a counterexample?}

\subsubsection{Soundness and completeness}

Soundness follows from completeness at $A$ and soundness at $B$ --- if
$\valid\df f g$ then for any $x$ we have $\valid{\df\<x\<\zero_x}{f\<x}{g\<x}$
(using completeness of $A$ to find $\zero_x$), and by soundness at $B$ we have
$f\<x \le g\<x$, so $f \le g$.

We'll show completeness by constructing \changetofn\ explicitly:

\nopagebreak[2]
\[ (f \changeto_{\expO A B} g) \<x \<\dx = (f\<x \changeto_B g\<x) \compose_B \deriv g\<x\<\dx\]

\noindent Observe that $f\<x \changeto_B g\<x$ is defined because $f \le g$
implies $f\<x \le g\<x$, and the RHS is monotone in \dx\ by monotonicity of
$\deriv g \<x$ and of $\composefn_B$.
%
To prove completeness, assuming $\valid\dx x y$, we need to show \( \valid{(f
  \changeto g) \<x \<\dx}{f\<x}{g\<y} \). This follows from correctness of
$\composefn_B$, since \( \valid{f\<x \changeto g\<x}{f\<x}{g\<x} \) and
\(\valid{\deriv g \<x \<\dx}{g\<x}{g\<y}\) by definition.

\subsubsection{Function change composition}

Change composition is defined by:

\nopagebreak[2]
\[ (\df \compose_{\expO A B} \dg) \<x \<\dx = \df \<x \<\zero_x \compose_B \dg \<x \<\dx\]

\noindent
This is monotone in \dx\ by monotonicity of $\dg\<x$ and $\composefn_B$. To show
this valid, suppose $\vld\df f g$, $\vld\dg g h$ and $\vld\dx x y$. Then
%
\(\vld{\df\<x\<\zero_x}{f\<x}{g\<x}\)
\text{and}
\(\vld{\dg\<x\<\dx}{g\<x}{h\<y} \).
%
\noindent So by correctness of $\composefn_B$ we have \(\valid{(\df\<x\<\zero_x
  \compose \dg\<x\<\dx)}{f\<x}{h\<y}\) as desired.

\todo{TODO: discuss unavoidable asymmetry in definitions of \(\changetofn_{\expO
    A B}\) and \(\composefn_{\expO A B}\).}


\subsection{The lifted \pfin\ functor}
\label{sec:CP-pfin}

\subsection{Equality objects}
\label{sec:CP-eq}

\subsection{Semilattice objects and collecting morphisms}
\label{sec:CP-semilattice}

\subsection{Collecting morphisms}
\label{sec:CP-collect}

\subsection{Fixed point objects}
\label{sec:CP-fix}


\section{Incrementalization}
\label{sec:incremental}

The \emph{incremental semantics} for Datafun, notated $\incden{-}$, is given by
the Datafun model in \CP{} constructed in \cref{sec:changeposets}, letting
$\disco = \iso_\CP$ and $\pfin = \pfin_\CP$.

\todo{TODO: explain/state/prove how this relates to the original semantics. use
  disambiguating notation, $\den{-}_\Poset$ and $\den{-}_\CP$ but say that from
  now on, $\den{-}$ means $\den{-}_\CP$ by default.}

The change poset $\D\incdens A$ of a Datafun type $A$ is internally definable
via a type translation given in \cref{fig:PhiDelta}, also named $\D$, despite
the risk of confusion. \todo{FIXME}

\input{seminaive/fig7-PhiDelta}

\begin{restatable}{theorem}{thmDeltaDen}
  \label{thm:delta-den}
  \(\D\incdens A = \den{\D A}\).
\end{restatable}
\begin{proof}
  \todo{TODO}
\end{proof}
