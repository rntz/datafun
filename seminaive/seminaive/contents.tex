\title{Semi\naive{} Datafun}
\author{\scshape Michael Arntzenius}
\date{\today}

\maketitle

\begin{abstract}
  We generalize semi\naive{} evaluation from Datalog to Datafun and prove it
  correct.
\end{abstract}

\section{Outline}

The key insight behind \emph{semi\naive{} evaluation} is to find fixed points
faster by computing only what changes between iterations
(\todo{??}). To apply this in Datafun, we first need to
understand what \emph{change} means.
%
To this end, we generalize Datafun's \Poset{} semantics to any category with
appropriate structures (\cref{sec:datafun-models}). We construct such a
category, \CP{}, whose objects are posets equipped with a notion of increasing
changes, and whose morphisms are monotone maps possessing \emph{derivatives}
relating input and output changes (\cref{sec:changeposets}).

This yields an incremental semantics for Datafun (\cref{sec:incremental}).
%
\todo{Unfortunately, the relationship between the incremental and standard semantics
is unwieldy, and \CP\ on its own is not rich enough to account for semi\naive{}
evaluation. We spec\-u\-late that specialising from \emph{once-differentiable}
to \emph{smooth} functions might yield a rich enough structure.}

Nonetheless, we use \CP\ as a rough guide when constructing a semi\naive{}
evaluation static transformation (\cref{sec:seminaive}). This transformation
reinterprets the discreteness comonad to compute derivatives, and uses these to
speed up fixed point computations. Finally, we prove this transformation correct
using logical relations (\cref{sec:logical-relations}).

% TODO: more section links once I finish them.


\section{Notation and conventions}

\begin{enumerate}
\item Adjacency $f\<x$ denotes the function $f$ applied to an argument $x$.

\item I write $f \then g$ for the composition of morphisms $f : A \to B$ and $g
  : B \to C$. This is the reverse of the usual composition operator, $g \circ
  f$.

\item I write $\subst{e}{x \substo f}$ to mean ``$e$ with all free occurrences of $x$
  replaced by $f$ ($\alpha$-varying as necessary to avoid capture)''.

  \newcommand\iexpr{\phi}
\item I write $(\iexpr_i)_i$ for the tuple or sequence $(\iexpr_1,
  ..., \iexpr_n)$, leaving $n$ unspecified. For example,

  \nopagebreak[2]
  \[ (2^ix + y_i)_i \quad\text{means}\quad
  (2^1x + y_1,~ 2^2x + y_2,~ ...,~ 2^nx + y_n) \]

  \noindent
  I also use this notation with other braces, eg. $\fork{\iexpr_i}_i =
  \fork{\iexpr_0, ..., \iexpr_n}$.

\item $\expO A B$ denotes the exponential $B^A$ in a cartesian closed category.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their \emph{``fork''} $\fork{f_i}_i : A \to \textstyle\prod_{i} B_i$
  uniquely satisfies $\fork{f_i}_i \then \pi_i = f_i$. Dually, given $f_i : A_i
  \to B$ in a category with finite sums, their \emph{``split''} $\krof{f_i}_i :
  \sum_i A_i \to B$ uniquely satisfies $\injc_i \then \krof{f_i}_i = f_i$.
  %
  So in particular, $\termI : A \to \termO$ is the unique map into the terminal
  object and $\initE : \initO \to B$ the unique map out of the initial object.

\item The comonad $\iso : \Poset \to \Poset$ takes a poset to the
  \emph{discrete} poset on the same elements, defined:

  \begin{eqnarray*}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{eqnarray*}
\end{enumerate}


\input{seminaive/fig01-core-datafun}
\input{seminaive/fig02-surface-syntax}
\input{seminaive/fig03-desugaring}
%\input{seminaive/fig04-desugaring-higher-order-semilattice}
\input{seminaive/fig05-desugaring-pattern-matching}


\section{Surface syntax and its desugaring}

We present Datafun in two layers: a simpler \emph{core}
(\cref{fig:core-datafun}) and a more liberal \emph{surface}
(\cref{fig:surface-syntax}) whose extensions are desugared into core terms
(\crefrange{fig:desugaring}{fig:desugaring-pattern-matching}).
%
The simpler core terms are easier to \emph{analyse}, so our semantics and static
transformations consume core terms; conversely, surface terms are easier to
\emph{construct}, so we use them in example programs and in the outputs of our
static transformations.

The specific surface features we add are:
\begin{enumerate}
\item Let-bindings.

\item Booleans, ordered $\efalse < \etrue$. Since sum types are ordered
  disjointly, booleans are instead desugared into sets of empty tuples, with
  $\efalse = \emptyset$ and $\etrue = \eset{\etuple{}}$. \todo{TODO: explain
    $(\eisEmpty e)$}.

\item Pattern matching on tuples and boxes. \todo{TODO: explain $\prim{split}$.}

%% \item In the core language, semilattice operations ($\bot$, $e \vee f$, and
%%   \kwname{for}-loops) are permitted only at \emph{first-order} semilattice types
%%   $\eqt L$. This limitation is lifted in the surface language using
%%   $\eta$-expansion (\cref{fig:desugaring-higher-order-semilattice}).

\item In the core language, we express fixed point computations using what
  amounts to a higher-order operator $\prim{fix} : \isof{(\fixt L \to \fixt L)}
  \to \fixt L$. In the surface language there is a more convenient binding form,
  $\efixisd x e$.

\end{enumerate}


\section{Datafun models}
\label{sec:datafun-models}

The \emph{``standard''} model of Datafun interprets types as posets and terms as
monotone maps. Generalizing this, we can interpret Datafun terms into any
bicartesian closed category \catC{} equipped with the following structures:

\begin{enumerate}
\item A \emph{``discreteness''} comonad $\tuple{\disco{}, \varepsilon, \delta}$
  equipped with distributive morphisms:

  \nopagebreak[2]
  \begin{align*}
    \discox &: \prod_i \discof{A_i} \to \disco \prod_i A_i
    &
    \discosum &: \disco \sum_i A_i \to \sum_i \discof{A_i}
  \end{align*}

\item A \emph{``finite powerset''} functor \(\pfin : \catC \to \catC\) equipped
  with morphism families:

  \nopagebreak[2]
  \begin{align*}
    \morph{singleton} &: \isof A \to \pfinof{A} &
    \morph{isEmpty} &: \discof{\pfinof{\termO}} \to \termO + \termO
  \end{align*}

  %% \noindent
  %% and, moreover, for any objects $\G,A$, semilattice object $L$, and morphism
  %% $f : \G \x \isof A \to L$, a ``collecting'' morphism \( \pcollect{f} : \G \x
  %% \pfinof A \to L \).

\item \emph{Equality}, \emph{semilattice}, and \emph{fixed point objects}, which
  must interpret first-order, semilattice, and fixed point types respectively.
  Letting $\eqt A$ be an equality object, $L$ be a semilattice object, and
  $\fixt L$ be a fixed point object, these must have morphisms:

  \nopagebreak[2]
  \begin{align*}
    \morph{eq} &: \isof{\eqt A} \x \isof{\eqt A} \to \pfinof\termO
    &
    \morph{join}_n &: L^n \to L
    &
    \morph{fix} &: \isof{(\expO{\fixt L}{\fixt L})} \to \fixt L
  \end{align*}

\item To interpret \kwname{for}-loops, for any objects $\G, A$ and any
  semilattice object $L$ we require a family of morphisms $\pcollect{f}$:

  \nopagebreak[2]
  \[
    \infer{f : \G \x \isof A \to L}
          {\pcollect{f} : \G \x \pfinof{A} \to L}
  \]

%% , Given objects $\G, A$, a semilattice equality type $\eqt L$, and
%%   a morphism $f : \G \x \isof{A} \to \den{\eqt L}$, we require a morphism
%%   $\pcollect{f} : \G \x \pfinof{A} \to \den{\eqt L}$. Or, abusing inference rule
%%   notation:
%%   %
%%   \[
%%     \infer{f : \G \x \isof A \to \den{\eqt L}}
%%           {\pcollect{f} : \G \x \pfinof{A} \to \den{\eqt L}}
%%   \]

\end{enumerate}

\input{seminaive/fig06-semantics}

\noindent
\Cref{fig:semantics} shows how to interpret Datafun into any Datafun
model. The standard semantics is an instance of this, letting \catC{} be
\Poset{}, \iso{} be \iso{}, and \pfin{} be the finite powerset functor.
\todo{TODO: explain in more detail?}

Since we have not imposed any laws, there is no useful general equational theory
of Datafun models. Instead, our approach is to relate the models we construct to
the standard model and use \emph{its} equational theory.


%%% ---------- Change posets ----------
%% We're not really using this section at present, and we don't need the full
%% generality of the section on ``Datafun models'' either.
\input{seminaive/sec5-deltaposet}


\section{Semi\naive{} evaluation}
\label{sec:seminaive}

\input{seminaive/fig09-PhiDelta}
\input{seminaive/fig10-seminaive-phi}
\input{seminaive/fig11-seminaive-delta}
\input{seminaive/fig12-dummy}

\todo{TODO: explain \prim{fast-fix}. explain $\Phi$ type transformation as
  ``decorating'' $\isof A$ values with their zero changes so that \prim{fix}
  gets its argument's derivative and can be implemented via \prim{fast-fix}.
  Explain that we need $\Phi{\eqt A}$ to be an eqtype for $\Phi{\tseteq{A}} =
  \tset{\Phi{\eqt A}}$ to be well-formed, and in fact we can be more specific,
  as in \cref{thm:phi-eqtype}.}

\begin{restatable}[$\Phi$ leaves equality types alone]{theorem}{thmPhiEqtype}
  \label{thm:phi-eqtype}
  $\Phi{\eqt A} = \eqt A$.
\end{restatable}
\begin{proof}
  \XXX
\end{proof}

\Cref{fig:seminaive-phi,fig:seminaive-delta} define two mutually recursive
static transformations: $\phi e$, which computes $e$ \emph{semi\naive{}ly},
speeding up fixed point computation by using derivatives; and $\delta e$, which
computes the \emph{derivative} of $\phi e$.
%
To describe the types of $\phi e$ and $\delta e$, we'll need three new operators
on contexts: $\isocx\G$, $\D\G$, and $\Phi\G$. \Cref{fig:PhiDelta} defines these
pointwise by their action on hypotheses. For example,
%\par\nopagebreak[2]\vspace{-.5\baselineskip}
\begin{mathpar}
  \isocx{(\h x A, \hd y B)} = \hd x A, \hd y B

  \D(\h x A, \hd y B) = \h \dx {\D A}

  \Phi(\h x A, \hd y B) = \h x {\Phi A}, \hd y {\Phi B}, \hd \dy {\DP B}
\end{mathpar}

\noindent
The idea is that $\isof\G$, $\D\G$, and $\Phi\G$ mirror the effect of $\iso$,
$\D$, and $\Phi$ on the semantics of $\G$. In particular, $\den{\isocx\G} =
\isof{\den\G}$, and:

\nopagebreak[2]
\begin{align*}
  \den{\D(\h x A)} &\cong \den{\D A}
  &
  \den{\Phi(\h x A)} &\cong \den{\Phi A}
  \\
  \den{\D(\hd x A)} &\cong \den{\D \isof A}
  &
  \den{\Phi(\hd x A)} &\cong \den{\Phi \isof A}
\end{align*}

\noindent
These defined, we can state the sense in which $\phi$ and $\delta$ are
type-correct:

\begin{restatable}[Type-correctness]{theorem}{thmTypeCorrect}
  \label{thm:type-correct}
  If $\J e \G A$, then
  \[ \J {\phi e} {\Phi\G} {\Phi A}
  \qquad\text{and}\qquad
  \J {\delta e} {\isocx{\Phi\G}, \DP\G} {\DP A}
  \]
\end{restatable}
\begin{proof}
  By induction on typing derivations; see \XXX. %\cpageref{proof:typeCorrect}.
\end{proof}

\noindent To get the hang of these context and type transformations, suppose $\J
e {\h x A, \hd y B} C$. Then \cref{thm:type-correct} tells us:

\nopagebreak[2]
\begin{align*}
  \Jalign {\phi e} {\h x {\Phi A}, \hd y {\Phi B}, \hd \dy {\DP B}} {\Phi C}
  \\
  \Jalign {\delta e} {\hd x {\Phi A}, \h\dx{\DP A}, \hd y {\Phi B}, \hd \dy {\DP B}} {\DP C}
\end{align*}


\section{Correctness via logical relations}
\label{sec:logical-relations}

%% TODO: put these in files so we can include them in figures.tex!
\begin{definition} \label{def:changes}
  Inductively on types $A$, we define $(\changesat{A}{\dx}{x}{y})$ for $\dx :
  \den{\D A}$ and $x,y : \den{A}$, glossed as ``$\dx$ changes $x$ into $y$'', as
  the least relation such that:

  \begin{align*}
    \changes{(\dx_i)_i}{(x_i)_i}{(y_i)_i}
    &\impliedby \fa{i} \changes{\dx_i}{x_i}{y_i}
    \\
    \changes{\inj i \dx}{\inj i x}{\inj i y}
    &\impliedby \changes{\dx}{x}{y}
    \\
    \changesat{A \to B}{\df}{f}{g}
    &\impliedby \fa{\changes\dx x y} \changes{\df\<x\<\dx}{f\<x}{g\<y}
    \\
    \changesat{\isof A}{\tuple{}}{x}{x}\\
    \changesat{\tseteq A}{\dx}{x}{(x \cup \dx)}
  \end{align*}

  \noindent This extends to contexts $\G$, letting $\dgamma : \den{\D\G}$ and
  $\g,\g' : \den{\G}$, as follows:

  \begin{align*}
    \changesat{\G}{\dgamma}{\g}{\g'}
    &\iff \fa{\h x A \in \G} \changesat{A}{\dgamma_x}{\g_x}{\g'_x}
    \\
    &\hspace*{1.8em}\wedge
    %\wedge
    \fa{\hd x A \in \G}
    \changesat{\isof A}{\tuple{}}{\g_{\dvar x}}{\g'_{\dvar x}}
  \end{align*}

  \noindent Observe that the condition $\changesat{\isof A}{\tuple{}}{\g_{\dvar
      x}}{\g'_{\dvar x}}$ is equivalent to $\g_{\dvar x} = \g'_{\dvar x}$.

  %% Finally, this extends to \Poset-morphisms $f,g : \den{\G} \to \den{A}$ and
  %% $\df : \den{\isocx \G \x \D\G} \to \den{\D A}$:
  %% \begin{align*}
  %%   \changesat{\G \vdash A}{\df}{f}{g} \impliedby&
  %%   \fa{\changesat{\G}{\dgamma}{\g}{\g'}}
  %%   \changesat{A}{\df\<\tuple{\g,\dgamma}}{f\<\g}{g\<\g'}
  %% \end{align*}
\end{definition}

\begin{definition}\label{def:impls}
  Inductively on types $A$, we define ${\impls_A} \subseteq \den{\Phi A} \x
  \den{A}$ as the least relation such that:
  %\par\nopagebreak[2]\vspace{-1ex}
  \begin{mathpar}
    %% \impls
    \infer{}{a \impls_{\tseteq A} a}

    \infer{x \impls_A a \\ \changesat{\Phi A}\dx x x}{
      (x,\dx) \impls_{\isof A} a}

    \tuple{} \impls_\tunit \tuple{}

    \infer{x \impls_A a \\ y \impls_B b}{
      (x,y) \impls_{A \x B} (a,b)}

    \infer{x \impls_{A_i} a}{\inj i x \impls_{A_1 + A_2} \inj i a}

    \infer{\fa{x \impls_A a} f\<x \impls_B g\<a}{f \impls_{A \to B} g}
  \end{mathpar}

  \noindent
  This lifts to contexts, ${\impls_\G} \subseteq \den{\Phi\G} \x \den\G$, as
  follows:

  \nopagebreak[2]
  \begin{align*}
    \gamma \impls_\G \rho
    &\iff \fa{\h x A \in \G} \gamma_x \impls \rho_x
    %\wedge
    \\&\hspace*{1.8em}\wedge
    \fa{\hd x A \in \G}
    (\gamma_{\dvar x}, \gamma_{\dvar \dx}) \impls_{\isof A} \rho_{\dvar x}
  \end{align*}

  \noindent Observe that the last condition is equivalent to \( (\gamma_{\dvar
    x} \impls_A \rho_{\dvar x}) \wedge (\changesat{A}{\gamma_{\dvar
      \dx}}{\gamma_{\dvar x}}{\gamma_{\dvar x}}) \).
\end{definition}

%% \noindent
%% Which can be lifted to morphisms (and thus term denotations) as follows:

%% \begin{align*}
%%   \impls_{\G \vdash A} &\subseteq \den{\Phi\G \vdash \Phi A} \x \den{\G \vdash A}\\
%%   f \impls_{\G \vdash A} g &\iff \fa{\gamma \impls_\G \gamma'} f\<\gamma \impls_A g\<\gamma'
%% \end{align*}

\begin{restatable}[Correctness]{theorem}{thmCorrect}\label{thm:correct}
  If $\J e \G A$ then

  \begin{enumerate}
  \item If $\gamma \impls_\G \rho$ then \(\den{\phi e} \<\gamma \impls_A \den{e}
    \<\rho\).
  \item If $\changesat{\G}{\dgamma}{\g}{\g'}$ then \(\changesat{A}{\den{\delta
      e} \<\tuple{\gamma,\dgamma}}{\den{\phi e} \<\gamma}{\den{\phi e}
    \<\gamma'}\).
  \end{enumerate}

  %% \nopagebreak[2]
  %% \begin{gather*}
  %% \text{(1)}~~ \den{\phi e}\<\gamma \impls_A \den{e}\<\rho
  %% \qquad\text{and}\qquad
  %% \text{(2)}~~
  %% \vld{\den{\delta e} \tuple{\gamma,\dgamma}}{\den{\phi e} \<\gamma}{\den{\phi e} \<\gamma'}
  %% : \incdens{\Phi{A}}
  %% \end{gather*}

  \noindent
  Note that $\tuple{\gamma,\dgamma}$ is a slight abuse of notation here;
  \todo{TODO explain that \emph{monotone} variables in $\g$ when we use it as
    $\den{\phi e}\<\g$ turn into \emph{discrete} variables in $\extend\g\dgamma$
    when we use it in $\den{\delta e} \<\extend\g\dgamma$}.
\end{restatable}
\begin{proof}
  By induction on the derivation of $\J e \G A$. See \XXX.
  %\cpageref{proof:correct}.
\end{proof}


