%\documentclass[12pt]{rntz}\usepackage[a4]{rntzgeometry}\usepackage[fullwidth=19cm,width=38em,width=36.65625em,]{narrow}
%\documentclass{rntz}\usepackage[b5]{rntzgeometry}\usepackage[fullwidth=158mm,width=373pt,width=360pt,]{narrow}
%\documentclass{rntz}\usepackage[a5]{rntzgeometry}\usepackage[fullwidth=130mm,width=330pt,]{narrow}
%\documentclass[nomarginums]{rntz}\usepackage[b6]{rntzgeometry}\usepackage[width=\textwidth,fullwidth=115mm,]{narrow}\geometry{bottom=36pt}\pagestyle{empty}

%\documentclass{rntz}\usepackage{fantasy}\geometry{textwidth=330pt,}
\documentclass[nomarginums]{rntz}\usepackage[tablet]{fantasy}\geometry{textwidth=330pt}
%\documentclass[nomarginums]{rntz}\usepackage[phone]{fantasy}

\usepackage{latexsym}               % \rightsquigarrow
\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage{amssymb,amsmath,amsthm} % \square etc.
\usepackage{mathtools}              %\dblcolon
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
%\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
\usepackage{accents}                %\underaccent
\usepackage{nccmath}                % fix align* (etc.) spacing
\usepackage{anyfontsize}

% Make section name references use \S.
\makeatletter\crefname{section}{\S\@gobble}{\S\@gobble}\makeatother

% hang is only relevant for long captions, which I don't have
\usepackage[skip=.5\baselineskip,labelsep=period,labelfont=it,textfont=it,format=hang]{caption}
%\usepackage[skip=.5\baselineskip,labelfont=sc,textfont=it,labelsep=period,format=hang]{caption}

\usepackage{enumitem}\setlist{labelindent=1em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=.5em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=0em,labelsep=.75em,leftmargin=*}

%\PassOptionsToPackage{scaled=1.1}{rntzfont} % a4/b5, width=38em/373pt
%\PassOptionsToPackage{scaled=1.0625}{rntzfont} % b5/a4 width=36.66em/360pt
\PassOptionsToPackage{scaled=1.036}{rntzfont} % fantasy[laptop,tablet]
%\PassOptionsToPackage{scaled=.99}{rntzfont} %b6

%% Note to self: don't use newmath, Neel's PC can't handle it.
\usepackage[charter,]{rntzfont}
%\usepackage[source,linespread=1.0233,]{rntzfont}
%\usepackage[librebaskerville,linespread=1.015,]{rntzfont}
%\usepackage[alegreya,scaled=1.01,]{rntzfont}

%% \usepackage[default,scale=.96]{lato}
%% \usepackage[sfdefault,scaled=0.9]{noto}
%% \usepackage{eulervm}\makeatletter\edef\zeu@Scale{1.022}\edef\zeu@Scale{1.077}\makeatother
%% %\usepackage[italic,basic,defaultmathsizes]{mathastext}
%% \linespread{1.054}%\linespread{1.0735}

\ifdefined\mathbold\else\newcommand\mathbold{\boldsymbol}\fi
\usepackage[spacing=true]{microtype}\frenchspacing

\newcommand\mathvar[1]{\ensuremath{#1}} % For upright math font.
%\renewcommand\mathvar[1]{\ensuremath{\mathit{#1}}} % For italic math font.

%% Ooh, check out the typeface package:
%% https://ctan.org/pkg/typeface?lang=en
%% https://mirror.hmc.edu/ctan/macros/latex/contrib/typeface/typeface.pdf
%%
%% Hm, it doesn't handle:
%% - scaling the main text font (!)
%% - all newtxmath's options
%% - newpxtext or newpxmath

\hyphenation{eq-uip-ped}
\hyphenation{inv-olv-ing}

\usepackage{notation}


\title{Change Semantics for Semi\naive{} Datafun}
\author{\scshape Michael Arntzenius}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{ord=omit}
\date{\today}

\begin{document}

%% \noindent
%% % use a math environment to force loading math font.
%% ex/em: \the\fontdimen5\font{} / \the\fontdimen6\font \(\)\\
%% math ex: \the\fontdimen5\textfont1{} / \the\fontdimen6\textfont1\\
%% word space: \the\fontdimen2\font\\
%% baselineskip: \the\baselineskip\\
%% %% \par\begingroup\Large\noindent
%% %% x$x$\emph{x} y$y$\emph{y} v$v$\emph{v} $f$f $t$t $o$o $T$T\emph{T} lIx\\
%% %% fb ff fh fi fj fk fl ft \emph{fb ff fh fi fj fk fl ft} Th \emph{Th}\\
%% %% ffb ffh ffi ffj ffk ffl fft \emph{ffb ffh ffi ffj ffk ffl fft}
%% %% \endgroup\\

\maketitle

\begin{abstract}
  We define \emph{incrementalization} and \emph{semi\naive{} evaluation}
  transformations for Datafun programs, generalizing the classic Datalog
  optimization, and prove them correct semantically.%
\end{abstract}


\section{Strategy}

First, we generalize Datafun's \Poset{} semantics to any category with
appropriate structures (a \emph{Datafun model}; \cref{sec:datafun-models}). We
then define the category \CP{} of posets equipped with increasing changes, whose
morphisms are monotone maps equipped with \emph{derivatives} taking input
changes to output changes (\cref{sec:changeposets}). We construct two Datafun
models in \CP{}, an \emph{incremental} (\cref{sec:incremental}) and a
\emph{semi\naive} (\cref{sec:seminaive}), from which we read off our program
transformations. By construction, the incremental semantics extends the one in
\Poset{}. To prove the semi\naive{} transform correct, we construct a
type-indexed family of natural isomorphisms relating the incremental and
semi\naive{} semantics.

%% TODO: rewrite to match above strategy and add section links


%% ---- Syntax & typing rules ----
\begin{figure*}
  \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
    \text{types} & A,B &\bnfeq& \tunit \bnfor A \x B \bnfor A + B \bnfor A \to B
    \bnfor \isof A \bnfor \tdown{\eqt A}
    \\
    \text{semilattices} & L,M &\bnfeq& \tunit \bnfor L \x M \bnfor A \to L \bnfor \tdown{\eqt A}
    \\
    \text{eqtypes} & \eqt A, \eqt B &\bnfeq&
    \tunit \bnfor \eqt A \x \eqt B \bnfor \eqt A + \eqt B
    \bnfor \isof{\eqt A} \bnfor \tdown{\eqt A}
    \\[.5em]
    \text{terms} & e,f,g &\bnfeq& x \bnfor \dvar x \bnfor \fnof{x} e \bnfor e\<f
    \bnfor \etuple{} \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
    &&&\inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
    &&&\bot \bnfor e \vee f \bnfor \edown{e} \bnfor \ebigvee x e f\\
    &&& \eboxd e \bnfor \elet{\eboxd x = e} f\\
    &&& \prim{isEmpty}\<e \bnfor \esplit e \bnfor \prim{eq}\<e \bnfor \efix e
    \\[.5em]
    \text{contexts} & \G &\bnfeq& (H_i)_i\\
    \text{hypotheses} & H &\bnfeq& \h x A \bnfor \hd x A
  \end{array}\]

  \vspace{-1ex}
  \begin{mathpar}
    \infer{\h x A \in \G}{\J x \G A}

    \infer{\hd x A \in \G}{\J {\dvar x} \G A}

    \infer{\J e {\G,\h x A} B}{\J {\fnof x e} \G {A \to B}}

    \infer{\J e \G {A \to B} \\ \J f \G A}{\J {e\<f} \G B}

    \infer{\quad}{\J {\etuple{}} \G \tunit}

    \infer{(\J{e_i}\G{A_i})_i}{\J{\etuple{e_1,e_2}} \G {A_1 \x A_2}}

    \infer{\J e \G {A_1 \x A_2}}{\J{\pi_i\<e}\G{A_i}}

    \infer{\J e \G A_i}{\J{\inj i e}\G{A_1 + A_2}}

    \infer{\J e \G {A_1 + A_2} \\
      (\J {f_i} {\G,\h {x_i} {A_i}} {B})_i
    }{
      \J {\ecase{e} (\inj i {x_i} \caseto f_i)_i} \G B
    }

    \infer{\quad}{\J\bot\G L}

    \infer{(\J{e_i}\G L)_i}{\J{e_1 \vee e_2}\G L}

    \infer{\J e \G {\eqt A}}{\J {\edown e} \G {\tdown {\eqt A}}}

    \infer{\J e \G {\tdown {\eqt A}} \\
      \J f {\G,\h x {\eqt A}} L
    }{\J {\ebigvee x e f} \G L}

    \infer{\J {\isocolor e} {\stripcx\G} A}{\J{\eboxd e} \G {\isof A}}

    \infer{\J e \G {\isof A} \\ \J f {\G,\hd x A} B}{
      \J {\elet{\eboxd x = e} f} \G B}

    \infer{\J e \G {\tdown \tunit}}{\J {\prim{isEmpty}\<e} \G {\tunit + \tunit}}

    \infer{\J e \G {\isof{(A + B)}}}{\J{\esplit e} \G {\isof A + \isof B}}

    \infer{\J e \G {\isof{(\eqt A \x \eqt A)}}}{\J{\prim{eq}\<e} \G {\tdown\tunit}}

    \infer{\J e \G {\isof{(\eqt L \to \eqt L)}}}{\J{\prim{fix}\< e} \G {\eqt L}}
  \end{mathpar}

  \caption{Datafun core syntax and typing rules}
  \label{fig:core-datafun}
\end{figure*}

\begin{figure*}
  \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
    \text{types} & A,B &\bnfeq& ... \bnfor \tbool \bnfor \tset{\eqt A}
    \\
    \text{terms} & e,f,g &\bnfeq&
    ... \bnfor \esetd{e_i}_i \bnfor \eeqd{e}{f} \bnfor \eford{x}{e} f\\
    &&& \efalse \bnfor \etrue \bnfor \eif e f g \bnfor \ewhen e f\\
    &&& \edcase{e} (\inj i {\dvar{x_i}} \caseto f_i)_{i\in\{1,2\}} \bnfor \efixisd x e
  \end{array}\]

  \begin{mathpar}
    \infer{(\J {\isocolor e_i} {\stripcx\G} A)_i}{
      \J {\esetd{e_i}_i} \G {\tset{A}}}

    \infer{(\J {\isocolor e_i} {\stripcx\G} {\eqt A})_i}
          {\J {\eeqd{e_1}{e_2}} \G \tbool}

    \infer{
      \J e \G {\tset A} \\
      \J f {\G,\hd x A} L
    }{\J {\eford x e f} \G L}

    \infer{\quad}{\J \etrue \G \tbool}

    \infer{\quad}{\J \efalse \G \tbool}

    \infer{\J {\isocolor e} {\stripcx\G} \tbool \\ (\J{f_i}\G B)_i}
          {\J {\eifd e{f_1}{f_2}} \G {B}}

    \infer{\J e \G \tbool \\ \J f \G L}{\J {\ewhen e f} \G L}

    \infer{\J {\isocolor e} {\stripcx{\G}, \h x {\eqt L}} {\eqt L}}
          {\J {\efixisd x e} \G {\eqt L}}
  \end{mathpar}

  \caption{Surface syntax and typing rules}
  \label{fig:surface-syntax}
\end{figure*}

\begin{figure*}
  \begin{align*}
    \tbool &\desugars \tdown{\tunit} &
    \tset{\eqt A} &\desugars \tdown{\isof {\eqt A}}
    \\[.5em]
    \efalse &\desugars \bot &
    \etrue &\desugars \edown{\etuple{}}
    \\
    \eeqd e f &\desugars \prim{eq}\< \eboxd{\etuple{e, f}} &
    \ewhen e f &\desugars \ebigvee {\freshvar\pwild} e f
  \end{align*}

  \begin{align*}
    \esetd{e_i}_i &\desugars \edown\eboxd{e_0} \vee ... \vee \edown\eboxd{e_n}
    \quad \text{(or $\bot$ if $n=0$)}\\
    \eford x e f &\desugars \ebigvee {\freshvar y} e {\elet{\eboxd x = \freshvar y} f}\\
    \eif e {f_1}{f_2} &\desugars
    \ecase{\prim{isEmpty}\<e} (\inj i {\freshvar\pwild} \caseto f_i)_i\\
    \edcase e (\inj i {\dvar{x_i}} \caseto f_i)_i
    &\desugars \ecase{\esplit \eboxd e}
    (\inj i {\freshvar y} \caseto \elet{\eboxd{x_i} = \freshvar y} f_i)_i\\
    \efixisd x e &\desugars \efix \eboxd{\fnof {\color{black} x} e}
  \end{align*}

  \vspace{-.5ex}
  {\small Fresh variables ($\freshvar y$, $\freshvar\pwild$) are marked in \freshvar{pink}.}

  \vspace{.5ex}
  \caption{Desugaring of surface syntax}
  \label{fig:desugaring}
\end{figure*}


\section{Notation and conventions}

\begin{enumerate}
\item Adjacency $f\<x$ denotes the function $f$ applied to an argument $x$.

\item I write $f \then g$ for the composition of morphisms $f : A \to B$ and $g
  : B \to C$. This is the reverse of the usual composition operator, $g \circ
  f$.

  \newcommand\iexpr{\phi}
\item I write $(\iexpr_i)_i$ for the tuple or sequence $(\iexpr_1,
  ..., \iexpr_n)$, leaving $n$ unspecified. For example,
  \[ (2^ix + y_i)_i \quad\text{means}\quad
  (2^1x + y_1,~ 2^2x + y_2,~ ...,~ 2^nx + y_n) \]

  \noindent
  I also use this notation with other braces, eg. $\fork{\iexpr_i}_i =
  \fork{\iexpr_0, ..., \iexpr_n}$.

\item $\initE_A : \initO \to A$ is the unique map out of an initial object;\\
  $\termI_A : A \to \termO$ is the unique map into a terminal object.

\item $A \homto B$ denotes the exponential $B^A$ in a category with
  exponentials.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their \emph{``fork''} $\fork{f_i}_i : A \to \textstyle\prod_{i} B_i$
  uniquely satisfies $\fork{f_i}_i \then \pi_i = f_i$. Dually, given $f_i : A_i
  \to B$ in a category with finite sums, their \emph{``split''} $\krof{f_i}_i :
  \sum_i A_i \to B$ uniquely satisfies $\injc_i \then \krof{f_i}_i = f_i$. So in
  particular, $\fork{} = \termI$ and $\krof{} = \initE$.

\item The comonad $\iso : \Poset \to \Poset$ takes a poset to the
  \emph{discrete} poset on the same elements, defined:
  \[\setlength\arraycolsep{.33em}
  \begin{array}{rcl}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{array}\]
\end{enumerate}


\section{Datafun models}
\label{sec:datafun-models}

The \emph{``standard''} model of Datafun interprets types as posets and terms as
monotone maps. However, with a little care, we can interpret Datafun terms into
any bicartesian closed category \catC{} equipped with the following structures:

\begin{enumerate}
\item A \emph{``discreteness''} comonad $\tuple{\disco{}, \varepsilon, \delta}$.

\item A \emph{``downset''} functor \(\down : \catC \to \catC\) equipped with
  maps
  \begin{align*}
    \morph{strong}_{A,B} &: A \x \downof{B} \to \downof{(A \x B)}\\
    \morph{singleton}_A &: A \to \downof{A}\\
    \morph{isEmpty} &: \discof{\downof{\termO}} \to \termO + \termO
  \end{align*}

\item For any finite family of objects $(A_i)_i$, distributive maps
  \begin{align*}
    \disco_\x &: \prod_i \discof{A_i} \to \disco \prod_i A_i
    &
    \disco_+ &: \disco \sum_i A_i \to \sum_i \discof{A_i}
  \end{align*}

\item \emph{Semilattice objects}, \emph{fixed point objects}, and \emph{equality
  objects} (see \cref{sec:object-families}).

\end{enumerate}

Observe that we have not imposed any laws, so there is no useful general
equational theory of Datafun models. Instead, our approach is to relate the
models we construct to the standard \Poset{} model and use \emph{its} equational
theory. \Cref{fig:general-semantics} shows how to interpret Datafun into any
Datafun model.


\subsection{Object families}
\label{sec:object-families}

To be a Datafun model, semilattice types must be interpreted into
\emph{semilattice objects}; equality types must be interpreted into
\emph{equality objects}; and fixed point types must be interpreted into
\emph{fixed point objects}. A given object $A$ is:


\begin{itemize}
\item A semilattice object when equipped with an \down-algebra $\morph{collect} :
  \downof{A} \to A$ and a family of morphisms $\morph{join}_n : A^n \to A$.

\item An equality object when equipped with a morphism $\morph{eq} : \discof A \x
\discof A \to \downof \termO$.

\item A fixed point object when equipped with a morphism $\morph{fix} : \discof{(A
  \homto A)} \to A$.
\end{itemize}


%% ---- Semantics in a Datafun Model ----
\begin{figure*}
  \emph{Types and contexts}%\vspace{-.5ex}

  \begin{align*}
    \den{\tunit} &= \termO & \den{A \to B} &= \den{A} \homto \den{B}
    \\
    \den{\tdown A} &= \downof{\den{A}} & \den{A \x B} &= \den{A} \x \den{B}
    \\
    \den{\isof A} &= \discof{\den{A}} & \den{A + B} &= \den{A} + \den{B}
  \end{align*}

  \begin{align*}
    \den{\G} &= \prod_{H \in \G} \den{H} &
    \den{\h x A} &= \den{A} & \den{\hd x A} &= \discof{\den{A}}
  \end{align*}

  \vspace{.5ex}\emph{Terms}%\vspace{-.5ex}

  \begin{align*}
    \den{\dvar x} &= \pi_x \then \varepsilon \quad \text{($\dvar x$ discrete)}
    & \den{x} &= \pi_x \quad \text{($x$ monotone)}
    \\
    \den{\fnof x e} &= \lambda\den{e}
    & \den{e\<f} &= \fork{\den{e}, \den{f}} \then \morph{eval}
    \\
    \den{\etuple{e_i}_i} &= \fork{\den{e_i}}_i
    & \den{\pi_i\<e} &= \den{e} \then \pi_i
    \\
    \den{\inj i e} &= \den{e} \then \injc_i
    &
    \den{\bot} &= \termI \then \morph{join}_0
    \\
    \den{e \vee f} &= \fork{\den{e}, \den{f}} \then \morph{join}_2
    &
    \den{\edown e} &= \den{e} \then \morph{singleton}
    \\
    \bigden{\eboxd e} &= \morph{strip} \then \discof{\den e}
    & \bigden{\elet{\eboxd x = e} f} &=
    \fork{\idmorph, \den{e}} \then \den{f}
    \\
    \den{\prim{isEmpty}\<e} &= \den{e} \then \morph{isEmpty}
    & \den{\esplit e} &= \den{e}\then \disco_+
    \\
    \den{\prim{eq}\<e} &= \den{e} \then \morph{eq}
    & \den{\efix e} &= \den{e} \then \morph{fix}
  \end{align*}

  \begin{align*}
    \den{\ecase{e} (\inj i{x_i} \caseto f_i)_i} &=
    \fork{\idmorph, \den{e}} \then \morph{dist}^\x_+
    \then \bigkrof{\den{f_i}}_i
    \\
    \den{\ebigvee x e f} &= \fork{\idmorph,\den{e}} \then \morph{strong}
    \then \downof{\den{f}} \then \morph{collect}
  \end{align*}

  \vspace{.5ex}\emph{Lemmas}%\vspace{-.5ex}

  \begin{align*}
    \morph{dist}^\x_+ &: A \x (B_1 + B_2) \to (A \x B_1) + (A \x B_2)\\
    % this could be simpler if it distributed in the opposite direction.
    \morph{dist}^\x_+ &= \fork{\pi_2 \then \krof{\lambda (\fork{\pi_2,\pi_1} \then \injc_i)}_i, \pi_1}
    \then \morph{eval}
    \\[1ex]
    \morph{strip} &: \den\G \to \discof{\den{\stripcx\G}}\\
    \morph{strip} &= \fork{\pi_{\dvar x} \then \delta}_{\hd x A \in \G} \then \disco_\x
  \end{align*}

  \caption{Datafun semantics in a Datafun model $\tuple{\catC, \disco, \down}$}
  \label{fig:general-semantics}
\end{figure*}


\section{The category \CP}
\label{sec:changeposets}

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \updfn_A)$, where
%
\begin{enumerate}
\item $\vals A \in \Poset$ is the poset of values.

\item $\chgs A \in \Poset$ is the poset of changes.

\item $\updfn : \vals A \x \chgs A \pto \vals A$ is a partial map taking a value
  and a change to an updated value. If $x \upd \dx$ is defined, we say $\dx$ is a
  \emph{valid} change to $x$.

  $\vld{\dx} x y$ means $x \upd \dx$ is defined and equal to $y$. Otherwise,
  equations inv\-olv\-ing \updfn{} should be understood to hold only when it is
  defined.
\end{enumerate}

\noindent
These must satisfy the following conditions:\footnote{There are other conditions
  one might sensibly impose here, most notably, that $x \upd \dx$ is monotone in
  $\dx$. I have not needed this, but the lack of an obvious ``correct'' set of
  conditions bothers me.}

\begin{align*}
  x \le y &\implies \ex{\dx} \vld{\dx} x y
  & \text{complete for increases}\\
  x \le y &\impliedby \ex{\dx} \vld{\dx} x y
  & \text{sound for increases}
\end{align*}

\noindent
Morphisms $f \in \CP(A,B)$ are differentiable maps $f \in \Poset(\vals A, \vals
B)$. A map is differentiable iff it has a derivative $\deriv f : \vals A \to
\Poset(\chgs A, \chgs B)$ such that:

\[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}\]

\noindent Or, equivalently:
\[ f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

\noindent
The same morphism may have many different derivatives; all that matters is that
one exist. We will later exhibit an algorithm to find a derivative of a Datafun
term.

Composition of derivatives follows the chain rule:

\begin{align*}
  \deriv\id \<x\<\dx &= \dx
  & \deriv{(f \circ g)} \<x\<\dx &= \deriv f \<(g\<x) \<(\deriv g\<x\<\dx)
\end{align*}


\subsection{Zero changes and change composition}

Applying the axiom of choice to soundness \& completeness for increases, we
recover operators $\zero$, $(\cdot)$ such that $x \upd \zero_x = x$ and $x \upd
(\dx \cdot \dy) = (x \upd \dx) \upd \dy$. These do not necessarily satisfy the
identity and associativity laws of a category, but $\zero$ will be useful
nonetheless. We will see how to duck this non-constructive use of the axiom of
choice in \cref{sec:incremental}.


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals{A}$
and morphisms $f$ to themselves. The structures we will build in \CP{}
\emph{refine} those in \Poset{}, in the sense of commuting with $\valfn$. For
example, for cartesian products, $\vals{(A \x B)} = \vals{A} \x \vals{B}$ and
$\vals{\fork{f,g}} = \fork{\vals f, \vals g}$.
%
For brevity, we omit the ``value components'' of our constructions when they can
be derived from this fact, only defining $\chgs{A}$ and $\oplus$ and showing the
existence of derivatives.


\subsection{Cartesian structure}

\begin{theorem}
  \CP{} has all finite products and sums.
\end{theorem}

\begin{proof}
  The value-level structure is inherited from \Poset{} along \valfn{}. The
  change-poset structure is also inherited from \Poset{}, while the projection
  and injection's derivatives operate pointwise on changes:

  \begin{align*}
    \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
    \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
    \\
    \deriv\pi_i\<x\<\dx &= \pi_i\<\dx & \deriv\injc_i\<x\<\dx &= \inj i \dx
  \end{align*}

  \noindent Updates are pointwise, noting that $(\inj i x \upd \inj j \dx)$ is
  undefined for $i \ne j$:

  \begin{align*}
    (x_i)_i \upd (\dx_i)_i &= (x_i \upd \dx_i)_i &
    \inj i x \upd \inj i \dx &= \inj i (x \upd \dx)
  \end{align*}

  \noindent
  Soundness \& completeness for increases follow directly from the pointwise
  orderings of products \& coproducts in \Poset{}.

  Fork's derivative $\deriv{\fork{f_i}_i}$ is $\fork{\deriv f_i}_i$:

  \begin{gather*}
    \fork{f_i}_i \<(x \upd \dx)
    = (f_i(x \upd \dx))_i
    = (f_i\<x \upd \deriv f_i \<x \<\dx)_i
    = \fork{f_i}_i \<x \upd \fork{\deriv f_i}_i \<x \<\dx
  \end{gather*}

  \noindent
  A derivative for split must obey \[ \krof{f_i}_i\<(\inj i x \upd \inj i \dx)
  = f_i\<x \upd \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj i \dx) \] so one
  valid choice is

  \[\deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj j \dx)
  =
  \begin{cases}
    \deriv f_i \<x \<\dx & \text{if}~i = j\\
    \deriv f_i \<x \<\zero_x & \text{otherwise}
  \end{cases}
  \]

  \noindent
  The second case is dead code; any value of the right type would do. We will
  exploit this later to avoid needing the axiom of choice (used to define
  $\zero_x$) in the context of Datafun.
\end{proof}


\subsection{Exponentials}

The change poset of the exponential object $\expO A B \in \CP$ consists of maps
$\vals A \to \Poset(\chgs A, \chgs B)$, ordered pointwise. The update relation
is:

\begin{equation}\label{eqn:function-update}
  f \valid\df g : \expO A B
  \iff \fa{x \valid\dx y} f\<x \longvalid{\df\<x\<\dx} g\<y
\end{equation}

\noindent Informally, this says a function change $\df$ is valid so long as it
takes valid input changes to valid output changes: if $\dx$ is a change to $x$,
then $\df\<x\<\dx$ must be a change to $f\<x$.

To show this defines a unique partial function \updfn, suppose $\vld\df f g$ and
$\vld\df f h$ and consider any $x : A$. \Cref{eqn:function-update} applied to
$\vld{\zero_x} x x$ gives us $\longvld{\df\<x\<\zero_x}{f\<x}{g\<x}$ and
$\longvld{\df\<x\<\zero_x}{f\<x}{h\<x}$. Then we know \(f\<x \upd
\df\<x\<\zero_x = g\<x = h\<x \), proving $g = h$. And so, whenever $f \upd \df$
is defined, we have
%
\[ (f \upd \df)\<x = f\<x \upd \df\<x\<\zero_x \]
%
and more generally, \cref{eqn:function-update} can be rewritten:
%
\begin{equation*}
  f\<x \upd \df\<x\<\dx = (f \upd \df)\<(x \upd \dx)
\end{equation*}

\noindent
Soundness \& completeness for increases at $\expO A B$ follows from soundness \&
completeness at $A$ and $B$ and the axiom of choice. % TODO?: Elaborate?

The derivative of the evaluation map is given by

\[\begin{array}{l}
  \deriv{\fname{eval}} \,:\,
  %(\expO{\vals A}{\vals B})
  \Poset(\vals A, \vals B)
  \x \vals A \to
  \Poset({\chgs{(\expO A B)} \x \chgs A},{\chgs B})
  \\
  \deriv{\fname{eval}} \<(f,a) \<(\df,\da) = \df\<a\<\da
\end{array}\]

\noindent
And for $f : \CP(\G \x A, B)$, the derivative of the curried $\fn f : \CP(\G,
\expO A B)$ is given by currying the derivative:

\[
\begin{array}{l}
  \deriv{(\fn f)} \,:\, \vals\G \to \expO{\chgs \G}{\chgs{(\expO A B)}}\\
  \deriv{(\fn f)} \<\gamma \<\mathvar{d\gamma} \<a \<\da
  = \deriv f \<(\gamma,a) \<(\mathvar{d\gamma}, \da)
\end{array}
\]

\noindent
Correctness of $\deriv{\fname{eval}}$ follows from the validity of \df\ and \da;
correctness of $\deriv{(\fn f)}$ follows from correctness of \deriv{f}.

%% Exponential is:
%% eval : (A => B) x A -> B
%%
%% Given f : Γ x A -> B
%% Exists λf : Γ -> (A => B)
%% such that f = (λf × id); eval

% WTS: f ≤ g ⇔ ∃df. f -df-> g

% Suppose f ≤ g.
% WTS: ∃df. f --df--> g.
% Let's calculate! df has to be such that
% ∀(x -dx-> y) f x --df x dx--> g y
% Suppose (x -dx-> y)
%
% Suppose f -df-> g.
% Consider x : A. WTS: f x <= g y. Know x --0x--> x.
% Thus f x --df x 0x--> g x. So by soundness f x <= g x.

%% \begin{align*}
%%   f \le g : \vals{(\expO A B)}
%%   &\iff f \le g : \expO{\vals A}{\vals B}\\
%%   &\iff \fa{x \le y} f\<x \le g\<y\\
%%   &\iff \fa{x,y} (\ex{\dx} \vld{\dx} x y)
%%   \implies \ex{\dx} \vld{\dx}{f\<x}{g\<y}\\
%%   &\iff \todo{???}\\
%%   &\iff \ex{\df} \vld{\df} f g
%% \end{align*}


\subsection{The lifted \iso{} comonad}

\newcommand\setfor[2]{\ensuremath{\{#1 \mathrel{|} #2\}}}

Now we construct a comonad $\iso$ on \CP\ such that $\valfn\iso_\CP =
\iso_\Poset\valfn$. This requirement defines the value-level structure, leaving
only the change poset and update map:

\begin{align*}
  \chgs{\isof A} &= \isof{\chgs A}
  &
  x \oplus_{\isof A} \dx = y &\iff x = y \wedge x \oplus_A \dx = y
\end{align*}

\noindent
So changes are ordered discretely, and \emph{only zero-changes are valid}. This
maintains soundness \& completeness for increases, since $x \le y : \isof A \iff
x = y$.

Functoriality is straightforward to verify:

\begin{align*}
  \iso_\CP(f) = \iso_\Poset(f) = f
  && \deriv{\iso_\CP(f)} = \deriv{\iso_\Poset(f)} = \deriv f
\end{align*}

\noindent
To show $\iso$ is a comonad, it's easy to see that ${\iso} = {\iso\iso}$, so the
duplication natural transformation $\delta : {\iso} \to {\iso\iso}$ is the
identity; the extraction natural transformation $\varepsilon : {\iso} \to
\mathbold{1}$ is given by the subposet inclusion from $\isof A$ to $A$, with
$\deriv{\varepsilon_A} \<x \<\dx = \dx$.

Finally, $\iso_\CP$, like $\iso_\Poset$, distributes over products \& sums. This
follows from the definitions of $\chgs{\iso A}$ and $\updfn_{\iso A}$ and of
products and sums in $\CP$.


\subsection{Semilattice and fixed-point structure}

\todo{TODO}


\section{Incrementalization}
\label{sec:incremental}

\todo{TODO: explain incremental semantics --- it's the ``obvious'' categorical
  semantics in \CP{}. Read off the incrementalization transform. To do this we
  need to fix our non-constructive use of $\zero$, which we do via
  $\fname{dummy} : A \to \chgs A$.}

\newcommand\expandsto{\rightsquigarrow}
\begin{figure*}
  %% TODO: pattern-matching on box types.
  \[\setlength\arraycolsep{.15em}\begin{array}{rcl}
    \ecase{e,\vec f} (p_i, \vec q_{i,j} \caseto g_{i,j})_{i,j}
    &\expandsto& \ecase{e} (p_i \caseto \ecase{\vec f} (\vec q_{i,j} \caseto g_{i,j})_j)_i
    \\[.33em]
    \ecase{e} x \caseto f;\ (p_i \caseto g_i)_i
    &\expandsto& \elet{x = e} f
    \\[.33em]
    \ecase{e} \eboxd x \caseto f;\ (p_i \caseto g_i)_i
    &\expandsto& \elet{\eboxd x = e} f
    \\[.33em]
    \ecase{e} (\etuple{p_i,q_i} \caseto f_i)_i
    &\expandsto& \elet{x = e}\\
    && \ecase{\pi_1\< x,\, \pi_2\< x} (p_i,q_i \caseto f_i)_i
    \\[.33em]
    \ecase{e} (\eboxd{\etuple{p_i,q_i}} \caseto f_i)_i
    &\expandsto& \elet{\eboxd x = e}\\
    && \ecase{\eboxd{\pi_1\<x}, \eboxd{\pi_2\<x}}
    (\eboxd{p_i}, \eboxd{q_i} \caseto f_i)
    \\[.33em]
    \ecase{e} (\inj i p_{i,j} \caseto f_{i,j})_{i,j}
    &\expandsto& \ecase{e} (\inj i x \caseto \ecase{x} (p_{i,j} \caseto f_{i,j})_j)_i
    \\[.33em]
    \ecase{e} (\eboxd{\inj i p_i} \caseto f_i)_i
    &\expandsto& \ecase{\esplit e} (\inj i \eboxd{p_i} \caseto f_i)_i
  \end{array}\]
  \caption{Some pattern-matching elaboration rules}
\end{figure*}

%% \newcommand\extract{{\color{Red}\fname{extract}}}
%% \renewcommand\extract{\error{don't use extract}}

\begin{figure*}
  \begin{mathpar}
    \setlength\arraycolsep{.3em}\begin{array}{lcl}
      \dummy &:& A \to \D A\\
      \dummy \<(\pwild : \tbool) &=& \efalse\\
      \dummy \<(\pwild : \tset{A}) &=& \eset{}\\
      \dummy \<\eboxd{x} &=& \eboxd{\dummy\<x}\\
      \dummy \<(f : A \to B) &=& \fnof{x} \dummy\<(f\<x)\\
      \dummy \<\etuple{x,y} &=& \etuple{\dummy\<x, \dummy\<y}\\
      %% \dummy \<\etuple{x_i}_i &=& \etuple{\dummy\<x_i}_i\\
      \dummy \<(\inj i x) &=& \inj i (\dummy\<x)
    \end{array}
    %%
    %% \begin{array}{l}
    %%   \extract_i ~:~ A_i \to \D A_1 + \D A_2 \to \D A_i\\
    %%   \extract_i\<x\<\dx = \ecase{\dx} \inj i \dx \caseto \dx;\;%\\
    %%   %\phantom{\extract_i\<x\<\dx = \ecase{\dx}}
    %%   \pwild \caseto \dummy\<x
    %%   %\quad\ {\color{ACMPurple} \longleftarrow \textit{Dead code.}}
    %% \end{array}
  \end{mathpar}
  \caption{The \dummy\ function}
  \label{fig:dummy}
\end{figure*}

\begin{figure*}
  \begin{align*}
    \delta x &= \dx\\
    \delta (\fnof{x} e) &= \fnof{\eboxd x}\fnof\dx \delta e &
    \delta (e\<f) &= \delta e \<\eboxd f \<\delta f\\
    \delta \etuple{e,f} &= \etuple{\delta e, \delta f} &
    \delta (\pi_i\<e) &= \pi_i\< \delta e\\
    \delta (\inj i e) &= \inj i {\delta e}\\
    \delta \bot &= \bot &
    \delta (e \vee f) &= \delta e \vee \delta f\\
    \delta \etrue = \delta \efalse &= \efalse
    & \delta\esetd{e_i}_i &= \eset{}\\
    \delta \eboxd{e} &= \eboxd{\delta e}
    & \delta(\esplit e) &= \esplit \delta e
  \end{align*}

  \begin{align*}
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd x = e \mathrel{\kwname{and}} \eboxd\dx = \delta e} \delta f
    \\
    \delta (\efix e) &= \efix (\delta e \<\eboxd{\efix e}) \\
    \delta (\eifd e f g) &= \eifd{e}{\delta f}{\delta g}\\
    \delta (\ewhen e f) &= \eifd e {\delta f} \ewhen{\delta e} f \vee \delta f\\
    \delta (\eford x e f)
    &= (\eford x {\delta e} f)\\
    &\vee (\eford x{e \vee \delta e} \substd{\delta f}{\dx \substo \zero\< x})\\
    \delta (\ecase e (\inj i x \caseto f_i)_i)
    %% &= \ecase{\esplit{\eboxd e}}\\
    %% &\qquad(\inj i \eboxd{x} \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i
    &= \ecase{\esplit{\eboxd e},\, \delta e}\\
    &\qquad ({\inj i \eboxd x,\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad \textit{\commentcolor --- The following cases are unreachable.}\\
    &\qquad ({\inj i \eboxd x,\, \pwild} \caseto
    %\elet{\dx = \dummy\<x}
    \subst{\delta f_i}{\dx \coloneqq \dummy\<x})_i
  \end{align*}
  \caption{The derivative translation}
  \label{fig:derivatives}
\end{figure*}


\section{Semi\naive{} evaluation}
\label{sec:seminaive}

\todo{TODO: explain faster-fix?}

\todo{TODO: explain semi\naive{} semantics --- it's the same except we interpret
  $\iso$ as $\blackiso$ and fix as fast-fix. Read off the semi\naive{}
  transform.}

\todo{TODO: Explain the use of weakening in semi\naive{} $\delta(e\<f)$,
  hilighted in {\color{Rhodamine}pink}.}

\begin{figure*}
  \begin{align*}
    \Phi \tbool &= \tbool & \D\tbool &= \tbool\\
    \Phi \tset{A} &= \tset{\Phi A} & \D\tset{A} &= \tset{\Phi A}\\
    \Phi \isof A &= \isof{(\Phi A \x \D A)}
    & \D\isof A &= \isof \D A\\
    \Phi(A \to B) &= \Phi A \to \Phi B
    & \D(A \to B) &= \isof \Phi A \to \D A \to \D B\\
    \Phi(A \x B) &= \Phi A \x \Phi B & \D(A \x B) &= \D A \x \D B\\
    \Phi(A + B) &= \Phi A + \Phi B & \D(A + B) &= \D A + \D B
  \end{align*}
  \caption{Semi\naive{} type translation}
\end{figure*}

\begin{figure*}
  \begin{align*}
    \phi x &= x & \delta x &= \dx\\
    \phi(\fnof x e) &= \fnof x \phi e
    & \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e\\
    \phi(e\<f) &= \phi e\<\phi f
    & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
    \phi\etuple{e,f} &= \etuple{\phi e, \phi f}
    & \delta\etuple{e,f} &= \etuple{\delta e, \delta f}\\
    \phi(\pi_i\<e) &= \pi_i\<\phi e
    & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
    \phi(\inj i e) &= \inj i \phi e
    & \delta(\inj i e) &= \inj i \delta e\\
    \phi\etrue &= \etrue & \delta\etrue &= \efalse\\
    \phi\efalse &= \efalse & \delta\efalse &= \efalse\\
    \phi\bot &= \bot & \delta\bot &= \bot\\
    \phi(e \vee f) &= \phi e \vee \phi f
    & \delta(e \vee f) &= \delta e \vee \delta f\\
    \phi\esetd{e_i}_i &= \esetd{\phi e_i}_i & \delta\esetd{e_i}_i &= \esetd{}\\
    \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
    & \delta\eboxd{e} &= \eboxd{\delta e}
  \end{align*}

  %% TODO: determine exactly how much syntax sugar I want to allow in the target
  %% of this translation. for example, the case-split I use in \phi(\esplit e)
  %% is only valid *because* \esplit exists.
  %%
  %% Would be nice to give the syntax sugar explicitly, but maybe more effor
  %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.

  %% TODO FIXME: \phi(\fix e), \delta(\fix e)!
  %% TODO FIXME: \phi(if then else), \delta(if then else)!

  \begin{align*}
    \phi(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
    \\
    \delta(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\esplit{\eboxd{\phi e}},\, \delta e}\\
    &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad ({\inj i {\eboxd x},\, \pwild}
      \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
    %% &= \ecase{\esplit{\eboxd{\phi e}}}\\
    %% &\qquad (\inj i \eboxd x
    %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
    %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
    %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
    \\
    \phi(\eford x e f)
    &= \eford{x}{\phi e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
    \substd{\phi f}{\dx \substo \zero\<x}
    \\
    \delta(\eford x e f)
    &= (\eford x{\delta e} \substd{\phi f}{\dx \substo \zero\<x}) \\
    &\vee (\eford x{e \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
    \substd{\delta f}{\dx \substo \zero\<x})
    \\
    \phi(\ewhen e f) &= \ewhen{\phi e} \phi f
    \\
    \delta(\ewhen e f)
    &= \eifd{\phi e}{\delta f} \ewhen{\delta e} \phi f \vee \delta f
    \\
    \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
    \\
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f
    \\
    \phi(\esplit e) &=
    %% \elet{\eboxd{\etuple{y,\dy}} = \phi e}\\
    %% &\phantom{{}={}} \ecase{\esplit{\eboxd y}}\\
    %% &\qquad (\inj i \eboxd x \caseto
    %% \substd{\phi f_i}{\dx \substo \extract_i\<y\<\dy})_i
    %%
    %% \elet{\eboxd{\etuple{x,\dx}} = \phi e}\\
    %% &\phantom{{}={}}\ecase{\esplit {\eboxd x}, \esplit {\eboxd\dx}}\\
    %% &\qquad (\inj i \eboxd x, \inj i \eboxd\dx
    %% \caseto \inj i \eboxd{\etuple{x,\dx}})_i\\
    %% &\qquad (\inj i \eboxd x, \pwild
    %% \caseto \inj i \eboxd{\etuple{x,\dummy\<x}})_i
    %%
    \elet{\eboxd{x} = \phi e}\\
    &\phantom{{}={}} \esplit [\isocolor \ecase x\\
    &\phantom{= \esplit}\quad\isocolor
      (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
    &\phantom{= \esplit}\quad
      {\isocolor(\etuple{\inj i y, \pwild}
        \caseto \inj i \etuple{y, \dummy\<y})_i}]
    %%
    %% \ecase{\phi e}\\
    %% &\qquad (\eboxd{\etuple{\inj i x, \inj i \dx}}
    %% \caseto \inj i \eboxd{x,\dx})_i\\
    %% &\qquad (\eboxd{\etuple{\inj i x, \pwild}}
    %% \caseto \inj i \eboxd{x, \dummy\<x})_{i}
    \\
    \delta(\esplit e) &= \esplit \delta e
  \end{align*}

  \todo{TODO: split cases for non-core syntax into separate figure.}

  \caption{Semi\naive{} term translation}
\end{figure*}

\subsection{The \blackiso{} comonad}

\todo{TODO: explain $\blackiso$}

\end{document}
