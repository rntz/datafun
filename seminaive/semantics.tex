\documentclass[ribbons,9pt]{rntz}\usepackage[a5]{rntzgeometry}%\usepackage[fullwidth=13cm,width=315pt]{narrow}
%\documentclass[nomarginums]{rntz}\usepackage[phone]{fantasy}

%\usepackage{anyfontsize}
%\usepackage{latexsym}               % \rightsquigarrow
%\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage{amssymb,amsmath,amsthm} % \square etc.
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
%\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
\usepackage[f]{esvect}              % \vv for wide vector arrows
\usepackage{nccmath}                % fix align* (etc.) spacing
\usepackage{enumitem}\setlist{labelindent=1em,labelsep=.75em,leftmargin=*}
%\setlist{labelindent=0em,labelsep=.75em,leftmargin=*}

\hyphenation{eq-uip-ped}

\usepackage[source,linespread=1.15]{rntzfont}
%\usepackage[italic,basic,defaultmathsizes]{mathastext}
%\usepackage[charter]{mathdesign}\linespread{1.08}
%\DeclareSymbolFontAlphabet{\mathbb}{AMSb}
\ifdefined\mathbold\else\newcommand\mathbold{\boldsymbol}\fi
\usepackage[spacing=true]{microtype}\frenchspacing

% For euler. TODO: put \mathvar in rntzfont.sty.
\newcommand\mathvar[1]{\ensuremath{#1}}
% Space for function application. Between \; and \:.
\newcommand\<{\mskip 4mu plus 4mu minus 1mu}
%\renewcommand\<\;
\newcommand\da{\mathvar{da}}
\newcommand\db{\mathvar{db}}
\newcommand\dx{\mathvar{dx}}
\newcommand\dy{\mathvar{dy}}
\newcommand\df{\mathvar{df}}
\newcommand\dg{\mathvar{dg}}

% For newmath, pazo, mathdesign, etc.
%\renewcommand\mathvar[1]{\ensuremath{\mathit{#1}}}
%\renewcommand\df{d\kern-.1em f\kern-.1em} % fucking kerning.


%% ===== Commands =====
\newcommand\todo[1]{{\color{Rhodamine}#1}}

\newcommand\naive{na\"ive}
\newcommand\Naive{Na\"ive}
\newcommand\cat\textbf
\newcommand\strong\textbf
\newcommand\CP{\cat{\texorpdfstring{$\Delta$Poset}{DeltaPoset}}}
\newcommand\Poset{\cat{Poset}}
\newcommand\initO{\ensuremath{\mathbold{0}}}
\newcommand\termO{\ensuremath{\mathbold{1}}}
\newcommand\expO[2]{#1 \Rightarrow #2}
\newcommand\initE{\mathop{\text{\textexclamdown}}}
\newcommand\termI{\mathop{!}}

\newcommand\G\Gamma
\newcommand\D\Delta
\newcommand\x\times
\newcommand\pto\rightharpoonup
\newcommand\fn\lambda
\newcommand\dee\delta
\newcommand\tuple[1]{\left({#1}\right)}
\newcommand\triv{\star}
\newcommand\injc{\textrm{in}}
\newcommand\inj[1]{\injc_{#1}\,}
\newcommand\zero{\ensuremath{\mathbold{0}}}

\newcommand\iso{\texorpdfstring{\ensuremath{\square}}{iso}}
\newcommand\isof{\iso}
\newcommand\fname[1]{\textit{#1}}
\newcommand\id{\fname{id}}
\newcommand\dummy{\fname{dummy}}

%% TODO: look at other latex arrows
\newcommand\valfn{\ensuremath{\mathbb{U}}}
%\renewcommand\valfn{\ensuremath{\mathcal{U}}}
\newcommand\vals{\valfn}
\newcommand\chgs[1]{\D{#1}}
\newcommand\deriv[1]{\ensuremath{#1'}}
\newcommand\upd{\mathbin{\oplus}}
\newcommand\updfn{\ensuremath{{\upd}}}

\newcommand\fork[1]{\langle{#1}\rangle}
\newcommand\krof[1]{[{#1}]}
\newcommand\Fork[1]{\left\langle{#1}\right\rangle}
\newcommand\Krof[1]{\left[{#1}\right]}
%% \renewcommand\fork\Fork
%% \renewcommand\krof\Krof

\newcommand\bindsp{~\,}
\newcommand\fa[1]{\forall #1.\bindsp}
\newcommand\ex[1]{\exists #1.\bindsp}


%% Option A
% \leadsto, \rightsquigarrow, \Rightarrow
\newcommand\validarrow\to
\newcommand\valid[1]{\mathrel{\overset{#1}{\validarrow}}}
\newcommand\longvalid[1]{\mathrel{\xrightarrow{#1}}}
\newcommand\vld[3]{{#2 \valid{#1} #3}}
\newcommand\longvld[3]{{#2 \longvalid{#1} #3}}


%% %% Option B
%% \renewcommand\validarrow\leadsto
%% \newcommand\longvalidarrow\validarrow
%% \renewcommand\longvld[3]{{#2 \mathrel{\overset{#1}{\longvalidarrow}} #3}}


%% %% Option C
%% \renewcommand\vld[3]{{#2 \xrsquigarrow{#1} #3}}
%% \renewcommand\longvld[3]{{#2 \xrsquigarrow{#1} #3}}

%% %% Adapted from https://tex.stackexchange.com/questions/233676/leadsto-with-text
%% \usepackage{tikz}
%% \usetikzlibrary{decorations.pathmorphing,shapes}

%% \usepackage{tikz-cd}
%% \usetikzlibrary{decorations.pathmorphing}
%% \newcommand\xrsquigarrow[1]{%
%%     \mathrel{%
%%         \begin{tikzpicture}[%
%%             baseline={(current bounding box.south)}
%%             ]
%%         \node[%
%%             ,inner sep=.44ex
%%             ,align=center
%%             ] (tmp) {$\scriptstyle #1$};
%%         \path[%
%%             ,draw,<-
%%             ,decorate,decoration={%
%%                 ,zigzag
%%                 ,amplitude=0.7pt
%%                 ,segment length=1.2mm,pre length=3.5pt
%%                 }
%%             ] 
%%         (tmp.south east) -- (tmp.south west);
%%         \end{tikzpicture}
%%         }
%%     }


\title{Change Semantics for Semi\naive{} Datafun}
\author{Michael Arntzenius}
\date{5 November 2018}

\begin{document}

\maketitle
\begin{abstract}
  We define the category \CP{} of posets equipped with \emph{increasing
    changes}, whose morphisms are monotone maps equipped with \emph{derivatives}
  taking input changes to output changes. We give a semantics for Datafun in
  \CP.
\end{abstract}


\section{Notation and conventions}

\begin{enumerate}
\item I write $f\<x$ for a function $f$ applied to an argument $x$.

\item $\initE_A : \initO \to A$ is the unique map out of an initial object;\\
  $\termI_A : A \to \initO$ is the unique map into a terminal object.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their ``fork'' $\fork{\vv{f_i}} : A \to \prod_{i} B_i$ uniquely
  satisfies $\pi_i \circ \fork{\vv{f_i}} = f_i$. Dually, given $f_i : A_i \to B$
  in a category with finite sums, their ``split'' $\krof{\vv{f_i}} : \sum_i A_i
  \to B$ uniquely satisfies $\krof{\vv{f_i}} \circ \injc_i = f_i$. So in
  particular, $\fork{} = \termI$ and $\krof{} = \initE$.

\item $\iso : \Poset \to \Poset$ takes a poset to the \emph{discrete} poset on
  the same elements, defined:
  \[\setlength\arraycolsep{.25em}\begin{array}{rcl}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{array}\]
\end{enumerate}


\section{The category \CP}

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \upd_A)$, where
%
\begin{enumerate}
\item $\vals A \in \Poset$ is the poset of values.

\item $\chgs A \in \Poset$ is the poset of changes.

\item $\updfn : \vals A \x \chgs A \pto \vals A$ is a partial map taking a value
  and a change to an updated value. If $x \upd \dx$ is defined, we say $\dx$ is a
  \emph{valid} change to $x$.

  $\vld{\dx} x y$ means $x \upd \dx$ is defined and equal to $y$. Otherwise,
  equations involving \updfn{} should be understood to hold only when it is
  defined.
\end{enumerate}

\noindent
These must satisfy the following conditions:\footnote{There are other conditions
  one might sensibly impose here, most notably, that $x \upd \dx$ is monotone in
  $\dx$. I have not needed this, but the lack of an obvious ``correct'' set of
  conditions bothers me.}

\begin{align*}
  x \le y &\implies \ex{\dx} \vld{\dx} x y
  & \text{complete for increases}\\
  x \le y &\impliedby \ex{\dx} \vld{\dx} x y
  & \text{sound for increases}
\end{align*}

\noindent
Morphisms $f : \CP(A,B)$ are differentiable maps $f \in \Poset(\vals A, \vals
B)$. A map is differentiable iff it has a derivative $\deriv f : \vals A
\to \Poset(\chgs A, \chgs B)$ such that:

\[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}\]

\noindent Or, equivalently:
\[ f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

\noindent
The same morphism may have many different derivatives; all that matters is that
one exist. We will later exhibit an algorithm to find a derivative of a Datafun
term.

Composition of derivatives follows the chain rule:

\begin{align*}
  \deriv\id \<x\<\dx &= \dx
  & \deriv{(f \circ g)} \<x\<\dx &= \deriv f \<(g\<x) \<(\deriv g\<x\<\dx)
\end{align*}


\subsection{Zero changes and change composition}

Applying the axiom of choice to soundness \& completeness for increases, we can
recover operators $\zero$, $(\cdot)$ such that $x \upd \zero_x = x$ and $x \upd
(\dx \cdot \dy) = (x \upd \dx) \upd \dy$. These do not necessarily satisfy the
identity and associativity laws of a category, but will be useful nonetheless.
\todo{TODO: talk about non-constructivity and why it won't be a problem. maybe
  should go in ``strategy'' section at the top?}


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals{A}$
and morphisms $f$ to themselves. The structures we will build in \CP{}
\emph{refine} those in \Poset{}, in the sense of commuting with $\valfn$. For
example, for cartesian products, $\vals{(A \x B)} = \vals{A} \x \vals{B}$ and
$\vals{\fork{f,g}} = \fork{\vals f, \vals g}$.
%
For brevity, we omit the ``value components'' of our constructions when they can
be derived from this fact, only defining $\chgs{A}$ and $\oplus$ and showing the
existence of derivatives.


\section{Cartesian structure}

\begin{theorem}
  \CP{} has all finite products and sums.
\end{theorem}

\begin{proof}
  The value-level structure is inherited from \Poset{} along \valfn{}. The
  change-poset structure is also inherited from \Poset{}, while the projection
  and injection's derivatives operate pointwise on changes:

  \begin{align*}
    \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
    \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
    \\
    \deriv\pi_i\<x\<\dx &= \pi_i\<\dx & \deriv\injc_i\<x\<\dx &= \inj i \dx
  \end{align*}

  \noindent Updates are pointwise, noting that $(\inj i x \upd \inj j \dx)$ is
  undefined for $i \ne j$:

  \begin{align*}
    (x_i)_i \upd (\dx_i)_i &= (x_i \upd \dx_i)_i &
    \inj i x \upd \inj i \dx &= \inj i (x \upd \dx)
  \end{align*}

  \noindent
  Soundness \& completeness for increases follow directly from the pointwise
  orderings of products \& coproducts in \Poset{}.

  Fork's derivative $\deriv{\fork{\vv{f_i}}}$ is $\fork{\vv{\deriv f_i}}$: %% It
  %% suffices to show:

  %% \[x \valid{\dx} y
  %% \implies (f_i\<x)_i \longvalid{\left(\deriv f_i \<x \<\dx\right)_i} (f_i\<y)_i \]

  \begin{gather*}
    \fork{\vv{f_i}}(x \upd \dx)
    = (f_i(x \upd \dx))_i
    = (f_i\<x \upd \deriv f_i \<x \<\dx)_i
    = \fork{\vv{f_i}}\<x \upd \fork{\vv{\deriv f_i}} \<x \<\dx
  \end{gather*}

  %% \noindent Which follows directly from our definition of \updfn{} for product
  %% types.

  \noindent
  A derivative for split must obey \[ \krof{\vv{f_i}}(\inj i x \upd \inj i \dx)
  = f_i\<x \upd \deriv{\krof{\vv{f_i}}} \<(\inj i x) \<(\inj i \dx) \] so one
  valid choice is

  \[\deriv{\Krof{\vv{f_i}}} (\inj i x) \<(\inj j \dx)
  = 
  \begin{cases}
    \deriv f_i \<x \<\dx & \text{if}~i = j\\
    \deriv f_i \<x \<\zero_x & \text{otherwise}
  \end{cases}
  \]

  \noindent
  The second case is dead code; any value of the right type would do. We will
  exploit this later to avoid needing the axiom of choice (used to define
  $\zero_x$) in the context of Datafun.
\end{proof}


\section{Exponential objects}

The change poset of the exponential object $\expO A B \in \CP$ consists of maps
$\vals A \to \Poset(\chgs A, \chgs B)$, ordered pointwise. The update relation
is:

\begin{equation}\label{eqn:function-update}
  f \valid\df g : \expO A B
  \iff \fa{x \valid\dx y} f\<x \longvalid{\df\<x\<\dx} g\<y
\end{equation}

\noindent Informally, this says a function change $\df$ is valid so long as it
takes valid input changes to valid output changes: if $\dx$ is a change to $x$,
then $\df\<x\<\dx$ must be a change to $f\<x$.

To show this defines a unique partial function \updfn, suppose $\vld\df f g$ and
$\vld\df f h$ and consider any $x : A$. \Cref{eqn:function-update} applied to
$\vld{\zero_x} x x$ gives us $\longvld{\df\<x\<\zero_x}{f\<x}{g\<x}$ and
$\longvld{\df\<x\<\zero_x}{f\<x}{h\<x}$. Then we know \(f\<x \upd
\df\<x\<\zero_x = g\<x = h\<x \), proving $g = h$. And so, whenever $f \upd \df$
is defined, we have
%
\[ (f \upd \df)\<x = f\<x \upd \df\<x\<\zero_x \]
%
and more generally, \cref{eqn:function-update} can be rewritten:
%
\begin{equation*}
  f\<x \upd \df\<x\<\dx = (f \upd \df)\<(x \upd \dx) 
\end{equation*}

\noindent
Soundness \& completeness for increases at $\expO A B$ follows from soundness \&
completeness at $A$ and $B$ and the axiom of choice. % TODO?: Elaborate?

The derivative of the evaluation map is given by

\[\begin{array}{l}
  \deriv{\fname{eval}} \,:\,
  %(\expO{\vals A}{\vals B})
  \Poset(\vals A, \vals B)
  \x \vals A \to
  \Poset({\chgs{(\expO A B)} \x \chgs A},{\chgs B})
  \\
  \deriv{\fname{eval}} \<(f,a) \<(\df,\da) = \df\<a\<\da
\end{array}\]

\noindent
And for $f : \CP(\G \x A, B)$, the derivative of the curried $\fn f : \CP(\G,
\expO A B)$ is given by currying the derivative:

\[
\begin{array}{l}
  \deriv{(\fn f)} \,:\, \vals\G \to \expO{\chgs \G}{\chgs{(\expO A B)}}\\
  \deriv{(\fn f)} \<\gamma \<\mathvar{d\gamma} \<a \<\da
  = \deriv f \<(\gamma,a) \<(\mathvar{d\gamma}, \da)
\end{array}
\]

\noindent
Correctness of $\deriv{\fname{eval}}$ follows from the validity of \df\ and \da;
correctness of $\deriv{(\fn f)}$ follows from correctness of \deriv{f}.

%% Exponential is:
%% eval : (A => B) x A -> B
%%
%% Given f : Γ x A -> B
%% Exists λf : Γ -> (A => B)
%% such that f = (λf × id); eval

% WTS: f ≤ g ⇔ ∃df. f -df-> g

% Suppose f ≤ g.
% WTS: ∃df. f --df--> g.
% Let's calculate! df has to be such that
% ∀(x -dx-> y) f x --df x dx--> g y
% Suppose (x -dx-> y)
% 
% Suppose f -df-> g.
% Consider x : A. WTS: f x <= g y. Know x --0x--> x.
% Thus f x --df x 0x--> g x. So by soundness f x <= g x.

%% \begin{align*}
%%   f \le g : \vals{(\expO A B)}
%%   &\iff f \le g : \expO{\vals A}{\vals B}\\
%%   &\iff \fa{x \le y} f\<x \le g\<y\\
%%   &\iff \fa{x,y} (\ex{\dx} \vld{\dx} x y)
%%   \implies \ex{\dx} \vld{\dx}{f\<x}{g\<y}\\
%%   &\iff \todo{???}\\
%%   &\iff \ex{\df} \vld{\df} f g
%% \end{align*}


\section{The lifted \iso{} comonad}

\newcommand\setfor[2]{\ensuremath{\{#1 \mathrel{|} #2\}}}

Now we construct a comonad $\iso$ on \CP\ such that $\valfn\iso_\CP =
\iso_\Poset\valfn$. This requirement defines the value-level structure, leaving
only the change poset and update map:

\begin{align*}
  \chgs{\isof A} &= \isof{\chgs A}
  &
  x \oplus_{\isof A} dx = y &\iff x = y \wedge x \oplus_A dx = y
\end{align*}

\noindent
So changes are ordered discretely, and \emph{only zero-changes are valid}. This
maintains soundness \& completeness for increases, since $x \le y : \isof A \iff
x = y$.

Functoriality is straightforward to verify:

\begin{align*}
  \iso_\CP(f) = \iso_\Poset(f) = f
  && \deriv{\iso_\CP(f)} = \deriv{\iso_\Poset(f)} = \deriv f
\end{align*}

\noindent
To show $\iso$ is a comonad, it's easy to see that ${\iso} = {\iso\iso}$, so the
duplication natural transformation $\delta : {\iso} \to {\iso\iso}$ is the
identity; the extraction natural transformation $\varepsilon : {\iso} \to
\mathbold{1}$ is given by the subposet inclusion from $\isof A$ to $A$, with
$\deriv{\varepsilon_A} \<x \<\dx = \dx$.

Finally, we'd like to show that $\iso_\CP$, like $\iso_\Poset$, distributes over
products \& sums.
\todo{TODO: show distributes over products \& sums.}


\section{Semilattice objects}


\section{Fixed points}


\section{``Reading off'' the change semantics of Datafun}

\end{document}
