%\documentclass[12pt]{rntz}\usepackage[a4]{rntzgeometry}\usepackage[fullwidth=18cm,width=38em,width=420pt,]{narrow}
%\documentclass{rntz}\usepackage[b5]{rntzgeometry}\usepackage[fullwidth=152mm,width=351pt,width=373pt,]{narrow}
%\documentclass{rntz}\usepackage[a5]{rntzgeometry}\usepackage[fullwidth=130mm,width=330pt,]{narrow}
%\documentclass[nomarginums]{rntz}\usepackage[b6]{rntzgeometry}\usepackage[width=\textwidth,fullwidth=115mm,]{narrow}\pagestyle{empty}

\documentclass{rntz}\usepackage{fantasy}%\geometry{textwidth=330pt,}
%\documentclass[nomarginums]{rntz}\usepackage[tablet]{fantasy}%\geometry{textwidth=345pt}
%\documentclass[nomarginums]{rntz}\usepackage[phone]{fantasy}

\usepackage{latexsym}               % \rightsquigarrow
\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage{amssymb,amsmath,amsthm} % \square etc.
\usepackage{mathtools}              %\dblcolon
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
\usepackage{accents}                %\underaccent
\usepackage{nccmath}                % fix align* (etc.) spacing
\usepackage{anyfontsize}
\usepackage{thmtools,thm-restate}   % allow restatable theorems.

% Make section name references use \S.
\makeatletter\crefname{section}{\S\@gobble}{\S\@gobble}\makeatother

% hang is only relevant for long captions, which I don't have
\usepackage[labelsep=period,labelfont=it,textfont=it,format=hang]{caption}
%\usepackage[skip=.5\baselineskip,labelfont=sc,textfont=it,labelsep=period,format=hang]{caption}
%\usepackage[labelfont=sc,labelsep=period,format=hang]{caption}

\usepackage{enumitem}\setlist{labelindent=1em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=.5em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=0em,labelsep=.75em,leftmargin=*}

%\PassOptionsToPackage{scaled=1.0625}{rntzfont} % b5/a4
%\PassOptionsToPackage{scaled=1.036}{rntzfont} % fantasy[laptop,tablet]
%\PassOptionsToPackage{scaled=.99}{rntzfont} %b6

%% Note to self: don't use newmath, Neel's PC can't handle it.
\usepackage[charter,]{rntzfont}
%\usepackage[source,linespread=1.0233,]{rntzfont}
%\usepackage[source,scaled=1.01,linespread=1.0132,linespread=1.015,]{rntzfont}
%\usepackage[librebaskerville,linespread=1.012,]{rntzfont} % zeu@Scale ≈ .98

%% %% Nice for fantasy[phone].
%% \usepackage[sfdefault,scaled=.89060]{noto}
%% \usepackage{eulervm}\makeatletter\edef\zeu@Scale{1.04}\makeatother
%% \usepackage[cal=cm,bb=esstix,scaled=.93,bbscaled=.93]{mathalfa}
%% \renewcommand\mathit\textit\renewcommand\mathrm\textmd % argh
%% \usepackage[basic,defaultmathsizes]{mathastext}
%% \linespread{1.05}%\linespread{1.08}

\ifdefined\mathbold\else\newcommand\mathbold{\boldsymbol}\fi
\usepackage[spacing=true]{microtype}
\frenchspacing

\newcommand\mathvar[1]{\ensuremath{#1}} % For upright math font.
%\renewcommand\mathvar[1]{\ensuremath{\mathit{#1}}} % For italic math font.

%% Ooh, check out the typeface package:
%% https://ctan.org/pkg/typeface?lang=en
%% https://mirror.hmc.edu/ctan/macros/latex/contrib/typeface/typeface.pdf
%%
%% Hm, it doesn't handle:
%% - scaling the main text font (!)
%% - all newtxmath's options
%% - newpxtext or newpxmath

\hyphenation{eq-uip-ped}
\hyphenation{inv-olv-ing}

\usepackage{notation}


\title{Change Semantics for Semi\naive{} Datafun}
\author{\scshape Michael Arntzenius}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{ord=omit}
\date{\today}

\begin{document}%\the\textwidth

%% \noindent
%% % use a math environment to force loading math font.
%% ex/em: \the\fontdimen5\font{} / \the\fontdimen6\font \(\)\\
%% math ex: \the\fontdimen5\textfont1{} / \the\fontdimen6\textfont1\\
%% word space: \the\fontdimen2\font\\
%% baselineskip: \the\baselineskip\\
%% %% \par\begingroup\Large\noindent
%% %% x$x$\emph{x} y$y$\emph{y} v$v$\emph{v} $f$f $t$t $o$o $T$T\emph{T} lIx\\
%% %% fb ff fh fi fj fk fl ft \emph{fb ff fh fi fj fk fl ft} Th \emph{Th}\\
%% %% ffb ffh ffi ffj ffk ffl fft \emph{ffb ffh ffi ffj ffk ffl fft}
%% %% \endgroup\\

\maketitle

\begin{abstract}
  We define \emph{incrementalization} and \emph{semi\naive{} evaluation}
  transformations for Datafun programs, generalizing the classic Datalog
  optimization, and prove them correct semantically.%
\end{abstract}


\section{Strategy}

First, we generalize Datafun's \Poset{} semantics to any category with
appropriate structures (\cref{sec:datafun-models}). With this in mind, we define
a category \CP{} of posets equipped with a notion of \emph{increasing changes},
whose morphisms are monotone maps possessing \emph{derivatives} relating input
changes to output changes (\cref{sec:changeposets}). This gives us an
\emph{incremental semantics} for Datafun (\cref{sec:incremental}). We observe
that one can compute the fixed point of a function more efficiently using its
derivative, and in a higher-order language function derivatives are \emph{zero
  changes}. We give a \emph{``semi\naive{}''} static transformation on Datafun
that augments the discreteness comonad to compute zero-changes. We prove this
correct by relating it to the incremental semantics.

% TODO: more section links once I finish them.


\section{Notation and conventions}

\begin{enumerate}
\item Adjacency $f\<x$ denotes the function $f$ applied to an argument $x$.

\item I write $f \then g$ for the composition of morphisms $f : A \to B$ and $g
  : B \to C$. This is the reverse of the usual composition operator, $g \circ
  f$.

\item I write $\subst{e}{x \substo f}$ to mean ``$e$ with all free occurrences of $x$
  replaced by $f$ ($\alpha$-varying as necessary to avoid capture)''.

  \newcommand\iexpr{\phi}
\item I write $(\iexpr_i)_i$ for the tuple or sequence $(\iexpr_1,
  ..., \iexpr_n)$, leaving $n$ unspecified. For example,

  \nopagebreak[2]
  \[ (2^ix + y_i)_i \quad\text{means}\quad
  (2^1x + y_1,~ 2^2x + y_2,~ ...,~ 2^nx + y_n) \]

  \noindent
  I also use this notation with other braces, eg. $\fork{\iexpr_i}_i =
  \fork{\iexpr_0, ..., \iexpr_n}$.

\item $\expO A B$ denotes the exponential $B^A$ in a cartesian closed category.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their \emph{``fork''} $\fork{f_i}_i : A \to \textstyle\prod_{i} B_i$
  uniquely satisfies $\fork{f_i}_i \then \pi_i = f_i$. Dually, given $f_i : A_i
  \to B$ in a category with finite sums, their \emph{``split''} $\krof{f_i}_i :
  \sum_i A_i \to B$ uniquely satisfies $\injc_i \then \krof{f_i}_i = f_i$.
  %
  So in particular, $\termI : A \to \termO$ is the unique map into the terminal
  object and $\initE : \initO \to B$ the unique map out of the initial object.

\item The comonad $\iso : \Poset \to \Poset$ takes a poset to the
  \emph{discrete} poset on the same elements, defined:

  \begin{eqnarray*}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{eqnarray*}
\end{enumerate}


%% ---- Syntax & typing rules ----
\begin{figure*}
  \begin{mathpar}
    \setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
      \text{types} & A,B &\bnfeq& \isof A \bnfor \tset{\eqt A}
      \bnfor \tunit \bnfor A \x B \bnfor A + B \bnfor A \to B
      \\
      \text{eqtypes} & \eqt A, \eqt B &\bnfeq&
      \isof{\eqt A} \bnfor \tset{\eqt A} \bnfor
      \tunit \bnfor \eqt A \x \eqt B \bnfor \eqt A + \eqt B
      \\
      \text{semilattices} & L,M &\bnfeq&
      \tset{\eqt A} \bnfor \tunit \bnfor L \x M \bnfor A \to L
      \\
      \text{fixtypes} & \fixt L, \fixt M &\bnfeq& \XXX
      \\[.5em]
      \text{terms} & e,f,g &\bnfeq& x \bnfor \dvar x \bnfor \fnof{x} e
      \bnfor e\<f \bnfor \etuple{} \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
      &&& \inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
      &&& \eboxd e \bnfor \elet{\eboxd x = e} f\\
      &&& \bot \bnfor e \vee f \bnfor \esetd{e_i}_i \bnfor \eford x e f\\
      &&& \eeqd e f \bnfor \eisEmpty e \bnfor \esplit e \bnfor \efix e
      \\[.5em]
      \text{contexts} & \G &\bnfeq& (H_i)_i\\
      \text{hypotheses} & H &\bnfeq& \h x A \bnfor \hd x A
    \end{array}
    \\
    \stripcxd\G = (\hd x A)_{\hd x A \in \G}
    \\
    \infer{\h x A \in \G}{\J x \G A}

    \infer{\hd x A \in \G}{\J {\dvar x} \G A}

    \infer{\J e {\G,\h x A} B}{\J {\fnof x e} \G {A \to B}}

    \infer{\J e \G {A \to B} \\ \J f \G A}{\J {e\<f} \G B}

    \infer{\quad}{\J {\etuple{}} \G \tunit}

    \infer{(\J{e_i}\G{A_i})_i}{\J{\etuple{e_1,e_2}} \G {A_1 \x A_2}}

    \infer{\J e \G {A_1 \x A_2}}{\J{\pi_i\<e}\G{A_i}}

    \infer{\J e \G A_i}{\J{\inj i e}\G{A_1 + A_2}}

    \infer{\J e \G {A_1 + A_2} \\
      (\J {f_i} {\G,\h {x_i} {A_i}} {B})_i
    }{
      \J {\ecase{e} (\inj i {x_i} \caseto f_i)_i} \G B
    }

    \infer{\J {\isocolor e} {\stripcxd\G} A}{\J{\eboxd e} \G {\isof A}}

    \infer{\J e \G {\isof A} \\ \J f {\G,\hd x A} B}{
      \J {\elet{\eboxd x = e} f} \G B}

    \infer{\quad}{\J\bot\G {\eqt L}}

    \infer{(\J{e_i} \G {\eqt L})_i}{\J{e_1 \vee e_2}\G {\eqt L}}

    %% \infer{\J e \G {\eqt A}}{\J {\edown e} \G {\tdown {\eqt A}}}
    \infer{(\J {\isocolor e_i} {\stripcxd\G} {\eqt A})_i}{
      \J {\esetd{e_i}_i} \G {\tset{\eqt A}}}

    %% \infer{\J e \G {\tdown {\eqt A}} \\
    %%   \J f {\G,\h x {\eqt A}} L
    %% }{\J {\ebigvee x e f} \G L}
    %%
    \infer{
      \J e \G {\tset A} \\
      \J f {\G,\hd x A} {\eqt L}
    }{\J {\eford x e f} \G {\eqt L}}

    %%\infer{\J e \G {\isof{(\eqt A \x \eqt A)}}}{\J{\prim{eq}\<e} \G {\tdown\tunit}}
    \infer{(\J {\isocolor e_i} {\stripcxd\G} {\eqt A})_i}
          {\J {\eeqd{e_1}{e_2}} \G \tbool}

    \infer{\J {\isocolor e} {\stripcxd\G} {\tset\tunit}}{
      \J {\eisEmpty e} \G {\tunit + \tunit}}

    \infer{\J e \G {\isof{(A + B)}}}{\J{\esplit e} \G {\isof A + \isof B}}

    \infer{\J e \G {\isof{(\fixt L \to \fixt L)}}}{\J{\prim{fix}\< e} \G {\fixt L}}
  \end{mathpar}

  \caption{Datafun core syntax and typing rules}
  \label{fig:core-datafun}
\end{figure*}

\begin{figure*}
  \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
    \text{types} & A,B &\bnfeq& ... \bnfor \tbool\\
    \text{terms} & e,f,g &\bnfeq&
    ... \bnfor \elet{x = e} f \bnfor \efixisd x e\\
    &&& \efalse \bnfor \etrue \bnfor \eif e f g \bnfor \ewhen e f
    % NB. no more \edcase because we just use pattern-matching elaboration
    %\\ &&& %\edcase{e} (\inj i {\dvar{x_i}} \caseto f_i)_{i\in\{1,2\}}
  \end{array}\]

  \begin{mathpar}
    \infer{\quad}{\J\bot\G L}

    \infer{(\J{e_i} \G L)_i}{\J{e_1 \vee e_2}\G L}

    \infer{\J e \G {\tseteq A} \\ \J f {\G,\hd x A} L}{
      \J {\eford x e f} \G L}

    \infer{\J e \G A \\ \J f {\G,\h x A} B}{\J{\elet{x = e} f} \G B}

    \infer{\J {\isocolor e} {\stripcxd{\G}, \h x {\fixt L}} {\fixt L}}
          {\J {\efixisd x e} \G {\fixt L}}

    \infer{\quad}{\J \etrue \G \tbool}

    \infer{\quad}{\J \efalse \G \tbool}

    \infer{\J {\isocolor e} {\stripcxd\G} \tbool \\ (\J{f_i}\G B)_i}
          {\J {\eifd e{f_1}{f_2}} \G {B}}

    \infer{\J e \G \tbool \\ \J f \G L}{\J {\ewhen e f} \G L}
  \end{mathpar}

  \caption{Surface syntax and typing rules}
  \label{fig:surface-syntax}
\end{figure*}

\begin{figure*}

  \begin{align*}
    \tbool &\desugars \tset{\tunit}
    \\
    %% \eeqd e f &\desugars \prim{eq}\< \eboxd{\etuple{e, f}}\\
    %% \esetd{e_i}_i &\desugars \edown\eboxd{e_0} \vee ... \vee \edown\eboxd{e_n} \quad \text{(or $\bot$ if $n=0$)}\\
    %% \eford x e f &\desugars \ebigvee {\freshvar y} e {\elet{\eboxd x = \freshvar y} f}\\
    \eifd e {f_1}{f_2} &\desugars
    \ecase{\eisEmpty e} (\inj i {\freshvar\pwild} \caseto f_i)_i
    %% %% NB. This is mostly redundant with the pattern-matching elaboration in fig:
    %% \edcase e (\inj i {\dvar{x_i}} \caseto f_i)_i
    %% &\desugars \ecase{\esplit \eboxd e}
    %% (\inj i {\freshvar y} \caseto \elet{\eboxd{x_i} = \freshvar y} f_i)_i
    %% \\
  \end{align*}

  \begin{align*}
    \efalse &\desugars \esetd{} &
    \etrue &\desugars \esetd{\etuple{}}
    \\
    \elet{x = e} f &\desugars (\fnof{x} f)\<e &
    \efixisd x e &\desugars \efix \eboxd{\fnof {\color{black} x} e}
  \end{align*}

  %\vspace{-.5ex}
  {\small Fresh variables ($\freshvar y$, $\freshvar\pwild$) are marked in \freshvar{pink}.}
  %\vspace{.5ex}

  \caption{Desugaring of surface syntax}
  \label{fig:desugaring}
\end{figure*}

\begin{figure*}
  \begin{tabular}{rll}
    Surface term & expanded at $A \to L$ & expanded at $L \x M$\\\midrule
    $\bot$
    & \(\fnof{\freshvar\pwild} \bot\)
    & \(\etuple{\bot,\bot}\)
    \\
    \(e \vee f\)
    & \(\fnof{\freshvar x} e\<{\freshvar x} \vee f\<{\freshvar x}\)
    & \(\etuple{\pi_1\<e \vee \pi_1\<f,\, \pi_2\<e\vee\pi_2\<f}\)
    \\
    \(\eford x e f\)
    & \(\fnof{\freshvar y} \eford x e {f\<\freshvar y}\)
    & \(\Etuple{\bigl(\eford x e {\pi_1\<f}\bigr), \bigl(\eford x e {\pi_2\<f}\bigr)}\)
  \end{tabular}

  \caption{Desugaring higher-order semilattice operations}
  \label{fig:desugaring-higher-order-semilattice}
\end{figure*}

%% TODO: check that we have every rule we need.
%% TODO: are any of these redundant/unnecessary?
\begin{figure*}
  \[\setlength\arraycolsep{.15em}\begin{array}{rcl}
    \ecase{e} x \caseto f &\desugars& \elet{x = e} f\\[.33em]
    \ecase{e} \eboxd x \caseto f &\desugars& \elet{\eboxd x = e} f
    \\[.33em]
    %% A * B
    \ecase{e} (\etuple{p_i,q_i} \caseto f_i)_i
    &\desugars& \elet{\freshvar x = e}\\
    && \ecase{\pi_1\< {\freshvar x},\, \pi_2\< {\freshvar x}} (p_i,q_i \caseto f_i)_i
    \\[.33em]
    %% A + B
    \ecase{e} (\inj i p_{i,j} \caseto f_{i,j})_{i,j}
    &\desugars& \ecase{e} (\inj i {\freshvar x}
    \caseto \ecase{\freshvar x} (p_{i,j} \caseto f_{i,j})_j)_i
    \\[.33em]
    %% [](A * B)
    \ecase{e} (\eboxd{\etuple{p_i,q_i}} \caseto f_i)_i
    &\desugars& \elet{\eboxd {\freshvar x} = e}\\
    && \ecase{\eboxd{\pi_1\<\freshvar x}, \eboxd{\pi_2\<\freshvar x}}
    (\eboxd{p_i}, \eboxd{q_i} \caseto f_i)
    \\[.33em]
    %% [](A + B)
    \ecase{e} (\eboxd{\inj i p_i} \caseto f_i)_i
    &\desugars& \ecase{\esplit e} (\inj i \eboxd{p_i} \caseto f_i)_i
    \\[.33em]
    %% multi-case -> nested case
    \ecase{e,\vec f} (p_i, \vec q_{i,j} \caseto g_{i,j})_{i,j}
    &\desugars& \ecase{e} (p_i \caseto \ecase{\vec f} (\vec q_{i,j} \caseto g_{i,j})_j)_i
  \end{array}\]
  \caption{Some pattern-matching elaboration rules}
  \label{fig:desugaring-pattern-matching}
\end{figure*}


\section{Surface syntax and its desugaring}

We present Datafun in two layers: a simpler \emph{core}
(\cref{fig:core-datafun}) and a more liberal \emph{surface}
(\cref{fig:surface-syntax}) whose extensions are desugared into core terms
(\crefrange{fig:desugaring}{fig:desugaring-pattern-matching}).
%
The simpler core terms are easier to \emph{analyse}, so our semantics and static
transformations consume core terms; conversely, surface terms are easier to
\emph{construct}, so we use them in example programs and in the outputs of our
static transformations.

The specific surface features we add are:
\begin{enumerate}
\item Let-bindings.

\item Booleans, ordered $\efalse < \etrue$. Since sum types are ordered
  disjointly, booleans are instead desugared into sets of empty tuples, with
  $\efalse = \emptyset$ and $\etrue = \eset{\etuple{}}$. \todo{TODO: explain
    $(\eisEmpty e)$}.

\item Pattern matching on tuples and boxes. \todo{TODO: explain $\prim{split}$.}

\item In the core language, semilattice operations ($\bot$, $e \vee f$, and
  \kwname{for}-loops) are permitted only at \emph{first-order} semilattice types
  $\eqt L$. This limitation is lifted in the surface language using
  $\eta$-expansion (\cref{fig:desugaring-higher-order-semilattice}).

\item In the core language, we express fixed point computations using what
  amounts to a higher-order operator $\prim{fix} : \isof{(\fixt L \to \fixt L)}
  \to \fixt L$. In the surface language there is a more convenient binding form,
  $\efixisd x e$.

\end{enumerate}


\section{Datafun models}
\label{sec:datafun-models}

The \emph{``standard''} model of Datafun interprets types as posets and terms as
monotone maps. Generalizing this, we can interpret Datafun terms into any
bicartesian closed category \catC{} equipped with the following structures:

\begin{enumerate}
\item A \emph{``discreteness''} comonad $\tuple{\disco{}, \varepsilon, \delta}$
  equipped with distributive morphisms:

  \nopagebreak[2]
  \begin{align*}
    \discox &: \prod_i \discof{A_i} \to \disco \prod_i A_i
    &
    \discosum &: \disco \sum_i A_i \to \sum_i \discof{A_i}
  \end{align*}

\item A \emph{``finite powerset''} functor \(\pfin : \catC \to \catC\) equipped
  with morphisms:

  \nopagebreak[2]
  \begin{align*}
    \morph{singleton}_A &: \isof A \to \pfinof{A} &
    \morph{isEmpty} &: \discof{\pfinof{\termO}} \to \termO + \termO
  \end{align*}

  %% \noindent
  %% and, moreover, for any objects $\G,A$, semilattice object $L$, and morphism $f
  %% : \G \x \isof A \to L$, a ``collecting'' morphism \( \pcollect{f} : \G \x
  %% \pfinof A \to L \).

%% \item \emph{Equality}, \emph{eqsemilattice}, and \emph{fixed point objects},
%%   which must interpret equality types $\eqt A$, equality semilattice types $\eqt
%%   L$, and fixed point types $\fixt L$ respectively. An object $A$ is:
%% %
%%   \begin{itemize}
%%   \item An equality object when equipped with a morphism $\morph{eq} : \discof A
%%     \x \discof A \to \pfinof \termO$.

%%   \item A semilattice object when \emph{also} equipped with morphisms
%%     $\morph{join}_n : A^n \to A$ for every $n : \N$.

%%   \item A fixed point object when \emph{also} equipped with a morphism
%%     $\morph{fix} : \discof{(\expO A A)} \to A$.
%%   \end{itemize}

\item Type-indexed families of morphisms interpreting equality, semilattice
  join, and fixed-point computations:\footnote{It may seem circular to use the
    denotation $\den{A}$ of types in a Datafun model in my \emph{definition} of
    a Datafun model. But there is no real circularity: type denotations do not
    require these morphism families to exist; only term denotations $\den e$
    do.}
  %
  \begin{mathpar}
    \morph{eq} : \isof{\den{\eqt A}} \x \isof{\den{\eqt A}} \to \pfinof\termO

    \morph{join}_n : \den{\eqt L}^n \to \den{\eqt L}

    \morph{fix} : \isof{(\expO{\den{\fixt L}}{\den{\fixt L}})} \to \den{\fixt L}
  \end{mathpar}

\item A family of \emph{collecting morphisms} to interpret \kwname{for}-loops.
  Given objects $\G, A$, a semilattice equality type $\eqt L$, and a morphism $f
  : \G \x \isof{A} \to \den{\eqt L}$, we require a morphism $\pcollect{f} : \G
  \x \pfinof{A} \to \den{\eqt L}$. Or, abusing inference rule notation:
  %
  \[
    \infer{f : \G \x \isof A \to \den{\eqt L}}
          {\pcollect{f} : \G \x \pfinof{A} \to \den{\eqt L}}
  \]

\end{enumerate}

\noindent
\Cref{fig:general-semantics} shows how to interpret Datafun into any Datafun
model. The standard semantics is an instance of this, letting \catC{} be
\Poset{}, \iso{} be \iso{}, and \pfin{} be the finite powerset functor.
\todo{TODO: explain in more detail?}

Since we have not imposed any laws, there is no useful general equational theory
of Datafun models. Instead, our approach is to relate the models we construct to
the standard model and use \emph{its} equational theory.


%% ---- Semantics in a Datafun Model ----
\begin{figure*}
  \figsectionname{Types and Contexts}

  \begin{align*}
    \den{\tunit} &= \termO & \den{A \to B} &= \expO{\den{A}}{\den{B}}
    \\
    \den{\tseteq A} &= \pfinof{\den{\eqt A}}
    & \den{A \x B} &= \den{A} \x \den{B}
    \\
    \den{\isof A} &= \discof{\den{A}} & \den{A + B} &= \den{A} + \den{B}
  \end{align*}

  \begin{align*}
    \den{\G} &= \prod_{H \in \G} \den{H} &
    \den{\h x A} &= \den{A} & \den{\hd x A} &= \discof{\den{A}}
  \end{align*}

  \vspace{.5\baselineskip}
  \figsectionname{Terms}

  \begin{align*}
    \den{\dvar x} &= \pi_{\dvar x} \then \varepsilon \quad \text{($\dvar x$ discrete)}
    & \den{x} &= \pi_x \quad \text{($x$ monotone)}
    \\
    \den{\fnof x e} &= \lambda\den{e}
    & \den{e\<f} &= \fork{\den{e}, \den{f}} \then \morph{eval}
    \\
    \den{\etuple{e_i}_i} &= \fork{\den{e_i}}_i
    & \den{\pi_i\<e} &= \den{e} \then \pi_i
    \\
    \bigden{\eboxd e} &= \morph{strip} \then \discof{\den e}
    & \bigden{\elet{\eboxd x = e} f} &=
    \fork{\id, \den{e}} \then \den{f}
    \\
    \den{\bot} &= \termI \then \morph{join}_0
    &
    \den{e \vee f} &= \fork{\den{e}, \den{f}} \then \morph{join}_2
    \\
    %\den{\color{red}\prim{isEmpty}\<e} &= \den{e} \then \morph{isEmpty}
    \den{\eisEmpty e} &= \den{\eboxd e} \then \morph{isEmpty}
    & \den{\esplit e} &= \den{e}\then \discosum
    \\
    %\den{\color{red}\prim{eq}\<e} &= \den{e} \then \morph{eq}
    \den{\eeqd{e_1}{e_2}} &= \fork{\den{\eboxd{e_i}}}_i \then \morph{eq}
    & \den{\efix e} &= \den{e} \then \morph{fix}
    \\
    %\den{\edown e} &= \den{e} \then \morph{gen} % <- THIS IS WRONG
    \den{\esetd{e_i}_i} &= \fork{\den{\eboxd{e_i}} \then \morph{singleton}}_i \then \morph{join}
    &
    \den{\eford x e f} &=
    \fork{\id,\den{e}} \then \pcollect{\den{f}}
    %\den{\ebigvee x e f} &=
    %\fork{\id,\den{e}} \then \morph{strong} \then \downof{\den{f}} \then \morph{collect}
  \end{align*}

  \begin{align*}
    \den{\inj i e} &= \den{e} \then \injc_i
    \\
    \den{\ecase{e} (\inj i{x_i} \caseto f_i)_i} &=
    \fork{\id, \den{e}} \then \morph{dist}^\x_+ \then \bigkrof{\den{f_i}}_i
    %\bigkrof{\den{f_i}}_i \circ \morph{dist}^\x_+ \circ \fork{\id, \den{e}}
  \end{align*}

  \vspace{.5\baselineskip}
  \figsectionname{Lemmas}

  \begin{align*}
    \morph{dist}^\x_+ &: A \x (B_1 + B_2) \to (A \x B_1) + (A \x B_2)\\
    % this could be simpler if it distributed in the opposite direction.
    \morph{dist}^\x_+ &= \fork{\pi_2 \then \krof{\lambda (\fork{\pi_2,\pi_1} \then \injc_i)}_i, \pi_1}
    \then \morph{eval}
    \\[1ex]
    \morph{strip} &: \den\G \to \discof{\den{\stripcxd\G}}\\
    \morph{strip} &= \fork{\pi_{\dvar x} \then \delta}_{\hd x A \in \G} \then \discox
  \end{align*}

  %% \raggedright\footnotesize Strictly speaking, the cases for
  %% $\den{\esetd{e_i}_i}$, $\den{\eisEmpty e}$, and $\den{\eeqd e f}$ are not
  %% structurally inductive; nonetheless $\den{e}$ is well-defined.

  \caption{Datafun semantics in a Datafun model $\tuple{\catC, \disco, \pfin}$}
  \label{fig:general-semantics}
\end{figure*}


\section{The category \CP}
\label{sec:changeposets}

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \updfn_A)$, where
%
$\vals A$ is a poset of values;
%
$\chgs A$ is a poset of changes;
%
and $\updfn : \vals A \x \chgs A \pto \vals A$ is a \strong{partial} map taking
a value and a change to an updated value.
%
We may also write $\vld{\dx} x y$ to mean that $x \upd \dx = y$ is defined. In
this case we say $\dx$ is a \emph{valid} change to $x$.
%
These must satisfy the following conditions:\footnote{There are other conditions
  one might sensibly impose here, most notably, that $x \upd \dx$ is monotone in
  $\dx$. I have not needed this, but the lack of an obvious ``correct'' set of
  conditions bothers me.}

\nopagebreak[2]
\begin{align*}
  x \le y &\implies \ex{\dx} \vld{\dx} x y
  & \text{complete for increases}\\
  x \le y &\impliedby \ex{\dx} \vld{\dx} x y
  & \text{sound for increases}
\end{align*}

\noindent In particular, for every $x$ there is a (not necessarily unique)
\emph{zero change}, $\zero_x$, such that $x \upd \zero_x = x$.\footnote{Use of
  the $\zero_x$ operator amounts to invoking the axiom of choice.}

Morphisms $f \in \CP(A,B)$ are differentiable maps $f \in \Poset(\vals A, \vals
B)$. A map is differentiable iff it has a derivative $\deriv f : \vals A \to
\Poset(\chgs A, \chgs B)$ such that:

\nopagebreak[2]
\[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}\]

\noindent Or, equivalently:

\nopagebreak[2]
\[ f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

%% % Doesn't work on narrow paper, eg. a5.
%% \nopagebreak
%% \[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}
%% \quad\text{or equivalently}\quad
%% f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

\noindent
The same morphism may have many different derivatives; all that matters is that
one exist.

Composition of derivatives follows the chain rule:

\nopagebreak[2]
\begin{align*}
  \deriv\id \<x\<\dx &= \dx
  & \deriv{(f \circ g)} \<x\<\dx &= \deriv f \<(g\<x) \<(\deriv g\<x\<\dx)
\end{align*}


%\subsection{Zero changes and change composition}

%% Applying the axiom of choice to soundness \& completeness for increases, we
%% recover operators $\zero$, $(\cdot)$ such that $x \upd \zero_x = x$ and $x \upd
%% (\dx \cdot \dy) = (x \upd \dx) \upd \dy$. These do not necessarily satisfy the
%% identity and associativity laws of a category, but $\zero$ will be useful
%% nonetheless. We will see how to duck this non-constructive use of the axiom of
%% choice in \cref{sec:incremental}.


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals{A}$
and morphisms $f$ to themselves. The structures we will build in \CP{}
\emph{refine} those in \Poset{}, in the sense of commuting with $\valfn$. For
example, for cartesian products, $\vals{(A \x B)} = \vals{A} \x \vals{B}$ and
$\vals{\fork{f,g}} = \fork{\vals f, \vals g}$.
%
For brevity, we omit the ``value components'' of our constructions when they can
be derived from this fact, only defining $\chgs{A}$ and $\upd$ and showing the
existence of derivatives.


\subsection{Cartesian structure}
\label{sec:CP-cartesian}

\CP{} has all finite products and sums. The value-level structure is inherited
from \Poset{} along \valfn{}. The change-poset structure is also inherited from
\Poset{}, while the projection and injection's derivatives operate pointwise on
changes:

\nopagebreak[2]
\begin{align*}
  \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
  \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
  %\label{eqn:delta-distributes-over-sums-and-products}
  \\
  \deriv\pi_i\<x\<\dx &= \pi_i\<\dx & \deriv\injc_i\<x\<\dx &= \inj i \dx
\end{align*}

\noindent Updates are pointwise, noting that $(\inj i x \upd \inj j \dx)$ is
undefined for $i \ne j$:

\nopagebreak[2]
\begin{align*}
  (x_i)_i \upd (\dx_i)_i &= (x_i \upd \dx_i)_i &
  \inj i x \upd \inj i \dx &= \inj i (x \upd \dx)
\end{align*}

\noindent
Soundness \& completeness for increases follow directly from the pointwise
orderings of products \& coproducts in \Poset{}.

Fork's derivative $\deriv{\fork{f_i}_i}$ is $\fork{\deriv f_i}_i$:

\nopagebreak[2]
\begin{equation*}
  \fork{f_i}_i \<(x \upd \dx)
  = (f_i(x \upd \dx))_i
  = (f_i\<x \upd \deriv f_i \<x \<\dx)_i
  = \fork{f_i}_i \<x \upd \fork{\deriv f_i}_i \<x \<\dx
\end{equation*}

\noindent
A derivative for split must obey

\nopagebreak[2]
\begin{equation*}
\krof{f_i}_i\<(\inj i x \upd \inj i \dx)
= f_i\<x \upd \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj i \dx)
\end{equation*}

\noindent
so one valid choice is

\nopagebreak[2]
\begin{equation*}
  \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj j \dx)
  =
  \begin{cases}
    \deriv f_i \<x \<\dx & \text{if}~i = j\\
    \deriv f_i \<x \<\zero_x & \text{otherwise}
  \end{cases}
\end{equation*}

\noindent
The second case is dead code; any value of the right type would do. We will
exploit this in \cref{sec:incremental} to avoid needing the axiom of choice
(used to define $\zero_x$) in the context of Datafun.


\subsection{Exponentials}
\label{sec:CP-exponentials}

The change poset of the exponential object $\expO A B \in \CP$ consists of maps
$\vals A \to \Poset(\chgs A, \chgs B)$, ordered pointwise. The update relation
is:

\nopagebreak[2]
\begin{equation}\label{eqn:function-update}
  f \valid\df g : \expO A B
  \iff \fa{x \valid\dx y} f\<x \longvalid{\df\<x\<\dx} g\<y
\end{equation}

\noindent Informally, this says a function change $\df$ is valid so long as it
takes valid input changes to valid output changes: if $\dx$ is a change to $x$,
then $\df\<x\<\dx$ must be a change to $f\<x$.

To show this defines a unique partial function \updfn, suppose $\vld\df f g$ and
$\vld\df f h$ and consider any $x : A$. \Cref{eqn:function-update} applied to
$\vld{\zero_x} x x$ gives us $\longvld{\df\<x\<\zero_x}{f\<x}{g\<x}$ and
$\longvld{\df\<x\<\zero_x}{f\<x}{h\<x}$. Then we know \(f\<x \upd
\df\<x\<\zero_x = g\<x = h\<x \), proving $g = h$. And so, whenever $f \upd \df$
is defined, we have

\nopagebreak[2]
\begin{equation*} (f \upd \df)\<x = f\<x \upd \df\<x\<\zero_x \end{equation*}

\noindent
and more generally, \cref{eqn:function-update} can be rewritten:

\nopagebreak[2]
\begin{equation*} f\<x \upd \df\<x\<\dx = (f \upd \df)\<(x \upd \dx) \end{equation*}

\noindent
Soundness \& completeness for increases at $\expO A B$ follows from soundness \&
completeness at $A$ and $B$ and the axiom of choice. % TODO?: Elaborate?

The derivative of the evaluation map is given by

\nopagebreak[2]
\[\begin{array}{l}
  \deriv{\fname{eval}} \,:\,
  %(\expO{\vals A}{\vals B})
  \Poset(\vals A, \vals B)
  \x \vals A \to
  \Poset({\chgs{(\expO A B)} \x \chgs A},{\chgs B})
  \\
  \deriv{\fname{eval}} \<(f,a) \<(\df,\da) = \df\<a\<\da
\end{array}\]

\noindent
And for $f : \CP(\G \x A, B)$, the derivative of the curried $\fn f : \CP(\G,
\expO A B)$ is given by currying the derivative:

\[
\begin{array}{l}
  \deriv{(\fn f)} \,:\, \vals\G \to \expO{\chgs \G}{\chgs{(\expO A B)}}\\
  \deriv{(\fn f)} \<\gamma \<\mathvar{d\gamma} \<a \<\da
  = \deriv f \<(\gamma,a) \<(\mathvar{d\gamma}, \da)
\end{array}
\]

\noindent
Correctness of $\deriv{\fname{eval}}$ follows from the validity of \df\ and \da;
correctness of $\deriv{(\fn f)}$ follows from correctness of \deriv{f}.

%% Exponential is:
%% eval : (A => B) x A -> B
%%
%% Given f : Γ x A -> B
%% Exists λf : Γ -> (A => B)
%% such that f = (λf × id); eval

% WTS: f ≤ g ⇔ ∃df. f -df-> g

% Suppose f ≤ g.
% WTS: ∃df. f --df--> g.
% Let's calculate! df has to be such that
% ∀(x -dx-> y) f x --df x dx--> g y
% Suppose (x -dx-> y)
%
% Suppose f -df-> g.
% Consider x : A. WTS: f x <= g y. Know x --0x--> x.
% Thus f x --df x 0x--> g x. So by soundness f x <= g x.

%% \begin{align*}
%%   f \le g : \vals{(\expO A B)}
%%   &\iff f \le g : \expO{\vals A}{\vals B}\\
%%   &\iff \fa{x \le y} f\<x \le g\<y\\
%%   &\iff \fa{x,y} (\ex{\dx} \vld{\dx} x y)
%%   \implies \ex{\dx} \vld{\dx}{f\<x}{g\<y}\\
%%   &\iff \todo{???}\\
%%   &\iff \ex{\df} \vld{\df} f g
%% \end{align*}


%% TODO: maybe call this \iso_{\boldsymbol\Delta} instead?
\subsection{The lifted \iso{} comonad and its relatives}
\label{sec:CP-iso}

Now we construct a comonad $\iso$ on \CP\ such that $\valfn\iso_\CP =
\iso_\Poset\valfn$. This requirement defines the value-level structure, leaving
only the change poset and update map. Since $\isof A$ is ordered discretely,
values \emph{cannot} increase. So the simplest definition that is sound and
complete for increases is:

\nopagebreak[2]
\begin{align*}
  \chgs{\isof A} &= \termO
  &
  x \upd_{\isof A} \tuple{} = x
\end{align*}

\noindent
Functoriality, extraction, duplication, and product- and sum-distribution all
refine the corresponding properties of $\iso_\Poset$, and their derivatives are
fairly straightforward:
%
\begin{mathpar}
  \deriv{\iso(f)} \<x \<\tuple{} = \tuple{}

  \deriv\delta_A \<x \<\tuple{} = \tuple{}

  \deriv\varepsilon_A \<x \<\tuple{} = \zero_x
  \\
  \deriv{{\discox}} \<x \<\dx = \tuple{}

  \deriv{{\discosum}} \<(\inj i x) \<\tuple{} = \inj i {\tuple{}}
\end{mathpar}


\subsubsection{The alternative \altiso}

Although we will not use it, there is another refinement of $\iso$ in \CP{},
which I'll call $\altiso$ for clarity, defined like so:

\nopagebreak[2]
\begin{align*}
  \chgs{\altiso A} &= \altiso \chgs A
  &
  x \upd_{\altiso A} \dx = y &\iff x = y \wedge x \upd_A \dx = y
\end{align*}

\noindent
So $\altiso A$ inherits all of $A$'s changes, but ordered discretely and with
\emph{only zero-changes still valid}. The derivatives of functoriality,
duplication, and extraction are different:

\nopagebreak[2]
\begin{align*}
  \deriv{\altiso(f)} &= \deriv f
  & \deriv\delta_A \<x\<\dx &= \dx
  & \deriv\varepsilon_A \<x\<\dx &= \dx
\end{align*}

\noindent
Observe that we no longer need the non-constructive $\zero_x$ to define comonad
extraction $\varepsilon$! However, for our purposes this will not be an issue.
Meanwhile, product- and sum-distribution become identity maps, because $\prod_i
\altiso A_i = \altiso \prod_i A$ and $\sum_i \altiso A_i = \altiso \sum_i
A_i$.\footnote{Checking this is left as an exercise for the reader.}


\subsection{The lifted \pfin\ functor}
\label{sec:CP-pfin}

We lift the finite powerset functor \pfin\ to \CP\ as follows:

\nopagebreak[2]
\begin{align}
  \chgs{\pfinof A} &= \pfinof{\vals A} &
  x \upd_{\pfinof A} \dx &= x \cup \dx
  \label{eqn:CP-pfin}
\end{align}

\noindent
Since the arguments to \morph{singleton} and \morph{isEmpty} cannot change
(having $\iso$ type), their derivatives always return zero-changes:

\nopagebreak[2]
\begin{align*}
  \deriv{\morph{singleton}}_A \<x \<\tuple{} &= \emptyset &
  \deriv{\morph{isEmpty}} \<x \<\tuple{} &= \morph{isEmpty} \< x
\end{align*}

%% \noindent
%% The derivative of $\pcollect f$ is more complicated and is given in
%% \cref{sec:CP-collect}.

%% We lift the free semilattice functor $\down$ to \CP\ as follows:
%% \begin{mathpar}
%%   \chgs{\downof A} = \downof{\vals A}

%%   x \upd_{\downof A} \dx = x \vee_{\downof{\vals A}} \dx
%% \end{mathpar}

%% \noindent
%% Derivatives for its associated morphisms are:

%% \begin{align*}
%%   \morph{gen}_A &: A \to \downof{A}\\
%%   \morph{isEmpty} &: \discof{\downof{\termO}} \to \termO + \termO\\
%%   \morph{strong}_{A,B} &: A \x \downof{B} \to \downof{(A \x B)}
%%   \\
%%   \deriv{\morph{gen}}_A \<x \<\dx &= \color{red}\morph{gen} \<(x \upd \dx)
%%   \\
%%   %% shit, this sucks.
%%   \deriv{\morph{isEmpty}} \<x \<\dx &= \XXX
%%   \\
%%   %% shit, this sucks.
%%   \deriv{\morph{strong}}_{A,B} \<\tuple{a,x} \<\tuple{\da,\dx}
%%   &= \XXX
%% \end{align*}

%% \todo{FIXME: $\upd$ isn't a total function so $\deriv{\morph{gen}}$ fails!}


\subsection{Equality, join, and fixed-point morphisms}
\label{sec:CP-families}

The derivatives of \morph{eq}, \morph{join}, and \morph{fix} are as follows:

\nopagebreak[2]
\begin{align*}
  \deriv{\morph{eq}} \<x \<\tuple{\tuple{},\tuple{}} &= \emptyset &
  \deriv{\morph{join}} \<x \<\dx &= \bigvee_i \pi_i\<\dx &
  \deriv{\morph{fix}} \<x \<\tuple{} &= \bot
\end{align*}

\noindent
Since the inputs to \morph{eq} and \morph{fix} cannot change, being of
\iso\ type, their derivatives need only produce zero-changes. $\emptyset$ is a
zero-change at $\pfinof\termO$ by \cref{eqn:CP-pfin}; to see why $\bot$ is a
zero-change to $\den{\fixt L}$, and why $\deriv{\morph{join}}$ is correct (or
even well-typed), we'll need a small lemma:

\nopagebreak[2]
\begin{restatable}{lemma}{lemEqsemi}
  \label{lem:eqsemi}
  \(\vals{\den{\eqt L}} = \chgs{\den{\eqt L}}\) is a semilattice and $x
  \upd_{\den{\eqt L}} \dx = x \vee \dx$.
\end{restatable}
\begin{proof}
  By induction on $\eqt L$. See \cpageref{proof:eqsemi}.
\end{proof}

\noindent This immediately entails that $\bot$ is a zero-change at
$\den{\eqt{L}}$, and consequently at $\den{\fixt L}$, proving
$\deriv{\morph{fix}}$ correct. It also shows that $\deriv{\morph{join}}$ is
correct:

\nopagebreak[2]
\begin{align*}
  \morph{join}\<(x \upd \dx) &= \bigvee_i \pi_i \<(x \vee \dx)\\
  &= \left(\bigvee_i \pi_i\<x\right) \vee \left(\bigvee_i \pi_i\<\dx\right)\\
  &= \morph{join}\<x \upd \deriv{\morph{join}}\<x\<\dx
\end{align*}


\subsection{Collecting morphisms}
\label{sec:CP-collect}

Let $\G, A$ be objects, $\eqt L$ be a semilattice equality type, and $f : \G \x
\isof A \to \den{\eqt L}$. Our derivative for $\pcollect f : \G \x \pfinof A \to
\den{\eqt L}$ is:

\nopagebreak[2]
\begin{align*}
  \deriv{\pcollect f} \<\tuple{\gamma,s} \<\tuple{d\gamma,\ds}
  &= \bigvee_{x \in \ds} f\<\tuple{\gamma,x} \vee
  \bigvee_{x \in s \cup \ds} \deriv f \<\tuple{\gamma,x} \<\tuple{d\gamma, \zero_x}
\end{align*}

\noindent To establish that this is correct (and even that it type-checks),
\todo{recall that for any semilattice equality type $\eqt L$, we have
  $\chgs{\den{\eqt L}} = \vals{\den{\eqt L}}$ and $x \upd y = x \vee y$}. Now,
suppose $\longvld{d\gamma}{\gamma}{\gamma'} : \G$. From this we have:

\nopagebreak[2]
\begin{align*}
  &\phantom{{}={}}\pcollect{f} \<\tuple{\gamma', s \cup \ds}
  \\
  &= \bigvee_{x \in s \cup \ds} f \<\tuple{\gamma', x}
  \\
  &\overset{\footnotemark}{=} \bigvee_{x \in s \cup \ds} \bigl(f \<\tuple{\gamma,x}
  \vee \deriv f \<\tuple{\gamma,x} \<\tuple{d\gamma,\zero_x}\bigr)
  \\
  &= \bigvee_{x \in s} f\<\tuple{\gamma,x}
  \upd \bigvee_{x \in \ds} f\<\tuple{\gamma,x}
  \vee \bigvee_{x \in s \cup \ds} \deriv f \<\tuple{\gamma,x} \<\tuple{d\gamma,\zero_x}
  \\
  &= \pcollect f \<\tuple{\gamma,s}
  \upd \deriv{\pcollect f} \<\tuple{\gamma,s} \<\tuple{d\gamma,\ds}
\end{align*}

\nopagebreak% for footnote to be on same page as mark
\noindent
Which is what we wished to show.\footnotetext{This equality follows from the
  correctness of $\deriv f$ applied to
  \(\longvld{\tuple{d\gamma,\zero_x}}{\tuple{\gamma,x}}{\tuple{\gamma',x}}\).}


\section{Incrementalization}
\label{sec:incremental}

The \emph{incremental semantics} for Datafun, notated $\incden{-}$, is given
by the Datafun model in \CP{} constructed in \cref{sec:changeposets}, letting
$\disco = \iso_\CP$ and $\pfin = \pfin_\CP$. As we took care to show while
constructing it, this \emph{refines} the standard model along the forgetful
functor $\valfn$, that is:

\begin{restatable}{theorem}{thmForget}
  \label{thm:forget}
  \(\vals{\incden{-}} = \den{-}\).
\end{restatable}

\begin{proof}
  By induction on types and typing derivations; see \cpageref{proof:forget}.
\end{proof}


%\subsection{The change type translation}
Given any Datafun type $A$, its change poset $\D\incdens A$ is internally
definable via the following translation (also named $\D$, despite the risk of
confusion):

\nopagebreak[2]
\begin{align*}
  \D\tunit &= \tunit
  & \D(A \x B) &= \D A \x \D B
  \\
  \D \isof A &= \tunit
  & \D(A + B) &= \D A + \D B
  \\
  \D\tset{\eqt A} &= \tset{\eqt A}
  & \D(A \to B) &= \isof A \to \D A \to \D B
\end{align*}

\begin{restatable}{theorem}{thmDeltaDen}
  \label{thm:delta-den}
  \(\D\incdens A = \den{\D A}\).
\end{restatable}
\begin{proof}
  Induct on types; see \cpageref{proof:delta-den}.
\end{proof}


%% ---- More figures ----
%% \begin{figure*}
%%   \begin{align*}
%%     \delta x &= \dx\\
%%     \delta (\fnof{x} e) &= \fnof{\eboxd x}\fnof\dx \delta e &
%%     \delta (e\<f) &= \delta e \<\eboxd f \<\delta f\\
%%     \delta \etuple{e,f} &= \etuple{\delta e, \delta f} &
%%     \delta (\pi_i\<e) &= \pi_i\< \delta e\\
%%     \delta (\inj i e) &= \inj i {\delta e}\\
%%     \delta \bot &= \bot &
%%     \delta (e \vee f) &= \delta e \vee \delta f\\
%%     \delta \etrue = \delta \efalse &= \efalse
%%     & \delta\esetd{e_i}_i &= \eset{}\\
%%     \delta \eboxd{e} &= \eboxd{\delta e}
%%     & \delta(\esplit e) &= \esplit \delta e
%%   \end{align*}

%%   \begin{align*}
%%     \delta(\elet{\eboxd x = e} f)
%%     &= \elet{\eboxd x = e \mathrel{\kwname{and}} \eboxd\dx = \delta e} \delta f
%%     \\
%%     \delta (\efix e) &= \efix (\delta e \<\eboxd{\efix e}) \\
%%     \delta (\eifd e f g) &= \eifd{e}{\delta f}{\delta g}\\
%%     \delta (\ewhen e f) &= \eifd e {\delta f} \ewhen{\delta e} f \vee \delta f\\
%%     \delta (\eford x e f)
%%     &= (\eford x {\delta e} f)\\
%%     &\vee (\eford x{e \vee \delta e} \substd{\delta f}{\dx \substo \zero\< x})\\
%%     \delta (\ecase e (\inj i x \caseto f_i)_i)
%%     %% &= \ecase{\esplit{\eboxd e}}\\
%%     %% &\qquad(\inj i \eboxd{x} \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i
%%     &= \ecase{\esplit{\eboxd e},\, \delta e}\\
%%     &\qquad ({\inj i \eboxd x,\, \inj i \dx} \caseto \delta f_i)_i\\
%%     &\qquad \textit{\commentcolor --- The following cases are unreachable.}\\
%%     &\qquad ({\inj i \eboxd x,\, \pwild} \caseto
%%     %\elet{\dx = \dummy\<x}
%%     \subst{\delta f_i}{\dx \coloneqq \dummy\<x})_i
%%   \end{align*}
%%   \caption{The derivative translation}
%%   \label{fig:derivatives}
%% \end{figure*}


\section{Semi\naive{} evaluation}
\label{sec:seminaive}

\todo{TODO: explain faster-fix?}

\todo{TODO: explain this type transformation:}
\begin{align*}
  \Phi\tunit &= \tunit &
  \Phi(A \x B) &= \Phi A \x \Phi B\\
  \Phi\isof A &= \isof{(\Phi A \x \D \Phi A)} &
  \Phi(A + B) &= \Phi A + \Phi B\\
  \Phi\tset A &= \tset{\Phi A} &
  \Phi(A \to B) &= \Phi A \to \Phi B
\end{align*}

\newcommand\isocx[1]{{\color{ACMPurple}\lfloor{#1}\rfloor}}

\noindent
\Cref{fig:seminaive-phi,fig:seminaive-delta} define two mutually recursive
static transformations: $\phi e$, which computes $e$ \emph{semi\naive{}ly},
speeding up fixed point computation by using derivatives; and $\delta e$, which
computes the \emph{derivative} of $\phi e$. The type of $\delta e$ involves a
strengthening operator $\isocx{\G}$ that makes every variable in $\G$
discrete:
%
\begin{mathpar}
  \isocx{(H_i)_i} = (\isocx{H_i})_i

  \isocx{\h x A} = \hd x A

  \isocx{\hd x A} = \hd x A
\end{mathpar}

\noindent
Be careful not to confuse this with $\stripcxd{\G}$, which weakens $\G$ by
removing all \emph{except} the discrete variables from $\G$. These defined, we
have:

\begin{restatable}[Type-correctness]{theorem}{thmTypeCorrect}
  \label{thm:type-correct}
  If $\J e \G A$, then
  \[ \J {\phi e} {\Phi\G, \D\Phi\stripcxd{\G}} {\Phi A}
  \qquad\text{and}\qquad
  \J {\delta e} {\isocx{\Phi\G}, \D\Phi\G} {\D\Phi A}
  \]
\end{restatable}
\begin{proof}
  By induction on typing derivations; see \cpageref{proof:typeCorrect}.
\end{proof}

\todo{TODO: Explain the use of weakening in semi\naive{} $\delta(e\<f)$,
  hilighted in {\color{Rhodamine}pink}.}


%% \begin{figure*}
%%   \begin{align*}
%%     \Phi \tunit &= \tunit & \D\tunit &= \tunit\\
%%     \Phi \tdown{\eqt A} &= \tdown{\Phi \eqt A} & \D\tdown{\eqt A} &= \tdown{\Phi \eqt A}\\
%%     \Phi \isof A &= \isof{(\Phi A \x \D A)}
%%     & \D\isof A &= \isof \D A\\
%%     \Phi(A \to B) &= \Phi A \to \Phi B
%%     & \D(A \to B) &= \isof \Phi A \to \D A \to \D B\\
%%     \Phi(A \x B) &= \Phi A \x \Phi B & \D(A \x B) &= \D A \x \D B\\
%%     \Phi(A + B) &= \Phi A + \Phi B & \D(A + B) &= \D A + \D B
%%   \end{align*}
%%   \caption{Semi\naive{} type translation}
%% \end{figure*}


%% ---- Seminaive ("go faster") term translation ----
\begin{figure*}
  %% TODO: think about this translation and syntax sugar. for example, the
  %% case-split I use in \phi(\esplit e) is only valid *because* \esplit exists.
  %%
  %% Would be nice to give the syntax sugar explicitly, but maybe more effor
  %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.
  \figsectionname{Interesting cases}

  \begin{align*}
    \phi(\prim{fix}\<e) &= \prim{fast-fix}\<\phi e\\
    \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
    \\
    \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
    \\
    \phi(\eford x e f)
    &= \eford x {\phi e} {\phi \substd{f}{dx \substo \zero\<x}}
    \\
    %% TODO: check this lines up with \delta(if then else), because that's where
    %% it comes up.
    \phi(\esplit e) &= \ecase{\phi e}\\
    &\phantom{{}={}}\quad
    \left(\eboxd{\etuple{\inj i x, \inj i \dx}}
    \caseto \inj i {\eboxd {\etuple{x,\dx}}}\right)_{i\in\{1,2\}}
    \\
    &\phantom{{}={}}\quad
    \left(\eboxd{\etuple{\inj i x, \pwild}}
    \caseto \inj i {\eboxd {\etuple{x, \dummy\<x}}} \right)_{i\in\{1,2\}}
    %% \phi(\esplit e) &= \color{red} \elet{\eboxd{x} = \phi e}\\
    %% &\phantom{{}={}} \esplit [\isocolor \ecase x\\
    %% &\phantom{= \esplit}\quad\isocolor
    %%   (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
    %% &\phantom{= \esplit}\quad
    %%   {\isocolor(\etuple{\inj i y, \pwild}
    %%     \caseto \inj i \etuple{y, \dummy\<y})_i}]
  \end{align*}
  \vspace{0pt} % <- yes, this matters.

  \figsectionname{Distributive cases}

  \begin{align*}
    %% TODO: I should mark discrete vs. monotone variables in some
    %% (colorblind/greyscale-printing)-safe way.
    \phi x &= x & \phi \dvar x &= \dvar x\\
    \phi(\fnof x e) &= \fnof x \phi e & \phi(e\<f) &= \phi e\<\phi f\\
    \phi\etuple{e_i}_i &= \etuple{\phi e_i}_i &
    \phi(\pi_i\<e) &= \pi_i\<\phi e\\
    \phi(\inj i e) &= \inj i \phi e\\
    \phi\bot &= \bot &
    \phi(e \vee f) &= \phi e \vee \phi f\\
    \phi(\esetd{e_i}_i) &= \esetd{\phi e_i}_i &
    \phi(\eeqd e f) &= \eeqd {\phi e} {\phi f}
  \end{align*}

  \begin{align*}
    \phi(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
    \\
    \phi(\eisEmpty e) &= \eisEmpty {\phi e}
  \end{align*}

  \todo{TODO: eta-expand $\vee$ etc. at functional types! Probably do this in
    elaborator.}

  \todo{TODO: distribution of $\iso$ over sums is no longer equality! does
    $\phi(\esplit e)$ need to change?}

  \caption{Semi\naive{} speed-up translation, $\phi$}
  \label{fig:seminaive-phi}
\end{figure*}


%% ----- Figure: Seminaive δ derivative -----
\begin{figure*}
  \[ \delta\bot = \delta\esetd{e_i}_i = \delta(\eeqd e f) = \delta(\efix e) = \bot \]

  \begin{align*}
    \delta x &= \dx &
    \delta \dvar x &= \dvar\dx\\
    \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e
    & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
    \delta\etuple{e_i}_i &= \etuple{\delta e_i}_i
    & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
    \delta(\inj i e) &= \inj i {\delta e} &
    \delta(e \vee f) &= \delta e \vee \delta f\\
    \delta\eboxd{e} &= \etuple{} &
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd{\etuple{x,\dx}} = \color{Rhodamine}\phi e} \delta f\\
    \delta(\eisEmpty e) &= \eisEmpty {\color{Rhodamine} \phi e} &
    \delta(\esplit e) &= \color{red} \esplit \delta e
  \end{align*}

  \begin{align*}
    %% TODO: double-check this!
    \delta(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\esplit{\eboxd{\color{Rhodamine} \phi e}},\, \delta e}\\
    &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad ({\inj i {\eboxd x},\, \pwild}
      \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
    %% &= \ecase{\esplit{\eboxd{\phi e}}}\\
    %% &\qquad (\inj i \eboxd x
    %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
    %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
    %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
    \\
    %% \delta(\ebigvee x e f)
    %% &= (\ebigvee x {\delta e} {\color{Rhodamine}\phi f})
    %% \vee
    %% (\ebigvee x {{\color{Rhodamine}\phi e} \vee \delta e} {\delta f})
    %% TODO: is weakening being used here?
    \delta(\eford x e f)
    &= (\eford x {\delta e} \substd{\color{Rhodamine} \phi f}{\dx \substo \zero\<x}) \\
    &\vee (\eford x {{\color{Rhodamine}\phi e} \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
    \substd{\delta f}{\dx \substo \zero\<x})
  \end{align*}

  \todo{TODO: double-check $\delta(\ecase e ...)$}\\
  \todo{TODO: does $\delta(\eford x e f)$ weaken $\phi f$?}\\
  \todo{TODO: since distribution of $\iso$ over sums isn't equality, doesn't
    $\delta(\esplit e)$ need to be changed?}

  \caption{Semi\naive{} derivative translation, $\delta$}
  \label{fig:seminaive-delta}
\end{figure*}


%% ---- old seminaive term translation ----
%% \begin{figure*}
%%   \begin{align*}
%%     \phi x &= x & \delta x &= \dx\\
%%     \phi(\fnof x e) &= \fnof x \phi e
%%     & \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e\\
%%     \phi(e\<f) &= \phi e\<\phi f
%%     & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
%%     \phi\etuple{e,f} &= \etuple{\phi e, \phi f}
%%     & \delta\etuple{e,f} &= \etuple{\delta e, \delta f}\\
%%     \phi(\pi_i\<e) &= \pi_i\<\phi e
%%     & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
%%     \phi(\inj i e) &= \inj i \phi e
%%     & \delta(\inj i e) &= \inj i \delta e\\
%%     \phi\etrue &= \etrue & \delta\etrue &= \efalse\\
%%     \phi\efalse &= \efalse & \delta\efalse &= \efalse\\
%%     \phi\bot &= \bot & \delta\bot &= \bot\\
%%     \phi(e \vee f) &= \phi e \vee \phi f
%%     & \delta(e \vee f) &= \delta e \vee \delta f\\
%%     \phi\esetd{e_i}_i &= \esetd{\phi e_i}_i & \delta\esetd{e_i}_i &= \esetd{}\\
%%     \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
%%     & \delta\eboxd{e} &= \eboxd{\delta e}
%%   \end{align*}

%%   %% TODO: determine exactly how much syntax sugar I want to allow in the target
%%   %% of this translation. for example, the case-split I use in \phi(\esplit e)
%%   %% is only valid *because* \esplit exists.
%%   %%
%%   %% Would be nice to give the syntax sugar explicitly, but maybe more effor
%%   %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.

%%   %% TODO FIXME: \phi(\fix e), \delta(\fix e)!
%%   %% TODO FIXME: \phi(if then else), \delta(if then else)!

%%   \begin{align*}
%%     \phi(\ecase e (\inj i x \caseto f_i)_i)
%%     &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
%%     \\
%%     \delta(\ecase e (\inj i x \caseto f_i)_i)
%%     &= \ecase{\esplit{\eboxd{\phi e}},\, \delta e}\\
%%     &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
%%     &\qquad ({\inj i {\eboxd x},\, \pwild}
%%       \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
%%     %% &= \ecase{\esplit{\eboxd{\phi e}}}\\
%%     %% &\qquad (\inj i \eboxd x
%%     %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
%%     %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
%%     %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
%%     \\
%%     \phi(\eford x e f)
%%     &= \eford{x}{\phi e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
%%     \substd{\phi f}{\dx \substo \zero\<x}
%%     \\
%%     \delta(\eford x e f)
%%     &= (\eford x{\delta e} \substd{\phi f}{\dx \substo \zero\<x}) \\
%%     &\vee (\eford x{e \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
%%     \substd{\delta f}{\dx \substo \zero\<x})
%%     \\
%%     \phi(\ewhen e f) &= \ewhen{\phi e} \phi f
%%     \\
%%     \delta(\ewhen e f)
%%     &= \eifd{\phi e}{\delta f} \ewhen{\delta e} \phi f \vee \delta f
%%     \\
%%     \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
%%     \\
%%     \delta(\elet{\eboxd x = e} f)
%%     &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f
%%     \\
%%     \phi(\esplit e) &=
%%     %% \elet{\eboxd{\etuple{y,\dy}} = \phi e}\\
%%     %% &\phantom{{}={}} \ecase{\esplit{\eboxd y}}\\
%%     %% &\qquad (\inj i \eboxd x \caseto
%%     %% \substd{\phi f_i}{\dx \substo \extract_i\<y\<\dy})_i
%%     %%
%%     %% \elet{\eboxd{\etuple{x,\dx}} = \phi e}\\
%%     %% &\phantom{{}={}}\ecase{\esplit {\eboxd x}, \esplit {\eboxd\dx}}\\
%%     %% &\qquad (\inj i \eboxd x, \inj i \eboxd\dx
%%     %% \caseto \inj i \eboxd{\etuple{x,\dx}})_i\\
%%     %% &\qquad (\inj i \eboxd x, \pwild
%%     %% \caseto \inj i \eboxd{\etuple{x,\dummy\<x}})_i
%%     %%
%%     \elet{\eboxd{x} = \phi e}\\
%%     &\phantom{{}={}} \esplit [\isocolor \ecase x\\
%%     &\phantom{= \esplit}\quad\isocolor
%%       (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
%%     &\phantom{= \esplit}\quad
%%       {\isocolor(\etuple{\inj i y, \pwild}
%%         \caseto \inj i \etuple{y, \dummy\<y})_i}]
%%     %%
%%     %% \ecase{\phi e}\\
%%     %% &\qquad (\eboxd{\etuple{\inj i x, \inj i \dx}}
%%     %% \caseto \inj i \eboxd{x,\dx})_i\\
%%     %% &\qquad (\eboxd{\etuple{\inj i x, \pwild}}
%%     %% \caseto \inj i \eboxd{x, \dummy\<x})_{i}
%%     \\
%%     \delta(\esplit e) &= \esplit \delta e
%%   \end{align*}

%%   \todo{TODO: split cases for non-core syntax into separate figure.}

%%   \caption{Semi\naive{} term translation}
%% \end{figure*}


%% ----- Figure: Dummy function -----
\begin{figure*}
  \[\setlength\arraycolsep{.3em}\begin{array}{lcl}
    \dummy &:& A \to \D A\\
    \dummy \<(\pwild : \tbool) &=& \efalse\\
    \dummy \<(\pwild : \tset{A}) &=& \eset{}\\
    \dummy \<\eboxd{x} &=& \eboxd{\dummy\<x}\\
    \dummy \<(f : A \to B) &=& \fnof{x} \dummy\<(f\<x)\\
    \dummy \<\etuple{x,y} &=& \etuple{\dummy\<x, \dummy\<y}\\
    %% \dummy \<\etuple{x_i}_i &=& \etuple{\dummy\<x_i}_i\\
    \dummy \<(\inj i x) &=& \inj i (\dummy\<x)
  \end{array}\]
  \caption{The \dummy\ function}
  \label{fig:dummy}
\end{figure*}


\section{Proof obligations when extending Datafun}

%% TODO: section on "proof obligations when extending Datafun"

\todo{This is all pretty speculative. I haven't given a proof that is
  parameterized enough to state that I've covered all my bases here. TODO: more.}

\begin{enumerate}
\item If you add a new first-order type, you must extend \dummy{} to compute
  $\zero$ for it.

\item Make sure that $\delta\bot$, $\delta(e \vee f)$, and $\delta(\eford x e
  f)$ are still correct. In particular, suppose you add a new type constructor
  $T$ and consider any $\vec A$ such that $T\vec A$ is a semilattice
  type.\footnote{A base type is simply a nullary type constructor. If there are
    no $\vec A$ such that $T\vec A$ is a semilattice, you're done.}

  The simplest way to keep everything working is to ensure that $\D(T\vec A) =
  T\vec A$ and $\upd_{T\vec A} = \vee$; then you're done. But if $T\vec A$ is
  higher-order, this is unlikely to be true.

  Alternatively, so long as $\D(T\vec A)$ is a semilattice type whose join composes
  changes~--- that is, if $x \upd \bot = x$ and $x \upd (y \vee z) = (x \upd y)
  \upd z$~--- then $\delta\bot$ and $\delta(e \vee f)$ remain correct. This
  \emph{is} the case for functions. So how do we repair $\delta(\eford x e f)$?
  Well, Datafun's current solution is to \emph{expand away} higher-order uses of
  \kwname{for}; if you can likewise expand away uses of \kwname{for} at type
  $T\vec A$, you're set.

  Otherwise, you're on your own. You'll have to find a new definition of
  $\delta(\eford x e f)$ at type $T\vec A$ and prove it correct. Likewise, if
  $\D(T\vec A)$ isn't a semilattice whose join corresponds to change
  composition, you'll need new definitions of $\delta\bot$ and $\delta(e \vee f)$.

\end{enumerate}


\clearpage
\appendix
\begin{center}\Large\scshape Proofs\end{center}

%\section{Proofs}

%% \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
%%   \text{terms} & e,f,g &\bnfeq& x \bnfor \dvar x \bnfor \fnof{x} e
%%   \bnfor e\<f \bnfor \etuple{} \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
%%   &&&\inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
%%   &&&\bot \bnfor e \vee f \bnfor \edown{e} \bnfor \ebigvee x e f\\
%%   &&& \eboxd e \bnfor \elet{\eboxd x = e} f\\
%%   &&& \prim{isEmpty}\<e \bnfor \esplit e \bnfor \prim{eq}\<e \bnfor \efix e
%% \end{array}\]


\todo{FIXME: wrong numbering!}
\lemEqsemi*
\begin{proof}\label{proof:eqsemi}
  By induction on $\eqt L$:

  \begin{description}
  \item[Case $\tunit$:] \(\vals{\den \tunit} = \chgs{\den \tunit} = \termO\),
    which is the trivial semilattice, and \(\tuple{} \upd \tuple{} = \tuple{}
    = \tuple{} \vee \tuple{}\).

  \item[Case $\eqt L \x \eqt M$:] \(\den{\eqt L \x \eqt M} = \den{\eqt L} \x
    \den{\eqt M}\), and by IH $\vals{\den{\eqt L}} = \chgs{\den{\eqt L}}$ and
    \(\vals{\den{\eqt M}} = \chgs{\den{\eqt M}}\) and both are semilattices. The
    product of semilattices is a semilattice itself, and update and semilattice
    join on products are both pointwise.

  \item[Case $\tseteq A$:] By \cref{eqn:CP-pfin}.
  \end{description}
\end{proof}


\thmForget*
\begin{proof}\label{proof:forget}

  We will make frequent and unremarked use of definitions from
  \cref{sec:changeposets}. First we induct on types to show $\vals{\incdens A} =
  \den A$. Equalities given by an inductive hypothesis are marked with a star,
  like so: $\stareq$.

  \begin{description}
    \item[Case $\isof A$:] \(\vals{\incdens{\isof A}}
      = \vals{\discof{\incdens A}}
      = \isof{\vals{\incdens A}} \stareq \isof{\den A}
      = \den{\isof A} \)

    %% \item[Case $\tset{\eqt A}$:]
    %%   \(\vals{\incdens{\tset{\eqt A}}} = \vals{\downof{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\vals{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\isof{\vals{\incdens{\eqt A}}}}
    %%   \stareq \downof{\isof{\den{\eqt A}}}
    %%   = \den{\tset{\eqt A}} \)

    \item[Case $\tset{\eqt A}$:]
      \(\vals{\incdens{\tset{\eqt A}}}
      = \vals{\pfinof{\incdens{\eqt A}}}
      = \pfinof{\vals{\incdens{\eqt A}}}
      \stareq \pfinof{\den{\eqt A}}
      = \den{\tset{\eqt A}} \)

      \todo{TODO: double-check against definitions in \cref{sec:CP-pfin}}

    \item[Case $\tunit$:] \(\vals{\incdens \tunit} = \vals\termO = \termO = \den{\tunit}\)

    \item[Case $A \x B$:] \(\vals{\incden{A \x B}}
      = \vals{(\incdens A \x \incdens B)}
      = \vals{\incdens A} \x \vals{\incdens B}
      \stareq \den{A} \x \den{B}
      = \den{A \x B} \)

    \item[Case $A + B$:] \(\vals{\incden{A + B}}
      = \vals{(\incdens A + \incdens B)}
      = \vals{\incdens A} + \vals{\incdens B}
      \stareq \den{A} + \den{B}
      = \den{A + B}
      \)

    \item[Case $A \to B$:] \(\vals{\incden{A \to B}}
      = \vals{(\expO{\incdens A}{\incdens B})}
      = \expO{\vals\incdens A}{\vals\incdens B}
      \stareq \expO{\den A}{\den B}
      = \den{A \to B}
      \)
  \end{description}

  \noindent
  Then we induct on typing derivations to show $\vals \incdens e = \den e$:

  \begin{description}
  \item[Case $x$] \XXX
  \item[Case $\dvar x$] \XXX
  \item[Case $\fnof x e$] \XXX
  \item[Case $e\<f$] \XXX
  \item[Case $\etuple{}$] \XXX
  \item[Case $\etuple{e,f}$] \XXX
  \item[Case $\pi_i\<e$] \XXX
  \item[Case $\inj i e$] \XXX
  \item[Case $(\ecase{e} (\inj i x \caseto f_i)_i)$] \XXX
  \item[Case $\eboxd e$] \XXX
  \item[Case $\elet{\eboxd x = e} f$] \XXX
  \item[Case $\bot$] \XXX

  \item[Case $e_1 \vee e_2$]
    \begin{align*}
      \vals{\incden{e_1 \vee e_2}}
      &= \vals{(\fork{\incdens{e_i}}_i \then \morph{join}_2)}
      && \text{by definition}\\
      &= \vals{\fork{\incdens{e_i}}_i} \then \vals{\morph{join}_2}
      && \text{functoriality of }\valfn\\
      &= \fork{\vals{\incdens{e_i}}}_i \then \morph{join}_2
      && \text{refinement along $\valfn$ (\cref{sec:CP-cartesian,sec:CP-families})}\\
      &= \fork{\den{e_i}}_i \then \morph{join}_2
      && \text{inductive hypothesis}\\
      &= \den{e_1 \vee e_2}
      && \text{by definition}
    \end{align*}

  \item[Case $\esetd{e_i}_i$] \XXX
  \item[Case $(\eford x e f)$] \XXX
  \item[Case $\eisEmpty e$] \XXX
  \item[Case $\esplit e$] \XXX
  \item[Case $\eeqd e f$] \XXX
  \item[Case $\efix e$] \XXX%
  \end{description}%
\end{proof}



\thmDeltaDen*
\begin{proof}
  \label{proof:delta-den}
  By induction on types. Again, $\stareq$ marks equalities given by an inductive
  hypothesis; additionally, $\daggereq$ indicates an appeal to
  \cref{thm:forget}.
  \begin{description}
    \item[Case $\isof A$:] \(\chgs{\incdens{\isof A}}
      = \chgs{\discof{\incdens A}}
      = \termO = \den{1} = \den{\D \isof A}\)

    %% \item[Case $\tset{\eqt A}$:] \(\chgs{\incdens{\tseteq A}}
    %%   = \chgs{\downof{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\vals{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\isof{\vals{\incdens{\eqt A}}}}
    %%   \daggereq \downof{\isof{\den{\eqt A}}}
    %%   = \den{\tseteq A}
    %%   \)

    \item[Case $\tset{\eqt A}$:] \(\chgs{\incdens{\tseteq A}}
      = \chgs{\pfinof{\incdens{\eqt A}}}
      = \pfinof{\vals{\incdens{\eqt A}}}
      \daggereq \pfinof{\den{\eqt A}}
      = \den{\tseteq A}
      \)

      \todo{TODO: double-check against definitions in \cref{sec:CP-pfin}}

    \item[Case $\tunit$:] \(\chgs{\incdens \tunit}
      = \chgs \termO = \termO = \den{\tunit} \)

    \item[Case $A \x B$:] \(\chgs{\incden{A \x B}}
      = \chgs{(\incdens A \x \incdens B)}
      = \chgs{\incdens A} \x \chgs{\incdens B}
      \stareq \den{\D A} \x \den{\D B}
      = \den{\D A \x \D B}
      = \den{\D(A \x B)} \)

    \item[Case $A + B$:] \(\chgs{\incden{A + B}}
      = \chgs{(\incdens A + \incdens B)}
      = \chgs{\incdens A} + \chgs{\incdens B}
      \stareq \den{\D A} + \den{\D B}
      = \den{\D A + \D B}
      = \den{\D(A + B)} \)

    \item[Case $A \to B$:]
      \begin{align*}
        \chgs{\incden{A \to B}}
        &= \chgs{(\expO{\incdens A}{\incdens B})}\\
        &= \expO {\isof{\vals{\incdens A}}} {
          \expO {\chgs{\incdens A}} {\chgs{\incdens B}}}
        & \text{by definition in \cref{sec:CP-exponentials}}
        \\
        &\stardaggereq \expO {\isof {\den A}} {\expO {\den{\D A}} {\den{\D B}}}\\
        &= \den{\isof A \to \D A \to \D B}\\
        &= \den{\D(A \to B)}
      \end{align*}
  \end{description}
\end{proof}


\thmTypeCorrect*
\begin{proof}\label{proof:typeCorrect}
  \XXX
\end{proof}


\end{document}
