\documentclass[]{rntz}
%\usepackage[b5]{rntzgeometry}
\usepackage[laptop]{fantasy}
\usepackage[scaled=1.02]{rntzfont}
\usepackage{anyfontsize}
\usepackage[spacing=true,stretch=10]{microtype}
\frenchspacing

\usepackage{amssymb,amsmath,amsthm} % \square etc.
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
%\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage[b]{esvect}              % \vv for wide vector arrows
\usepackage{nccmath}                % fix align* (etc.) spacing
\usepackage{latexsym}


%% ===== Commands =====
\newcommand\todo[1]{{\color{Rhodamine}#1}}

\newcommand\naive{na\"ive}
\newcommand\Naive{Na\"ive}
\newcommand\cat\textbf
\newcommand\strong\textbf
\newcommand\CP{\cat{ChangePoset}}
\newcommand\Poset{\cat{Poset}}
\newcommand\initO{\ensuremath{\mathbold{0}}}
\newcommand\termO{\ensuremath{\mathbold{1}}}
\newcommand\initE{\mathop{\text{\textexclamdown}}}
\newcommand\termI{\mathop{!}}

\newcommand\G\Gamma
\newcommand\D\Delta
\newcommand\x\times
\newcommand\dee\delta
\newcommand\tuple[1]{\left({#1}\right)}
\newcommand\triv{\star}
\newcommand\injc{\mathrm{in}}
\newcommand\inj[1]{\injc_{#1}\,}
\newcommand\zero{\ensuremath{\mathbold{0}}}

\newcommand\iso{\texorpdfstring{\ensuremath{\square}}{iso}}
\newcommand\isof[1]{\iso {#1}}
\newcommand\fname[1]{\textit{#1}}
\newcommand\id{\fname{id}}
\newcommand\dummy{\fname{dummy}}

%% TODO: look at other latex arrows
\newcommand\vals[1]{#1^v} % other options: _v, _o, _\iota
\newcommand\valfn{\ensuremath{\vals{-}}}
\newcommand\chgs[1]{\D{#1}}

\newcommand\fork[1]{\langle{#1}\rangle}
\newcommand\krof[1]{[{#1}]}
\newcommand\Fork[1]{\left\langle{#1}\right\rangle}
\newcommand\Krof[1]{\left[{#1}\right]}
%% \renewcommand\fork\Fork
%% \renewcommand\krof\Krof

\newcommand\funct[1]{\vals{#1}}
\newcommand\deriv[1]{#1'}

\newcommand\bindsp{~\,}
\newcommand\fa[1]{\forall #1.\bindsp}
\newcommand\ex[1]{\exists #1.\bindsp}
%% \renewcommand\ex[1]{(\exists #1)\bindsp}
%% \renewcommand\fa[1]{(\forall #1)\bindsp}


%% Option A
% \leadsto, \rightsquigarrow, \Rightarrow
\newcommand\validarrow\to
\newcommand\vld[3]{{#2 \mathrel{\overset{#1}{\validarrow}} #3}}
\newcommand\longvld[3]{{#2 \xrightarrow{#1} #3}}


%% %% Option B
%% \renewcommand\validarrow\leadsto
%% \newcommand\longvalidarrow\validarrow
%% \renewcommand\longvld[3]{{#2 \mathrel{\overset{#1}{\longvalidarrow}} #3}}


%% %% Option C
%% \renewcommand\vld[3]{{#2 \xrsquigarrow{#1} #3}}
%% \renewcommand\longvld[3]{{#2 \xrsquigarrow{#1} #3}}

%% %% Adapted from https://tex.stackexchange.com/questions/233676/leadsto-with-text
%% \usepackage{tikz}
%% \usetikzlibrary{decorations.pathmorphing,shapes}

%% \usepackage{tikz-cd}
%% \usetikzlibrary{decorations.pathmorphing}
%% \newcommand\xrsquigarrow[1]{%
%%     \mathrel{%
%%         \begin{tikzpicture}[%
%%             baseline={(current bounding box.south)}
%%             ]
%%         \node[%
%%             ,inner sep=.44ex
%%             ,align=center
%%             ] (tmp) {$\scriptstyle #1$};
%%         \path[%
%%             ,draw,<-
%%             ,decorate,decoration={%
%%                 ,zigzag
%%                 ,amplitude=0.7pt
%%                 ,segment length=1.2mm,pre length=3.5pt
%%                 }
%%             ] 
%%         (tmp.south east) -- (tmp.south west);
%%         \end{tikzpicture}
%%         }
%%     }


\title{Change Semantics for Semi\naive{} Datafun}
\author{Michael Arntzenius}
\date{5 November 2018}

\begin{document}

\maketitle

\begin{abstract}
  We define the category \CP{} of posets equipped with \emph{increasing
    changes}, whose morphisms are monotone maps equipped with \emph{derivatives}
  taking input changes to output changes. We give a semantics for Datafun in
  \CP.
\end{abstract}


\section{Notation and conventions}

\begin{enumerate}
\item I write $f~x$ for a function $f$ applied to an argument $x$.
\item $\initE_A : \initO \to A$ is the unique map out of an initial object;\\
  $\termI_A : A \to \initO$ is the unique map into a terminal object.
\item \todo{TODO: Explain $\iso : \Poset \to \Poset$.}
\end{enumerate}


\section{The category \CP}

\newcommand\pto\rightharpoonup
\newcommand\upd\oplus

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \upd_A)$, where
\begin{enumerate}
\item $\vals A \in \Poset$ is the poset of values.
\item $\chgs A \in \Poset$ is the poset of changes.
\item $(\upd) : \vals A \x \chgs A \pto \vals A$ is a partial map
  taking a value and a change to an updated value. If $x \upd dx$ is defined, we
  say $dx$ is a \emph{valid} change to $x$.

  $\vld{dx} x y$ means $x \upd dx$ is defined and equal to $y$. Otherwise,
  propositions involving $\upd$ should be understood to hold only when it is
  defined.
\end{enumerate}

\noindent
These must satisfy the following conditions:\footnote{There are other conditions
  one might sensibly impose here, most notably, that $x \upd dx$ is monotone in
  $dx$. I have not needed this, but the lack of an obvious ``correct'' set of
  conditions bothers me.}

\begin{align*}
  x \le y &~\implies \ex{dx} \vld{dx} x y
  & \text{complete for increases}\\
  x \le y &\impliedby~ \ex{dx} \vld{dx} x y
  & \text{sound for increases}
\end{align*}

\noindent
A morphism $f \in \CP(A, B)$ is a value map $\funct f \in \Poset(\vals A, \vals
B)$ eq\-uip\-ped with a derivative $\deriv f \in \Poset(\isof{\vals A} \x \chgs
A, \chgs B)$ such that:

\[ \vld{dx} x y \implies \longvld{\deriv f(x,dx)}{\funct f\,x}{\funct f\,y}\]

\noindent Or, equivalently:
\[ \funct f(x \upd dx) = \funct f\,x \upd \deriv f(x, dx) \]

\noindent
Two morphisms are equal iff they have equal value maps and their derivatives'
behavior coincides on \emph{valid} changes. In other words, we quotient equality
of derivatives as follows:

\[ (\fa{\vld{dx} x y} \deriv f(x,dx) = \deriv g(x,dx))
\implies \deriv f = \deriv g \]

\noindent
Composition of derivatives follows the chain rule:

\begin{align*}
  %% \funct\id\, x &= x &
  %% \funct{(f \circ g)}\, x &= \funct f (\funct g\,x)\\
  \funct\id &= \id & \funct{(f \circ g)} &= \funct f \circ \funct g\\
  \deriv\id(x,dx) &= dx
  & \deriv{(f \circ g)} (x,dx) &= \deriv f (g ~x,\, \deriv g(x,dx))
\end{align*}

\noindent The only interesting case of associativity is the one involving the
chain rule:
\begin{align*}
  \deriv{(f \circ (g \circ h))} (x,dx)
  &= \deriv f((g \circ h) ~x,\ \deriv{(g \circ h)}(x,dx))\\
  &= \deriv f (g(h ~x),\ \deriv g(h ~x,\ \deriv h(x,dx)))\\
  &= \deriv{(f \circ g)} (h ~x,\ \deriv h(x,dx))\\
  &= \deriv{((f \circ g) \circ h)} (x,dx)
\end{align*}


\subsection{Zero changes and change composition}

Applying the axiom of choice to soundness \& completeness for increases, we can
recover zero-change and composition operators $\zero$, $(\cdot)$ such that $x
\upd \zero_x = x$ and $x \upd (dx \cdot dy) = (x \upd dx) \upd dy$. These do not
necessarily satisfy the identity and associativity laws of a category, but will
be useful nonetheless. \todo{TODO: talk about non-constructivity and why it
  won't be a problem. maybe should go in ``strategy'' section at the top?}


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals{A}$
and morphisms $f$ to $\funct f$. The structures we will build in \CP{}
\emph{refine} the corresponding structures in \Poset{}, in the sense of
commuting with $\valfn$. For example, for cartesian products, $\vals{(A \x B)} =
\vals{A} \x \vals{B}$ and $\funct{\fork{f,g}} = \fork{\funct f, \funct g}$. For
brevity, we omit the ``value components'' of our constructions when they can be
derived from this fact.


\section{Cartesian structure}

\begin{theorem}
  \CP{} has all finite products and sums.
\end{theorem}

\begin{proof}
  I omit the value-level structure, as it is inherited from \Poset{} along
  \valfn{}. The change-poset structure is also inherited from \Poset{}, while
  the projection and injection's derivatives operate pointwise on changes:

  \begin{align*}
    \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
    \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
    \\
    \deriv\pi_i(x,dx) &= \pi_i~dx & \deriv\injc_i(x,dx) &= \inj i dx
  \end{align*}

  \noindent Updates are pointwise, noting that $(\inj i x \upd \inj j dx)$ is
  undefined for $i \ne j$:

  \begin{align*}
    (x_i)_i \upd (dx_i)_i &= (x_i \upd dx_i)_i &
    \inj i x \upd \inj i dx &= \inj i (x \upd dx)
  \end{align*}

  \noindent
  Soundness \& completeness for increases follow directly from the pointwise
  orderings of products \& coproducts in \Poset{}.

  We calculate $\deriv{\fork{\vv f}}$ from its universal property. Imagine $g$
  such that $\deriv f_i = (\pi_i \circ g)'$ for $i \in I$. Then:

  \begin{align*}
    \deriv f_i(x,dx) &= \deriv{(\pi_i \circ g)} (x,dx)\\
    &= \deriv\pi_i(\funct g\,x,\, \deriv g(x,dx))\\
    &= \pi_i (\deriv g(x,dx))
  \end{align*}

  \noindent
  So by the universal property of products in \Poset{}, we have $\deriv g =
  \fork{\vv{\deriv f}}$. Thus $\deriv{\fork{\vv f}} = \fork{\vv{\deriv f}}$.

  Now let's try calculating $\deriv{\krof{\vv f}}$ from its universal property.
  Imagine $g$ such that $\deriv f_i = \deriv{(g \circ \injc_i)}$. Then:

  \begin{align*}
    \deriv f_i(x,dx) &= \deriv{(g \circ \injc_i)}(x,dx)\\
    &= \deriv g(\funct\injc_i(x),\, \deriv\injc_i(x,dx))\\
    &= \deriv g(\inj i x,\, \inj i dx)
  \end{align*}

  This defines $\deriv{\krof{\vv f}}(\inj i x,\, \inj j dx)$ when $i = j$. What
  about $i \ne j$? Here we appeal to our quotient: derivatives are equal iff
  they agree on \emph{valid} changes. By construction, all valid changes to
  $\inj i x$ are of the form $\inj i dx$. So the $i \ne j$ case \strong{does not
    matter}, so long as it is defined. One satisfactory definition is:

  \begin{equation*}
    \deriv{\Krof{\vv f}}(\inj i x,\, \inj j dx) = 
    \begin{cases}
      \deriv f_i(x,dx) & \text{if}~ i=j\\
      \zero_x & \text{otherwise}
    \end{cases}
  \end{equation*}

  I omit the proofs that the derivatives above are monotone in their second
  argument.
\end{proof}

\noindent
The use of $\zero_x$ in $\deriv{\krof{\vv f}}$ is effectively dead code:
necessary to define $\deriv{\krof{\vv f}}$, but irrelevant to its behavior. We
will exploit this later to avoid needing the axiom of choice (used to define
$\zero_x$) in the context of Datafun.


\section{Exponential objects}

\newcommand\expO[2]{#1 \Rightarrow #2}
\newcommand\df{d\kern-.1em f\kern-.1em} % fucking kerning.

The change poset of the exponential object $\expO A B \in \CP$ consists of
monotone maps $\df, dg \in \expO{\isof{\vals A}}{\expO{\chgs A}{\chgs B}}$,
partially ordered pointwise by their effect on valid changes and quotiented to
satisfy antisymmetry:

\begin{equation*}
  \df \le dg : \chgs{(\expO A B)}
  \iff \fa{\vld{dx} x y} \df ~x ~dx \le dg ~x ~dx 
\end{equation*}

\noindent
The update relation is:

\begin{equation}\label{eqn:function-update}
  \vld{\df} f g : \expO A B
  \iff \fa{\vld{dx} x y} \longvld{\df~x~dx}{f~x}{g~y}
\end{equation}

\noindent Informally, this says a function change $\df$ is valid so long as it
takes valid input changes to valid output changes: if $dx$ is a change to $x$,
then $\df~x~dx$ must be a change to $f~x$.

To show this defines a unique partial function $\upd$, suppose $\vld\df f g$ and
$\vld\df f h$ and consider any $x : A$. \Cref{eqn:function-update} applied to
$\vld{\zero_x} x x$ gives us $\longvld{\df~x~\zero_x}{f~x}{g~x}$ and
$\longvld{\df~x~\zero_x}{f~x}{h~x}$. By functionality of $\validarrow$ at $B$ we
have $g~x = h~x = f~x \upd \df~x~\zero_x$.

Thus, whenever $f \upd \df$ is defined, we have
%
\[ (f \upd \df)~x = f~x \upd \df~x~\zero_x \]
%
and more generally, setting aside definedness, \cref{eqn:function-update} can be
rewritten:
%
\[ f~x \upd \df~x~dx = (f \upd \df)~(x \upd dx) \]

\noindent
Soundness \& completeness for increases at $\expO A B$ follows from soundness \&
completeness at $A$ and $B$ and the axiom of choice. \todo{TODO: elaborate}

% WTS: f ≤ g ⇔ ∃df. f -df-> g

% Suppose f ≤ g.
% WTS: ∃df. f --df--> g.
% Let's calculate! df has to be such that
% ∀(x -dx-> y) f x --df x dx--> g y
% Suppose (x -dx-> y)
% 
% Suppose f -df-> g.
% Consider x : A. WTS: f x <= g y. Know x --0x--> x.
% Thus f x --df x 0x--> g x. So by soundness f x <= g x.

%% \begin{align*}
%%   f \le g : \vals{(\expO A B)}
%%   &\iff f \le g : \expO{\vals A}{\vals B}\\
%%   &\iff \fa{x \le y} f~x \le g~y\\
%%   &\iff \fa{x,y} (\ex{dx} \vld{dx} x y)
%%   \implies \ex{dx} \vld{dx}{f~x}{g~y}\\
%%   &\iff \todo{???}\\
%%   &\iff \ex{\df} \vld{\df} f g
%% \end{align*}

\newcommand\fn\lambda
\todo{TODO: define \fname{eval}, compute $\fn$ from its universal property}


\section{The lifted \iso{} comonad}

\section{Semilattice objects}

\section{Fixed points}


\section{``Reading off'' the change semantics of Datafun}

\end{document}
