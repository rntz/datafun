%\documentclass[12pt]{rntz}\usepackage[a4]{rntzgeometry}\usepackage[fullwidth=18cm,width=38em,width=420pt,]{narrow}
%\documentclass{rntz}\usepackage[b5]{rntzgeometry}\usepackage[fullwidth=152mm,width=351pt,width=373pt,]{narrow}
%\documentclass{rntz}\usepackage[a5]{rntzgeometry}\usepackage[fullwidth=130mm,width=330pt,]{narrow}
%\documentclass[nomarginums]{rntz}\usepackage[b6]{rntzgeometry}\usepackage[width=\textwidth,fullwidth=115mm,]{narrow}\pagestyle{empty}

\documentclass{rntz}\usepackage{fantasy}%\geometry{textwidth=330pt,}
%\documentclass[nomarginums]{rntz}\usepackage[tablet]{fantasy}%\geometry{textwidth=345pt}
%\documentclass[nomarginums]{rntz}\usepackage[phone]{fantasy}

\usepackage{latexsym}               % \rightsquigarrow
\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage{amssymb,amsmath,amsthm} % \square etc.
\usepackage{mathtools}              %\dblcolon
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
\usepackage{accents}                %\underaccent
\usepackage{nccmath}                % fix align* (etc.) spacing
\usepackage{anyfontsize}
%\usepackage{thmtools,thm-restate}   % allow restatable theorems.

% Make section name references use \S.
\makeatletter\crefname{section}{\S\@gobble}{\S\@gobble}\makeatother

% hang is only relevant for long captions, which I don't have
\usepackage[labelsep=period,labelfont=it,textfont=it,format=hang]{caption}
%\usepackage[skip=.5\baselineskip,labelfont=sc,textfont=it,labelsep=period,format=hang]{caption}
%\usepackage[labelfont=sc,labelsep=period,format=hang]{caption}

\usepackage{enumitem}\setlist{labelindent=1em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=.5em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=0em,labelsep=.75em,leftmargin=*}

%\PassOptionsToPackage{scaled=1.0625}{rntzfont} % b5/a4
\PassOptionsToPackage{scaled=1.036}{rntzfont} % fantasy[laptop,tablet]
%\PassOptionsToPackage{scaled=.99}{rntzfont} %b6

%% Note to self: don't use newmath, Neel's PC can't handle it.
\usepackage[charter,]{rntzfont}
%\usepackage[source,linespread=1.0233,]{rntzfont}
%\usepackage[source,scaled=1.01,linespread=1.0132,linespread=1.015,]{rntzfont}
%\usepackage[librebaskerville,linespread=1.012,]{rntzfont} % zeu@Scale ≈ .98

%% %% Nice for fantasy[phone].
%% \usepackage[sfdefault,scaled=.89060]{noto}
%% \usepackage{eulervm}\makeatletter\edef\zeu@Scale{1.04}\makeatother
%% \usepackage[cal=cm,bb=esstix,scaled=.93,bbscaled=.93]{mathalfa}
%% \renewcommand\mathit\textit\renewcommand\mathrm\textmd % argh
%% \usepackage[basic,defaultmathsizes]{mathastext}
%% \linespread{1.05}%\linespread{1.08}

\ifdefined\mathbold\else\newcommand\mathbold{\boldsymbol}\fi
\usepackage[spacing=true]{microtype}
\frenchspacing

\newcommand\mathvar[1]{\ensuremath{{#1}}} % For upright math font.
%\renewcommand\mathvar[1]{\ensuremath{\mathit{#1}}} % For italic math font.

%% Ooh, check out the typeface package:
%% https://ctan.org/pkg/typeface?lang=en
%% https://mirror.hmc.edu/ctan/macros/latex/contrib/typeface/typeface.pdf
%%
%% Hm, it doesn't handle:
%% - scaling the main text font (!)
%% - all newtxmath's options
%% - newpxtext or newpxmath

\hyphenation{eq-uip-ped}
\hyphenation{inv-olv-ing}

\usepackage{notation}


\title{Change Semantics for Semi\naive{} Datafun}
\author{\scshape Michael Arntzenius}
\usepackage[en-GB]{datetime2}
\DTMlangsetup[en-GB]{ord=omit}
\date{\today}

\begin{document}%\the\textwidth

%% \noindent
%% % use a math environment to force loading math font.
%% ex/em: \the\fontdimen5\font{} / \the\fontdimen6\font \(\)\\
%% math ex: \the\fontdimen5\textfont1{} / \the\fontdimen6\textfont1\\
%% word space: \the\fontdimen2\font\\
%% baselineskip: \the\baselineskip\\
%% %% \par\begingroup\Large\noindent
%% %% x$x$\emph{x} y$y$\emph{y} v$v$\emph{v} $f$f $t$t $o$o $T$T\emph{T} lIx\\
%% %% fb ff fh fi fj fk fl ft \emph{fb ff fh fi fj fk fl ft} Th \emph{Th}\\
%% %% ffb ffh ffi ffj ffk ffl fft \emph{ffb ffh ffi ffj ffk ffl fft}
%% %% \endgroup\\

\maketitle

\begin{abstract}
  We define \emph{incrementalization} and \emph{semi\naive{} evaluation}
  transformations for Datafun programs, generalizing the classic Datalog
  optimization, and prove them correct semantically.%
\end{abstract}


\section{Strategy}

First, we generalize Datafun's \Poset{} semantics to any category with
appropriate structures (\cref{sec:datafun-models}). With this in mind, we define
a category \CP{} of posets equipped with a notion of \emph{increasing changes},
whose morphisms are monotone maps possessing \emph{derivatives} relating input
changes to output changes (\cref{sec:changeposets}). This gives us an
\emph{incremental semantics} for Datafun (\cref{sec:incremental}). We observe
that one can compute the fixed point of a function more efficiently using its
derivative, and in a higher-order language function derivatives are \emph{zero
  changes}. We give a \emph{``semi\naive{}''} static transformation on Datafun
that augments the discreteness comonad to compute zero-changes. We prove this
correct by relating it to the incremental semantics.

% TODO: more section links once I finish them.


\section{Notation and conventions}

\begin{enumerate}
\item Adjacency $f\<x$ denotes the function $f$ applied to an argument $x$.

\item I write $f \then g$ for the composition of morphisms $f : A \to B$ and $g
  : B \to C$. This is the reverse of the usual composition operator, $g \circ
  f$.

\item I write $\subst{e}{x \substo f}$ to mean ``$e$ with all free occurrences of $x$
  replaced by $f$ ($\alpha$-varying as necessary to avoid capture)''.

  \newcommand\iexpr{\phi}
\item I write $(\iexpr_i)_i$ for the tuple or sequence $(\iexpr_1,
  ..., \iexpr_n)$, leaving $n$ unspecified. For example,

  \nopagebreak[2]
  \[ (2^ix + y_i)_i \quad\text{means}\quad
  (2^1x + y_1,~ 2^2x + y_2,~ ...,~ 2^nx + y_n) \]

  \noindent
  I also use this notation with other braces, eg. $\fork{\iexpr_i}_i =
  \fork{\iexpr_0, ..., \iexpr_n}$.

\item $\expO A B$ denotes the exponential $B^A$ in a cartesian closed category.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their \emph{``fork''} $\fork{f_i}_i : A \to \textstyle\prod_{i} B_i$
  uniquely satisfies $\fork{f_i}_i \then \pi_i = f_i$. Dually, given $f_i : A_i
  \to B$ in a category with finite sums, their \emph{``split''} $\krof{f_i}_i :
  \sum_i A_i \to B$ uniquely satisfies $\injc_i \then \krof{f_i}_i = f_i$.
  %
  So in particular, $\termI : A \to \termO$ is the unique map into the terminal
  object and $\initE : \initO \to B$ the unique map out of the initial object.

\item The comonad $\iso : \Poset \to \Poset$ takes a poset to the
  \emph{discrete} poset on the same elements, defined:

  \begin{eqnarray*}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{eqnarray*}
\end{enumerate}


%% ---- Syntax & typing rules ----
\begin{figure*}
  \begin{mathpar}
    \setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
      \text{types} & A,B &\bnfeq& \isof A \bnfor \tset{\eqt A}
      \bnfor \tunit \bnfor A \x B \bnfor A + B \bnfor A \to B
      \\
      \text{eqtypes} & \eqt A, \eqt B &\bnfeq&
      \isof{\eqt A} \bnfor \tset{\eqt A} \bnfor
      \tunit \bnfor \eqt A \x \eqt B \bnfor \eqt A + \eqt B
      \\
      \text{semilattices} & L,M &\bnfeq& \tset{\eqt A} \bnfor \tunit \bnfor L \x M
      \\
      \text{fixtypes} & \fixt L, \fixt M &\bnfeq&
      \tset{\color{red}\fint A} \bnfor \tunit \bnfor \fixt L \x \fixt M
      \\[.5em]
      \text{terms} & e,f,g &\bnfeq& x \bnfor \dvar x \bnfor \fnof{x} e
      \bnfor e\<f \bnfor \etuple{} \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
      &&& \inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
      &&& \eboxd e \bnfor \elet{\eboxd x = e} f\\
      &&& \bot \bnfor e \vee f \bnfor \esetd{e_i}_i \bnfor \eford x e f\\
      &&& \eeqd e f \bnfor \eisEmpty e \bnfor \esplit e \bnfor \efix e
      \\[.5em]
      \text{contexts} & \G &\bnfeq& (H_i)_i\\
      \text{hypotheses} & H &\bnfeq& \h x A \bnfor \hd x A
    \end{array}
    \\
    \stripcxd\G = (\hd x A)_{\hd x A \in \G}
    \\
    \infer{\h x A \in \G}{\J x \G A}

    \infer{\hd x A \in \G}{\J {\dvar x} \G A}

    \infer{\J e {\G,\h x A} B}{\J {\fnof x e} \G {A \to B}}

    \infer{\J e \G {A \to B} \\ \J f \G A}{\J {e\<f} \G B}

    \infer{\quad}{\J {\etuple{}} \G \tunit}

    \infer{(\J{e_i}\G{A_i})_i}{\J{\etuple{e_1,e_2}} \G {A_1 \x A_2}}

    \infer{\J e \G {A_1 \x A_2}}{\J{\pi_i\<e}\G{A_i}}

    \infer{\J e \G A_i}{\J{\inj i e}\G{A_1 + A_2}}

    \infer{\J e \G {A_1 + A_2} \\
      (\J {f_i} {\G,\h {x_i} {A_i}} {B})_i
    }{
      \J {\ecase{e} (\inj i {x_i} \caseto f_i)_i} \G B
    }

    \infer{\J {\isocolor e} {\stripcxd\G} A}{\J{\eboxd e} \G {\isof A}}

    \infer{\J e \G {\isof A} \\ \J f {\G,\hd x A} B}{
      \J {\elet{\eboxd x = e} f} \G B}

    \infer{\quad}{\J\bot\G {\eqt L}}

    \infer{(\J{e_i} \G {\eqt L})_i}{\J{e_1 \vee e_2}\G {\eqt L}}

    %% \infer{\J e \G {\eqt A}}{\J {\edown e} \G {\tdown {\eqt A}}}
    \infer{(\J {\isocolor e_i} {\stripcxd\G} {\eqt A})_i}{
      \J {\esetd{e_i}_i} \G {\tset{\eqt A}}}

    %% \infer{\J e \G {\tdown {\eqt A}} \\
    %%   \J f {\G,\h x {\eqt A}} L
    %% }{\J {\ebigvee x e f} \G L}
    %%
    \infer{
      \J e \G {\tset A} \\
      \J f {\G,\hd x A} {\eqt L}
    }{\J {\eford x e f} \G {\eqt L}}

    %%\infer{\J e \G {\isof{(\eqt A \x \eqt A)}}}{\J{\prim{eq}\<e} \G {\tdown\tunit}}
    \infer{(\J {\isocolor e_i} {\stripcxd\G} {\eqt A})_i}
          {\J {\eeqd{e_1}{e_2}} \G \tbool}

    \infer{\J {\isocolor e} {\stripcxd\G} {\tset\tunit}}{
      \J {\eisEmpty e} \G {\tunit + \tunit}}

    \infer{\J e \G {\isof{(A + B)}}}{\J{\esplit e} \G {\isof A + \isof B}}

    \infer{\J e \G {\isof{(\fixt L \to \fixt L)}}}{\J{\prim{fix}\< e} \G {\fixt L}}
  \end{mathpar}

  \caption{Datafun core syntax and typing rules}
  \label{fig:core-datafun}
\end{figure*}

\begin{figure*}
  \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
    \text{types} & A,B &\bnfeq& ... \bnfor \tbool\\
    \text{terms} & e,f,g &\bnfeq&
    ... \bnfor \elet{x = e} f \bnfor \efixisd x e\\
    &&& \efalse \bnfor \etrue \bnfor \eif e f g \bnfor \ewhen e f
    % NB. no more \edcase because we just use pattern-matching elaboration
    %\\ &&& %\edcase{e} (\inj i {\dvar{x_i}} \caseto f_i)_{i\in\{1,2\}}
  \end{array}\]

  \begin{mathpar}
    \infer{\quad}{\J\bot\G L}

    \infer{(\J{e_i} \G L)_i}{\J{e_1 \vee e_2}\G L}

    \infer{\J e \G {\tseteq A} \\ \J f {\G,\hd x A} L}{
      \J {\eford x e f} \G L}

    \infer{\J e \G A \\ \J f {\G,\h x A} B}{\J{\elet{x = e} f} \G B}

    \infer{\J {\isocolor e} {\stripcxd{\G}, \h x {\fixt L}} {\fixt L}}
          {\J {\efixisd x e} \G {\fixt L}}

    \infer{\quad}{\J \etrue \G \tbool}

    \infer{\quad}{\J \efalse \G \tbool}

    \infer{\J {\isocolor e} {\stripcxd\G} \tbool \\ (\J{f_i}\G B)_i}
          {\J {\eifd e{f_1}{f_2}} \G {B}}

    \infer{\J e \G \tbool \\ \J f \G L}{\J {\ewhen e f} \G L}
  \end{mathpar}

  \caption{Surface syntax and typing rules}
  \label{fig:surface-syntax}
\end{figure*}

\begin{figure*}

  \begin{align*}
    \tbool &\desugars \tset{\tunit}
    \\
    %% \eeqd e f &\desugars \prim{eq}\< \eboxd{\etuple{e, f}}\\
    %% \esetd{e_i}_i &\desugars \edown\eboxd{e_0} \vee ... \vee \edown\eboxd{e_n} \quad \text{(or $\bot$ if $n=0$)}\\
    %% \eford x e f &\desugars \ebigvee {\freshvar y} e {\elet{\eboxd x = \freshvar y} f}\\
    \eifd e {f_1}{f_2} &\desugars
    \ecase{\eisEmpty e} (\inj i {\freshvar\pwild} \caseto f_i)_i
    %% %% NB. This is mostly redundant with the pattern-matching elaboration in fig:
    %% \edcase e (\inj i {\dvar{x_i}} \caseto f_i)_i
    %% &\desugars \ecase{\esplit \eboxd e}
    %% (\inj i {\freshvar y} \caseto \elet{\eboxd{x_i} = \freshvar y} f_i)_i
    %% \\
  \end{align*}

  \begin{align*}
    \efalse &\desugars \esetd{} &
    \etrue &\desugars \esetd{\etuple{}}
    \\
    \elet{x = e} f &\desugars (\fnof{x} f)\<e &
    \efixisd x e &\desugars \efix \eboxd{\fnof {\color{black} x} e}
  \end{align*}

  %\vspace{-.5ex}
  {\small Fresh variables ($\freshvar y$, $\freshvar\pwild$) are marked in \freshvar{pink}.}
  %\vspace{.5ex}

  \caption{Desugaring of surface syntax}
  \label{fig:desugaring}
\end{figure*}

\begin{figure*}
  \begin{tabular}{rll}
    Surface term & expanded at $A \to L$ & expanded at $L \x M$\\\midrule
    $\bot$
    & \(\fnof{\freshvar\pwild} \bot\)
    & \(\etuple{\bot,\bot}\)
    \\
    \(e \vee f\)
    & \(\fnof{\freshvar x} e\<{\freshvar x} \vee f\<{\freshvar x}\)
    & \(\etuple{\pi_1\<e \vee \pi_1\<f,\, \pi_2\<e\vee\pi_2\<f}\)
    \\
    \(\eford x e f\)
    & \(\fnof{\freshvar y} \eford x e {f\<\freshvar y}\)
    & \(\Etuple{\bigl(\eford x e {\pi_1\<f}\bigr), \bigl(\eford x e {\pi_2\<f}\bigr)}\)
  \end{tabular}

  \caption{Desugaring higher-order semilattice operations}
  \label{fig:desugaring-higher-order-semilattice}
\end{figure*}

%% TODO: check that we have every rule we need.
%% TODO: are any of these redundant/unnecessary?
\begin{figure*}
  \[\setlength\arraycolsep{.15em}\begin{array}{rcl}
    \ecase{e} x \caseto f &\desugars& \elet{x = e} f\\[.33em]
    \ecase{e} \eboxd x \caseto f &\desugars& \elet{\eboxd x = e} f
    \\[.33em]
    %% A * B
    \ecase{e} (\etuple{p_i,q_i} \caseto f_i)_i
    &\desugars& \elet{\freshvar x = e}\\
    && \ecase{\pi_1\< {\freshvar x},\, \pi_2\< {\freshvar x}} (p_i,q_i \caseto f_i)_i
    \\[.33em]
    %% A + B
    \ecase{e} (\inj i p_{i,j} \caseto f_{i,j})_{i,j}
    &\desugars& \ecase{e} (\inj i {\freshvar x}
    \caseto \ecase{\freshvar x} (p_{i,j} \caseto f_{i,j})_j)_i
    \\[.33em]
    %% [](A * B)
    \ecase{e} (\eboxd{\etuple{p_i,q_i}} \caseto f_i)_i
    &\desugars& \elet{\eboxd {\freshvar x} = e}\\
    && \ecase{\eboxd{\pi_1\<\freshvar x}, \eboxd{\pi_2\<\freshvar x}}
    (\eboxd{p_i}, \eboxd{q_i} \caseto f_i)
    \\[.33em]
    %% [](A + B)
    \ecase{e} (\eboxd{\inj i p_i} \caseto f_i)_i
    &\desugars& \ecase{\esplit e} (\inj i \eboxd{p_i} \caseto f_i)_i
    \\[.33em]
    %% multi-case -> nested case
    \ecase{e,\vec f} (p_i, \vec q_{i,j} \caseto g_{i,j})_{i,j}
    &\desugars& \ecase{e} (p_i \caseto \ecase{\vec f} (\vec q_{i,j} \caseto g_{i,j})_j)_i
  \end{array}\]
  \caption{Some pattern-matching elaboration rules}
  \label{fig:desugaring-pattern-matching}
\end{figure*}


\section{Surface syntax and its desugaring}

We present Datafun in two layers: a simpler \emph{core}
(\cref{fig:core-datafun}) and a more liberal \emph{surface}
(\cref{fig:surface-syntax}) whose extensions are desugared into core terms
(\crefrange{fig:desugaring}{fig:desugaring-pattern-matching}).
%
The simpler core terms are easier to \emph{analyse}, so our semantics and static
transformations consume core terms; conversely, surface terms are easier to
\emph{construct}, so we use them in example programs and in the outputs of our
static transformations.

The specific surface features we add are:
\begin{enumerate}
\item Let-bindings.

\item Booleans, ordered $\efalse < \etrue$. Since sum types are ordered
  disjointly, booleans are instead desugared into sets of empty tuples, with
  $\efalse = \emptyset$ and $\etrue = \eset{\etuple{}}$. \todo{TODO: explain
    $(\eisEmpty e)$}.

\item Pattern matching on tuples and boxes. \todo{TODO: explain $\prim{split}$.}

\item In the core language, semilattice operations ($\bot$, $e \vee f$, and
  \kwname{for}-loops) are permitted only at \emph{first-order} semilattice types
  $\eqt L$. This limitation is lifted in the surface language using
  $\eta$-expansion (\cref{fig:desugaring-higher-order-semilattice}).

\item In the core language, we express fixed point computations using what
  amounts to a higher-order operator $\prim{fix} : \isof{(\fixt L \to \fixt L)}
  \to \fixt L$. In the surface language there is a more convenient binding form,
  $\efixisd x e$.

\end{enumerate}


\section{Datafun models}
\label{sec:datafun-models}

The \emph{``standard''} model of Datafun interprets types as posets and terms as
monotone maps. Generalizing this, we can interpret Datafun terms into any
bicartesian closed category \catC{} equipped with the following structures:

\begin{enumerate}
\item A \emph{``discreteness''} comonad $\tuple{\disco{}, \varepsilon, \delta}$
  equipped with distributive morphisms:

  \nopagebreak[2]
  \begin{align*}
    \discox &: \prod_i \discof{A_i} \to \disco \prod_i A_i
    &
    \discosum &: \disco \sum_i A_i \to \sum_i \discof{A_i}
  \end{align*}

\item A \emph{``finite powerset''} functor \(\pfin : \catC \to \catC\) equipped
  with morphism families:

  \nopagebreak[2]
  \begin{align*}
    \morph{singleton} &: \isof A \to \pfinof{A} &
    \morph{isEmpty} &: \discof{\pfinof{\termO}} \to \termO + \termO
  \end{align*}

  %% \noindent
  %% and, moreover, for any objects $\G,A$, semilattice object $L$, and morphism
  %% $f : \G \x \isof A \to L$, a ``collecting'' morphism \( \pcollect{f} : \G \x
  %% \pfinof A \to L \).

\item \emph{Equality}, \emph{semilattice}, and \emph{fixed point objects}, which
  must interpret equality, semilattice, and fixed point types respectively.
  Letting $\eqt A$ be an equality object, $L$ be a semilattice object, and
  $\fixt L$ be a fixed point object, these must have morphisms:

  \nopagebreak[2]
  \begin{align*}
    \morph{eq} &: \isof{\eqt A} \x \isof{\eqt A} \to \pfinof\termO
    &
    \morph{join}_n &: L^n \to L
    &
    \morph{fix} &: \isof{(\expO{\fixt L}{\fixt L})} \to \fixt L
  \end{align*}

\item To interpret \kwname{for}-loops, for any objects $\G, A$ and any
  semilattice object $L$ we require a family of morphisms $\pcollect{f}$:

  \nopagebreak[2]
  \[
    \infer{f : \G \x \isof A \to \den{\eqt L}}
          {\pcollect{f} : \G \x \pfinof{A} \to \den{\eqt L}}
  \]

%% , Given objects $\G, A$, a semilattice equality type $\eqt L$, and
%%   a morphism $f : \G \x \isof{A} \to \den{\eqt L}$, we require a morphism
%%   $\pcollect{f} : \G \x \pfinof{A} \to \den{\eqt L}$. Or, abusing inference rule
%%   notation:
%%   %
%%   \[
%%     \infer{f : \G \x \isof A \to \den{\eqt L}}
%%           {\pcollect{f} : \G \x \pfinof{A} \to \den{\eqt L}}
%%   \]

\end{enumerate}

\noindent
\Cref{fig:semantics} shows how to interpret Datafun into any Datafun
model. The standard semantics is an instance of this, letting \catC{} be
\Poset{}, \iso{} be \iso{}, and \pfin{} be the finite powerset functor.
\todo{TODO: explain in more detail?}

Since we have not imposed any laws, there is no useful general equational theory
of Datafun models. Instead, our approach is to relate the models we construct to
the standard model and use \emph{its} equational theory.


%% ---- Semantics in a Datafun Model ----
\begin{figure*}
  \figsectionname{Types and Contexts}

  \begin{align*}
    \den{\tunit} &= \termO & \den{A \to B} &= \expO{\den{A}}{\den{B}}
    \\
    \den{\tseteq A} &= \pfinof{\den{\eqt A}}
    & \den{A \x B} &= \den{A} \x \den{B}
    \\
    \den{\isof A} &= \discof{\den{A}} & \den{A + B} &= \den{A} + \den{B}
  \end{align*}

  \begin{align*}
    \den{\G} &= \prod_{H \in \G} \den{H} &
    \den{\h x A} &= \den{A} & \den{\hd x A} &= \discof{\den{A}} &
    \den{\G \vdash A} &= \catC(\den\G, \den A)
  \end{align*}

  \vspace{.5\baselineskip}
  \figsectionname{Terms}

  \begin{align*}
    \den{\dvar x} &= \pi_{\dvar x} \then \varepsilon \quad \text{($\dvar x$ discrete)}
    & \den{x} &= \pi_x \quad \text{($x$ monotone)}
    \\
    \den{\fnof x e} &= \lambda\den{e}
    & \den{e\<f} &= \fork{\den{e}, \den{f}} \then \morph{eval}
    \\
    \den{\etuple{e_i}_i} &= \fork{\den{e_i}}_i
    & \den{\pi_i\<e} &= \den{e} \then \pi_i
    \\
    \bigden{\eboxd e} &= \strip \then \discof{\den e}
    & \bigden{\elet{\eboxd x = e} f} &=
    \fork{\id, \den{e}} \then \den{f}
    \\
    \den{\bot} &= \termI \then \morph{join}_0
    &
    \den{e \vee f} &= \fork{\den{e}, \den{f}} \then \morph{join}_2
    \\
    %\den{\color{red}\prim{isEmpty}\<e} &= \den{e} \then \morph{isEmpty}
    \den{\eisEmpty e} &= \den{\eboxd e} \then \morph{isEmpty}
    & \den{\esplit e} &= \den{e}\then \discosum
    \\
    %\den{\color{red}\prim{eq}\<e} &= \den{e} \then \morph{eq}
    \den{\eeqd{e_1}{e_2}} &= \fork{\den{\eboxd{e_i}}}_i \then \morph{eq}
    & \den{\efix e} &= \den{e} \then \morph{fix}
    \\
    %\den{\edown e} &= \den{e} \then \morph{gen} % <- THIS IS WRONG
    \den{\esetd{e_i}_i} &= \fork{\den{\eboxd{e_i}} \then \morph{singleton}}_i \then \morph{join}
    &
    \den{\eford x e f} &=
    \fork{\id,\den{e}} \then \pcollect{\den{f}}
    %\den{\ebigvee x e f} &=
    %\fork{\id,\den{e}} \then \morph{strong} \then \downof{\den{f}} \then \morph{collect}
  \end{align*}

  \begin{align*}
    \den{\inj i e} &= \den{e} \then \injc_i
    \\
    \den{\ecase{e} (\inj i{x_i} \caseto f_i)_i} &=
    \fork{\id, \den{e}} \then \morph{dist}^\x_+ \then \bigkrof{\den{f_i}}_i
    %\bigkrof{\den{f_i}}_i \circ \morph{dist}^\x_+ \circ \fork{\id, \den{e}}
  \end{align*}

  \vspace{.5\baselineskip}
  \figsectionname{Lemmas}

  \begin{align*}
    \morph{dist}^\x_+ &: A \x (B_1 + B_2) \to (A \x B_1) + (A \x B_2)\\
    % this could be simpler if it distributed in the opposite direction.
    \morph{dist}^\x_+ &= \fork{\pi_2 \then \krof{\lambda (\fork{\pi_2,\pi_1} \then \injc_i)}_i, \pi_1}
    \then \morph{eval}
    \\[1ex]
    \strip &: \den\G \to \discof{\den{\stripcxd\G}}\\
    \strip &= \fork{\pi_{\dvar x} \then \delta}_{\hd x A \in \G} \then \discox
  \end{align*}

  \todo{TODO: add a function $\morph{box}(f) = \strip \then \isof f$, so
    $\den{\eboxd e} = \morph{box}(\den{e})$?}

  %% \raggedright\footnotesize Strictly speaking, the cases for
  %% $\den{\esetd{e_i}_i}$, $\den{\eisEmpty e}$, and $\den{\eeqd e f}$ are not
  %% structurally inductive; nonetheless $\den{e}$ is well-defined.

  \caption{Datafun semantics in a Datafun model $\tuple{\catC, \disco, \pfin}$}
  \label{fig:semantics}\label{def:strip}
\end{figure*}


\section{The category \CP}
\label{sec:changeposets}

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \updfn_A)$, where
%
$\vals A$ is a poset of values;
%
$\chgs A$ is a poset of changes;
%
and $\updfn : \vals A \x \chgs A \pto \vals A$ is a \strong{partial} map taking
a value and a change to an updated value.
%
We may also write $\vld{\dx} x y$ to mean that $x \upd \dx = y$ is defined. In
this case we say $\dx$ is a \emph{valid} change to $x$.
%
These must satisfy the following conditions:\footnote{There are other conditions
  one might sensibly impose here, most notably, that $x \upd \dx$ is monotone in
  $\dx$. I have not needed this, but the lack of an obvious ``correct'' set of
  conditions bothers me.}

\nopagebreak[2]
\begin{align*}
  x \le y &\implies \ex{\dx} \vld{\dx} x y
  & \text{complete for increases}\\
  x \le y &\impliedby \ex{\dx} \vld{\dx} x y
  & \text{sound for increases}
\end{align*}

\noindent In particular, for every $x$ there is a (not necessarily unique)
\emph{zero change}, $\zero_x$, such that $x \upd \zero_x = x$.\footnote{Use of
  the $\zero_x$ operator amounts to invoking the axiom of choice.}

Morphisms $f \in \CP(A,B)$ are differentiable maps $f \in \Poset(\vals A, \vals
B)$. A map is differentiable iff it has a derivative $\deriv f : \vals A \to
\Poset(\chgs A, \chgs B)$ such that:

\nopagebreak[2]
\[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}\]

\noindent Or, equivalently:

\nopagebreak[2]
\[ f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

%% % Doesn't work on narrow paper, eg. a5.
%% \nopagebreak
%% \[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}
%% \quad\text{or equivalently}\quad
%% f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

\noindent
The same morphism may have many different derivatives; all that matters is that
one exist.

Composition of derivatives follows the chain rule:

\nopagebreak[2]
\begin{align*}
  \deriv\id \<x\<\dx &= \dx
  & \deriv{(f \circ g)} \<x\<\dx &= \deriv f \<(g\<x) \<(\deriv g\<x\<\dx)
\end{align*}


%\subsection{Zero changes and change composition}

%% Applying the axiom of choice to soundness \& completeness for increases, we
%% recover operators $\zero$, $(\cdot)$ such that $x \upd \zero_x = x$ and $x \upd
%% (\dx \cdot \dy) = (x \upd \dx) \upd \dy$. These do not necessarily satisfy the
%% identity and associativity laws of a category, but $\zero$ will be useful
%% nonetheless. We will see how to duck this non-constructive use of the axiom of
%% choice in \cref{sec:incremental}.


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals{A}$
and morphisms $f$ to themselves. The structures we will build in \CP{}
\emph{refine} those in \Poset{}, in the sense of commuting with $\valfn$. For
example, for cartesian products, $\vals{(A \x B)} = \vals{A} \x \vals{B}$ and
$\vals{\fork{f,g}} = \fork{\vals f, \vals g}$.
%
For brevity, we omit the ``value components'' of our constructions when they can
be derived from this fact, only defining $\chgs{A}$ and $\upd$ and showing the
existence of derivatives.


\subsection{Cartesian structure}
\label{sec:CP-cartesian}

\CP{} has all finite products and sums. The value-level structure is inherited
from \Poset{} along \valfn{}. The change-poset structure is also inherited from
\Poset{}, while the projection and injection's derivatives operate pointwise on
changes:

\nopagebreak[2]
\begin{align*}
  \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
  \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
  %\label{eqn:delta-distributes-over-sums-and-products}
  \\
  \deriv\pi_i\<x\<\dx &= \pi_i\<\dx & \deriv\injc_i\<x\<\dx &= \inj i \dx
\end{align*}

\noindent Updates are pointwise, noting that $(\inj i x \upd \inj j \dx)$ is
undefined for $i \ne j$:

\nopagebreak[2]
\begin{align*}
  (x_i)_i \upd (\dx_i)_i &= (x_i \upd \dx_i)_i &
  \inj i x \upd \inj i \dx &= \inj i (x \upd \dx)
\end{align*}

\noindent
Soundness \& completeness for increases follow directly from the pointwise
orderings of products \& coproducts in \Poset{}.

Fork's derivative $\deriv{\fork{f_i}_i}$ is $\fork{\deriv f_i}_i$:

\nopagebreak[2]
\begin{equation*}
  \fork{f_i}_i \<(x \upd \dx)
  = (f_i(x \upd \dx))_i
  = (f_i\<x \upd \deriv f_i \<x \<\dx)_i
  = \fork{f_i}_i \<x \upd \fork{\deriv f_i}_i \<x \<\dx
\end{equation*}

\noindent
A derivative for split must obey

\nopagebreak[2]
\begin{equation*}
\krof{f_i}_i\<(\inj i x \upd \inj i \dx)
= f_i\<x \upd \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj i \dx)
\end{equation*}

\noindent
so one valid choice is

\nopagebreak[2]
\begin{equation*}
  \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj j \dx)
  =
  \begin{cases}
    \deriv f_i \<x \<\dx & \text{if}~i = j\\
    \deriv f_i \<x \<\zero_x & \text{otherwise}
  \end{cases}
\end{equation*}

\noindent
The second case is dead code; any value of the right type would do. We will
exploit this in \cref{sec:incremental} to avoid needing the axiom of choice
(used to define $\zero_x$) in the context of Datafun.


\subsection{Exponentials}
\label{sec:CP-exponentials}

The change poset of the exponential object $\expO A B \in \CP$ consists of maps
$\vals A \to \Poset(\chgs A, \chgs B)$, ordered pointwise. The update relation
is:

\nopagebreak[2]
\begin{equation}\label{eqn:function-update}
  \vld{\df}{f}{g} : \expO A B
  \iff \fa{\vld\dx x y} \longvld{\df\<x\<\dx} {f\<x} {g\<y}
\end{equation}

\noindent Informally, this says a function change $\df$ is valid so long as it
takes valid input changes to valid output changes: if $\dx$ is a change to $x$,
then $\df\<x\<\dx$ must be a change to $f\<x$.

To show this defines a unique partial function \updfn, suppose $\vld\df f g$ and
$\vld\df f h$ and consider any $x : A$. \Cref{eqn:function-update} applied to
$\vld{\zero_x} x x$ gives us $\longvld{\df\<x\<\zero_x}{f\<x}{g\<x}$ and
$\longvld{\df\<x\<\zero_x}{f\<x}{h\<x}$. Then we know \(f\<x \upd
\df\<x\<\zero_x = g\<x = h\<x \), proving $g = h$. And so, whenever $f \upd \df$
is defined, we have

\nopagebreak[2]
\begin{equation*} (f \upd \df)\<x = f\<x \upd \df\<x\<\zero_x \end{equation*}

\noindent
and more generally, \cref{eqn:function-update} can be rewritten:

\nopagebreak[2]
\begin{equation*} f\<x \upd \df\<x\<\dx = (f \upd \df)\<(x \upd \dx) \end{equation*}

\noindent
Soundness \& completeness for increases at $\expO A B$ follows from soundness \&
completeness at $A$ and $B$ and the axiom of choice. % TODO?: Elaborate?

The derivative of the evaluation map is given by

\nopagebreak[2]
\[\begin{array}{l}
  \deriv{\fname{eval}} \,:\,
  %(\expO{\vals A}{\vals B})
  \Poset(\vals A, \vals B)
  \x \vals A \to
  \Poset({\chgs{(\expO A B)} \x \chgs A},{\chgs B})
  \\
  \deriv{\fname{eval}} \<(f,a) \<(\df,\da) = \df\<a\<\da
\end{array}\]

\noindent
And for $f : \CP(\G \x A, B)$, the derivative of the curried $\fn f : \CP(\G,
\expO A B)$ is given by currying the derivative:

\[
\begin{array}{l}
  \deriv{(\fn f)} \,:\, \vals\G \to \expO{\chgs \G}{\chgs{(\expO A B)}}\\
  \deriv{(\fn f)} \<\gamma \<\mathvar{\dgamma} \<a \<\da
  = \deriv f \<(\gamma,a) \<(\mathvar{\dgamma}, \da)
\end{array}
\]

\noindent
Correctness of $\deriv{\fname{eval}}$ follows from the validity of \df\ and \da;
correctness of $\deriv{(\fn f)}$ follows from correctness of \deriv{f}.

%% Exponential is:
%% eval : (A => B) x A -> B
%%
%% Given f : Γ x A -> B
%% Exists λf : Γ -> (A => B)
%% such that f = (λf × id); eval

% WTS: f ≤ g ⇔ ∃df. f -df-> g

% Suppose f ≤ g.
% WTS: ∃df. f --df--> g.
% Let's calculate! df has to be such that
% ∀(x -dx-> y) f x --df x dx--> g y
% Suppose (x -dx-> y)
%
% Suppose f -df-> g.
% Consider x : A. WTS: f x <= g y. Know x --0x--> x.
% Thus f x --df x 0x--> g x. So by soundness f x <= g x.

%% \begin{align*}
%%   f \le g : \vals{(\expO A B)}
%%   &\iff f \le g : \expO{\vals A}{\vals B}\\
%%   &\iff \fa{x \le y} f\<x \le g\<y\\
%%   &\iff \fa{x,y} (\ex{\dx} \vld{\dx} x y)
%%   \implies \ex{\dx} \vld{\dx}{f\<x}{g\<y}\\
%%   &\iff \todo{???}\\
%%   &\iff \ex{\df} \vld{\df} f g
%% \end{align*}


%% TODO: maybe call this \iso_{\boldsymbol\Delta} instead?
\subsection{The lifted \iso{} comonad and its relatives}
\label{sec:CP-iso}

Now we construct a comonad $\iso$ on \CP\ such that $\valfn\iso_\CP =
\iso_\Poset\valfn$. This requirement defines the value-level structure, leaving
only the change poset and update map. Since $\isof A$ is ordered discretely,
values \emph{cannot} increase. So the simplest definition that is sound and
complete for increases is:

\nopagebreak[2]
\begin{align*}
  \chgs{\isof A} &= \termO
  &
  x \upd_{\isof A} \tuple{} = x
\end{align*}

\noindent
Functoriality, extraction, duplication, and product- and sum-distribution all
refine the corresponding properties of $\iso_\Poset$, and their derivatives are
fairly straightforward:
%
\begin{mathpar}
  \deriv{\iso(f)} \<x \<\tuple{} = \tuple{}

  \deriv\delta_A \<x \<\tuple{} = \tuple{}

  \deriv\varepsilon_A \<x \<\tuple{} = \zero_x
  \\
  \deriv{{\discox}} \<x \<\dx = \tuple{}

  \deriv{{\discosum}} \<(\inj i x) \<\tuple{} = \inj i {\tuple{}}
\end{mathpar}


\subsubsection{The alternative \altiso}

Although we will not use it, there is another refinement of $\iso$ in \CP{},
which I'll call $\altiso$ for clarity, defined like so:

\nopagebreak[2]
\begin{align*}
  \chgs{\altiso A} &= \altiso \chgs A
  &
  x \upd_{\altiso A} \dx = y &\iff x = y \wedge x \upd_A \dx = y
\end{align*}

\noindent
So $\altiso A$ inherits all of $A$'s changes, but ordered discretely and with
\emph{only zero-changes still valid}. The derivatives of functoriality,
duplication, and extraction are different:

\nopagebreak[2]
\begin{align*}
  \deriv{\altiso(f)} &= \deriv f
  & \deriv\delta_A \<x\<\dx &= \dx
  & \deriv\varepsilon_A \<x\<\dx &= \dx
\end{align*}

\noindent
Observe that we no longer need the non-constructive $\zero_x$ to define comonad
extraction $\varepsilon$! However, for our purposes this will not be an issue.
Meanwhile, product- and sum-distribution become identity maps, because $\prod_i
\altiso A_i = \altiso \prod_i A$ and $\sum_i \altiso A_i = \altiso \sum_i
A_i$.\footnote{Checking this is left as an exercise for the reader.}


\subsection{The lifted \pfin\ functor}
\label{sec:CP-pfin}

We lift the finite powerset functor \pfin\ to \CP\ as follows:

\nopagebreak[2]
\begin{align}
  \chgs{\pfinof A} &= \pfinof{\vals A} &
  x \upd_{\pfinof A} \dx &= x \cup \dx
  \label{eqn:CP-pfin}
\end{align}

\noindent
Since the arguments to \morph{singleton} and \morph{isEmpty} cannot change
(having $\iso$ type), their derivatives always return zero-changes:

\nopagebreak[2]
\begin{align*}
  \deriv{\morph{singleton}}_A \<x \<\tuple{} &= \emptyset &
  \deriv{\morph{isEmpty}} \<x \<\tuple{} &= \morph{isEmpty} \< x
\end{align*}


\subsection{Equality objects}
\label{sec:CP-eq}

Every object in \CP{} is an equality object, with \morph{eq} and its derivative
defined by:

\nopagebreak[2]
\begin{align*}
  \morph{eq}\<\tuple{x,y} &= 
  \begin{cases}
    \{\tuple{}\} & \text{if}~ x = y\\
    \emptyset & \text{otherwise}
  \end{cases}
  &
  \deriv{\morph{eq}} \<\pwild \<\pwild &= \emptyset
\end{align*}

\noindent Since \emph{every} object is an equality object, every equality type
is trivially interpreted into an equality object. \todo{TODO more explanation
  --- why isn't every type an equality type, then?}


\subsection{Semilattice objects and collecting morphisms}
\label{sec:CP-semilattice}

A semilattice object $L$ in \CP\ is one where $\vals L = \chgs L$ is a
semilattice and $x \upd_L y = x \vee y$. This immediately justifies letting
$\deriv{\morph{join}} \<x \<\dx = \morph{join}\<\dx$, because:

\nopagebreak[2]
\begin{align*}
  \morph{join}\<(x \upd \dx) &= \bigvee_i \pi_i \<(x \vee \dx)\\
  &= \left(\bigvee_i \pi_i\<x\right) \vee \left(\bigvee_i \pi_i\<\dx\right)\\
  &= \morph{join}\<x \vee \morph{join}\<\dx\\
  &= \morph{join}\<x \upd \deriv{\morph{join}}\<x\<\dx
\end{align*}

\begin{restatable}{lemma}{lemSemi}
  \label{lem:semi} $\incdens L$ is a semilattice object.
\end{restatable}
\begin{proof}
  By induction on $\eqt L$. See \cpageref{proof:semi}.
\end{proof}


\subsection{Collecting morphisms}
\label{sec:CP-collect}

Let $\G, A$ be objects, $L$ be a semilattice object, and $f : \G \x \isof A \to
L$. Our derivative for $\pcollect f : \G \x \pfinof A \to L$ is:

\nopagebreak[2]
\begin{align*}
  \deriv{\pcollect f} \<\tuple{\gamma,s} \<\tuple{\dgamma,\ds}
  &= \bigvee_{x \in \ds} f\<\tuple{\gamma,x} \vee
  \bigvee_{x \in s \cup \ds} \deriv f \<\tuple{\gamma,x} \<\tuple{\dgamma, \zero_x}
\end{align*}

\noindent To establish that this is correct, suppose
$\longvld{\dgamma}{\gamma}{\gamma'} : \G$. From this we have:

\nopagebreak[2]
\begin{align*}
  &\phantom{{}={}}\pcollect{f} \<\tuple{\gamma', s \cup \ds}
  \\
  &= \bigvee_{x \in s \cup \ds} f \<\tuple{\gamma', x}
  \\
  &\overset{\footnotemark}{=} \bigvee_{x \in s \cup \ds} \bigl(f \<\tuple{\gamma,x}
  \vee \deriv f \<\tuple{\gamma,x} \<\tuple{\dgamma,\zero_x}\bigr)
  \\
  &= \bigvee_{x \in s} f\<\tuple{\gamma,x}
  \upd \bigvee_{x \in \ds} f\<\tuple{\gamma,x}
  \vee \bigvee_{x \in s \cup \ds} \deriv f \<\tuple{\gamma,x} \<\tuple{\dgamma,\zero_x}
  \\
  &= \pcollect f \<\tuple{\gamma,s}
  \upd \deriv{\pcollect f} \<\tuple{\gamma,s} \<\tuple{\dgamma,\ds}
\end{align*}

\nopagebreak% for footnote to be on same page as mark
\noindent
Which is what we wished to show.\footnotetext{This equality follows from the
  correctness of $\deriv f$ applied to
  \(\longvld{\tuple{\dgamma,\zero_x}}{\tuple{\gamma,x}}{\tuple{\gamma',x}}\).}


\subsection{Fixed point objects}
\label{sec:CP-fix}

A fixed point object $\fixt L$ in \CP\ is a semilattice object such that
$\vals{\fixt L}$ satisfies the ascending chain condition. \todo{TODO more
  explanation.} Since the argument to \morph{fix} is boxed and cannot change,
$\deriv{\morph{fix}}$ needs to produce a zero change; and at any semilattice
object, $\bot$ is a zero change, so:

\nopagebreak[2]
\[ \deriv{\morph{fix}} \<x \<\tuple{} = \bot \]

\begin{lemma}\label{lem:fixobject}
  \(\incdens{\fixt L}\) is a fixed point object.
\end{lemma}
\begin{proof}
  By induction on $\fixt L$. \todo{TODO}
\end{proof}


\section{Incrementalization}
\label{sec:incremental}

The \emph{incremental semantics} for Datafun, notated $\incden{-}$, is given by
the Datafun model in \CP{} constructed in \cref{sec:changeposets}, letting
$\disco = \iso_\CP$ and $\pfin = \pfin_\CP$. As we took care to show while
constructing it, this \emph{refines} the standard model along the forgetful
functor $\valfn$, that is:

\begin{restatable}{theorem}{thmForget}
  \label{thm:forget}
  \(\vals{\incden{-}} = \den{-}_\Poset\).
\end{restatable}

\begin{proof}
  By induction on types and typing derivations; see \cpageref{proof:forget}.
\end{proof}

The change poset $\D\incdens A$ of a Datafun type $A$ is internally definable
via a type translation given in \cref{fig:PhiDelta}, also named $\D$, despite
the risk of confusion.

\begin{figure*}
  \begin{align*}
    \D\tunit &= \tunit & \Phi\tunit &= \tunit
    \\
    \D \isof A &= \tunit & \Phi \isof A &= \isof{(\Phi A \x \DP A)}
    \\
    \D\tseteq A &= \tseteq A &
    \Phi\tseteq A &= \tset{\Phi{\eqt A}}\\
    \D(A \x B) &= \D A \x \D B & \Phi(A \x B) &= \Phi A \x \Phi B\\
    \D(A + B) &= \D A + \D B & \Phi(A + B) &= \Phi A + \Phi B\\
    \D(A \to B) &= \isof A \to \D A \to \D B &
    \Phi(A \to B) &= \Phi A \to \Phi B
  \end{align*}

  \todo{TODO: need lemma that $\Phi{\eqt A}$ is an eqtype}

  \caption{The $\D$ and $\Phi$ type translations}
  \label{fig:PhiDelta}
\end{figure*}

\begin{restatable}{theorem}{thmDeltaDen}
  \label{thm:delta-den}
  \(\D\incdens A = \den{\D A}\).
\end{restatable}
\begin{proof}
  Induct on types; see \cpageref{proof:delta-den}.
\end{proof}


%% ---- More figures ----
%% \begin{figure*}
%%   \begin{align*}
%%     \delta x &= \dx\\
%%     \delta (\fnof{x} e) &= \fnof{\eboxd x}\fnof\dx \delta e &
%%     \delta (e\<f) &= \delta e \<\eboxd f \<\delta f\\
%%     \delta \etuple{e,f} &= \etuple{\delta e, \delta f} &
%%     \delta (\pi_i\<e) &= \pi_i\< \delta e\\
%%     \delta (\inj i e) &= \inj i {\delta e}\\
%%     \delta \bot &= \bot &
%%     \delta (e \vee f) &= \delta e \vee \delta f\\
%%     \delta \etrue = \delta \efalse &= \efalse
%%     & \delta\esetd{e_i}_i &= \eset{}\\
%%     \delta \eboxd{e} &= \eboxd{\delta e}
%%     & \delta(\esplit e) &= \esplit \delta e
%%   \end{align*}

%%   \begin{align*}
%%     \delta(\elet{\eboxd x = e} f)
%%     &= \elet{\eboxd x = e \mathrel{\kwname{and}} \eboxd\dx = \delta e} \delta f
%%     \\
%%     \delta (\efix e) &= \efix (\delta e \<\eboxd{\efix e}) \\
%%     \delta (\eifd e f g) &= \eifd{e}{\delta f}{\delta g}\\
%%     \delta (\ewhen e f) &= \eifd e {\delta f} \ewhen{\delta e} f \vee \delta f\\
%%     \delta (\eford x e f)
%%     &= (\eford x {\delta e} f)\\
%%     &\vee (\eford x{e \vee \delta e} \substd{\delta f}{\dx \substo \zero\< x})\\
%%     \delta (\ecase e (\inj i x \caseto f_i)_i)
%%     %% &= \ecase{\esplit{\eboxd e}}\\
%%     %% &\qquad(\inj i \eboxd{x} \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i
%%     &= \ecase{\esplit{\eboxd e},\, \delta e}\\
%%     &\qquad ({\inj i \eboxd x,\, \inj i \dx} \caseto \delta f_i)_i\\
%%     &\qquad \textit{\commentcolor --- The following cases are unreachable.}\\
%%     &\qquad ({\inj i \eboxd x,\, \pwild} \caseto
%%     %\elet{\dx = \dummy\<x}
%%     \subst{\delta f_i}{\dx \coloneqq \dummy\<x})_i
%%   \end{align*}
%%   \caption{The derivative translation}
%%   \label{fig:derivatives}
%% \end{figure*}


\section{Semi\naive{} evaluation}
\label{sec:seminaive}

\renewcommand\isocx\isof

\todo{TODO: explain faster-fix?}
\todo{TODO: explain $\Phi$ type transformation.}

\Cref{fig:seminaive-phi,fig:seminaive-delta} define two mutually recursive
static transformations: $\phi e$, which computes $e$ \emph{semi\naive{}ly},
speeding up fixed point computation by using derivatives; and $\delta e$, which
computes the \emph{derivative} of $\phi e$.
%
To describe the types of $\phi e$ and $\delta e$, we'll need three new operators
on contexts: $\isocx\G$, $\D\G$, and $\Phi\G$. We define these by their
pointwise action on hypotheses: \todo{TODO: intuition}

\nopagebreak[2]
\begin{align*}
  \isocx{(\h x A)} &= \hd x A & \isocx{(\hd x A)} &= \hd x A\\
  \D(\h x A) &= \h \dx {\D A} & \D(\hd x A) &= \emptycx \quad\text{(the empty context)}\\
  \Phi(\h x A) &= \h x {\Phi A} & \Phi(\hd x A) &= \hd x {\Phi A}, \hd \dx {\DP A}
\end{align*}

\noindent For example,
%
\begin{mathpar}
  \isocx{(\h x A, \hd y B)} = \hd x A, \hd y B

  \D(\h x A, \hd y B) = \h \dx {\D A}

  \Phi(\h x A, \hd y B) = \h x {\Phi A}, \hd y {\Phi B}, \hd \dy {\DP B}
\end{mathpar}

\noindent
The idea here is that:

\nopagebreak[2]
\begin{align*}
  \den{\isocx\G} &\cong \isof{\den\G} &
  \den{\D\G} &\cong \D\incdens\G &
  \den{\Phi\G} &\cong \text{\todo{harder to describe}}
\end{align*}

%% The type of $\delta e$ involves a
%% strengthening operator $\isocx{\G}$ that makes every variable in $\G$
%% discrete:
%% %
%% \begin{mathpar}
%%   \isocx{(H_i)_i} = (\isocx{H_i})_i

%%   \isocx{\h x A} = \hd x A

%%   \isocx{\hd x A} = \hd x A
%% \end{mathpar}

%% \noindent
%% Be careful not to confuse $\isocx\G$, which strengthens $\G$ by making every
%% variable discrete, with $\stripcxd{\G}$, which weakens $\G$ by removing all
%% \emph{except} the discrete variables.

%% \begin{restatable}[Type-correctness]{theorem}{thmTypeCorrect}
%%   \label{thm:type-correct}
%%   If $\J e \G A$, then
%%   \[ \J {\phi e} {\Phi\G, \D\Phi\stripcxd{\G}} {\Phi A}
%%   \qquad\text{and}\qquad
%%   \J {\delta e} {\isocx{\Phi\G}, \D\Phi\G} {\D\Phi A}
%%   \]
%% \end{restatable}

\begin{restatable}[Type-correctness]{theorem}{thmTypeCorrect}
  \label{thm:type-correct}
  If $\J e \G A$, then
  \[ \J {\phi e} {\Phi\G} {\Phi A}
  \qquad\text{and}\qquad
  \J {\delta e} {\isocx{\Phi\G}, \DP\G} {\DP A}
  \]
\end{restatable}
\begin{proof}
  By induction on typing derivations; see \cpageref{proof:typeCorrect}.
\end{proof}

\noindent To get the hang of these context and type transformations, let's
suppose that $\J e {\h x A, \hd y B} C$. Then \cref{thm:type-correct} tells us:
%
\begin{mathpar}
  \J {\phi e} {\h x {\Phi A}, \hd y {\Phi B}, \hd \dy {\DP B}} {\Phi C}

  \J {\delta e} {\hd x {\Phi A}, \h\dx{\DP A}, \hd y {\Phi B}, \hd \dy {\DP B}} {\DP C}
\end{mathpar}

\todo{TODO: Explain the use of weakening in semi\naive{} $\delta(e\<f)$,
  hilighted in {\color{Rhodamine}pink}.}


%% \begin{figure*}
%%   \begin{align*}
%%     \Phi \tunit &= \tunit & \D\tunit &= \tunit\\
%%     \Phi \tdown{\eqt A} &= \tdown{\Phi \eqt A} & \D\tdown{\eqt A} &= \tdown{\Phi \eqt A}\\
%%     \Phi \isof A &= \isof{(\Phi A \x \D A)}
%%     & \D\isof A &= \isof \D A\\
%%     \Phi(A \to B) &= \Phi A \to \Phi B
%%     & \D(A \to B) &= \isof \Phi A \to \D A \to \D B\\
%%     \Phi(A \x B) &= \Phi A \x \Phi B & \D(A \x B) &= \D A \x \D B\\
%%     \Phi(A + B) &= \Phi A + \Phi B & \D(A + B) &= \D A + \D B
%%   \end{align*}
%%   \caption{Semi\naive{} type translation}
%% \end{figure*}


%% ---- Seminaive ("go faster") term translation ----
\begin{figure*}
  %% TODO: think about this translation and syntax sugar. for example, the
  %% case-split I use in \phi(\esplit e) is only valid *because* \esplit exists.
  %%
  %% Would be nice to give the syntax sugar explicitly, but maybe more effor
  %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.
  \figsectionname{Interesting cases}

  \begin{align*}
    \phi(\prim{fix}\<e) &= \prim{fast-fix}\<\phi e\\
    \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
    \\
    \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
    \\
    \phi(\eford x e f)
    &= \eford x {\phi e} {\phi \substd{f}{dx \substo \zero\<x}}
    \\
    %% TODO: check this lines up with \delta(if then else), because that's where
    %% it comes up.
    \phi(\esplit e) &= \ecase{\phi e}\\
    &\phantom{{}={}}\quad
    \left(\eboxd{\etuple{\inj i x, \inj i \dx}}
    \caseto \inj i {\eboxd {\etuple{x,\dx}}}\right)_{i\in\{1,2\}}
    \\
    &\phantom{{}={}}\quad
    \left(\eboxd{\etuple{\inj i x, \pwild}}
    \caseto \inj i {\eboxd {\etuple{x, \dummy\<x}}} \right)_{i\in\{1,2\}}
    %% \phi(\esplit e) &= \color{red} \elet{\eboxd{x} = \phi e}\\
    %% &\phantom{{}={}} \esplit [\isocolor \ecase x\\
    %% &\phantom{= \esplit}\quad\isocolor
    %%   (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
    %% &\phantom{= \esplit}\quad
    %%   {\isocolor(\etuple{\inj i y, \pwild}
    %%     \caseto \inj i \etuple{y, \dummy\<y})_i}]
  \end{align*}
  \vspace{0pt} % <- yes, this matters.

  \figsectionname{Distributive cases}

  \begin{align*}
    %% TODO: I should mark discrete vs. monotone variables in some
    %% (colorblind/greyscale-printing)-safe way.
    \phi x &= x & \phi \dvar x &= \dvar x\\
    \phi(\fnof x e) &= \fnof x \phi e & \phi(e\<f) &= \phi e\<\phi f\\
    \phi\etuple{e_i}_i &= \etuple{\phi e_i}_i &
    \phi(\pi_i\<e) &= \pi_i\<\phi e\\
    \phi(\inj i e) &= \inj i \phi e\\
    \phi\bot &= \bot &
    \phi(e \vee f) &= \phi e \vee \phi f\\
    \phi(\esetd{e_i}_i) &= \esetd{\phi e_i}_i &
    \phi(\eeqd e f) &= \eeqd {\phi e} {\phi f}
  \end{align*}

  \begin{align*}
    \phi(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
    \\
    \phi(\eisEmpty e) &= \eisEmpty {\phi e}
  \end{align*}

  \caption{Semi\naive{} speed-up translation, $\phi$}
  \label{fig:seminaive-phi}
\end{figure*}


%% ----- Figure: Seminaive δ derivative -----
\begin{figure*}
  \[ \delta\bot = \delta\esetd{e_i}_i = \delta(\eeqd e f) = \delta(\efix e) = \bot \]

  \begin{align*}
    \delta x &= \dx &
    \delta \dvar x &= \dvar\dx\\
    \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e
    & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
    \delta\etuple{e_i}_i &= \etuple{\delta e_i}_i
    & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
    \delta(\inj i e) &= \inj i {\delta e} &
    \delta(e \vee f) &= \delta e \vee \delta f\\
    \delta\eboxd{e} &= \etuple{} &
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f
  \end{align*}

  \begin{align*}
    %% TODO: double-check this!
    \delta(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\esplit{\eboxd{\color{Rhodamine} \phi e}},\, \delta e}\\
    &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad ({\inj i {\eboxd x},\, \pwild}
      \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
    %% &= \ecase{\esplit{\eboxd{\phi e}}}\\
    %% &\qquad (\inj i \eboxd x
    %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
    %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
    %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
    \\
    %% \delta(\ebigvee x e f)
    %% &= (\ebigvee x {\delta e} {\color{Rhodamine}\phi f})
    %% \vee
    %% (\ebigvee x {{\color{Rhodamine}\phi e} \vee \delta e} {\delta f})
    %% TODO: is weakening being used here?
    \delta(\eford x e f)
    &= (\eford x {\delta e} \substd{\phi f}{\dx \substo \zero\<x}) \\
    &\vee (\eford x {{\phi e} \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
    \substd{\delta f}{\dx \substo \zero\<x})
    \\
    \delta(\eisEmpty e) &= \eisEmpty {\color{Rhodamine} \phi e}
    \\
    \delta(\esplit e) &= \ecase{\phi e}
    (\eboxd{\eboxd{\etuple{\inj i \pwild, \pwild}}}
    \caseto \inj i {\etuple{}} )_i
  \end{align*}

  \caption{Semi\naive{} derivative translation, $\delta$}
  \label{fig:seminaive-delta}
\end{figure*}


%% ---- old seminaive term translation ----
%% \begin{figure*}
%%   \begin{align*}
%%     \phi x &= x & \delta x &= \dx\\
%%     \phi(\fnof x e) &= \fnof x \phi e
%%     & \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e\\
%%     \phi(e\<f) &= \phi e\<\phi f
%%     & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
%%     \phi\etuple{e,f} &= \etuple{\phi e, \phi f}
%%     & \delta\etuple{e,f} &= \etuple{\delta e, \delta f}\\
%%     \phi(\pi_i\<e) &= \pi_i\<\phi e
%%     & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
%%     \phi(\inj i e) &= \inj i \phi e
%%     & \delta(\inj i e) &= \inj i \delta e\\
%%     \phi\etrue &= \etrue & \delta\etrue &= \efalse\\
%%     \phi\efalse &= \efalse & \delta\efalse &= \efalse\\
%%     \phi\bot &= \bot & \delta\bot &= \bot\\
%%     \phi(e \vee f) &= \phi e \vee \phi f
%%     & \delta(e \vee f) &= \delta e \vee \delta f\\
%%     \phi\esetd{e_i}_i &= \esetd{\phi e_i}_i & \delta\esetd{e_i}_i &= \esetd{}\\
%%     \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
%%     & \delta\eboxd{e} &= \eboxd{\delta e}
%%   \end{align*}

%%   %% TODO: determine exactly how much syntax sugar I want to allow in the target
%%   %% of this translation. for example, the case-split I use in \phi(\esplit e)
%%   %% is only valid *because* \esplit exists.
%%   %%
%%   %% Would be nice to give the syntax sugar explicitly, but maybe more effor
%%   %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.

%%   %% TODO FIXME: \phi(\fix e), \delta(\fix e)!
%%   %% TODO FIXME: \phi(if then else), \delta(if then else)!

%%   \begin{align*}
%%     \phi(\ecase e (\inj i x \caseto f_i)_i)
%%     &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
%%     \\
%%     \delta(\ecase e (\inj i x \caseto f_i)_i)
%%     &= \ecase{\esplit{\eboxd{\phi e}},\, \delta e}\\
%%     &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
%%     &\qquad ({\inj i {\eboxd x},\, \pwild}
%%       \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
%%     %% &= \ecase{\esplit{\eboxd{\phi e}}}\\
%%     %% &\qquad (\inj i \eboxd x
%%     %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
%%     %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
%%     %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
%%     \\
%%     \phi(\eford x e f)
%%     &= \eford{x}{\phi e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
%%     \substd{\phi f}{\dx \substo \zero\<x}
%%     \\
%%     \delta(\eford x e f)
%%     &= (\eford x{\delta e} \substd{\phi f}{\dx \substo \zero\<x}) \\
%%     &\vee (\eford x{e \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
%%     \substd{\delta f}{\dx \substo \zero\<x})
%%     \\
%%     \phi(\ewhen e f) &= \ewhen{\phi e} \phi f
%%     \\
%%     \delta(\ewhen e f)
%%     &= \eifd{\phi e}{\delta f} \ewhen{\delta e} \phi f \vee \delta f
%%     \\
%%     \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
%%     \\
%%     \delta(\elet{\eboxd x = e} f)
%%     &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f
%%     \\
%%     \phi(\esplit e) &=
%%     %% \elet{\eboxd{\etuple{y,\dy}} = \phi e}\\
%%     %% &\phantom{{}={}} \ecase{\esplit{\eboxd y}}\\
%%     %% &\qquad (\inj i \eboxd x \caseto
%%     %% \substd{\phi f_i}{\dx \substo \extract_i\<y\<\dy})_i
%%     %%
%%     %% \elet{\eboxd{\etuple{x,\dx}} = \phi e}\\
%%     %% &\phantom{{}={}}\ecase{\esplit {\eboxd x}, \esplit {\eboxd\dx}}\\
%%     %% &\qquad (\inj i \eboxd x, \inj i \eboxd\dx
%%     %% \caseto \inj i \eboxd{\etuple{x,\dx}})_i\\
%%     %% &\qquad (\inj i \eboxd x, \pwild
%%     %% \caseto \inj i \eboxd{\etuple{x,\dummy\<x}})_i
%%     %%
%%     \elet{\eboxd{x} = \phi e}\\
%%     &\phantom{{}={}} \esplit [\isocolor \ecase x\\
%%     &\phantom{= \esplit}\quad\isocolor
%%       (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
%%     &\phantom{= \esplit}\quad
%%       {\isocolor(\etuple{\inj i y, \pwild}
%%         \caseto \inj i \etuple{y, \dummy\<y})_i}]
%%     %%
%%     %% \ecase{\phi e}\\
%%     %% &\qquad (\eboxd{\etuple{\inj i x, \inj i \dx}}
%%     %% \caseto \inj i \eboxd{x,\dx})_i\\
%%     %% &\qquad (\eboxd{\etuple{\inj i x, \pwild}}
%%     %% \caseto \inj i \eboxd{x, \dummy\<x})_{i}
%%     \\
%%     \delta(\esplit e) &= \esplit \delta e
%%   \end{align*}

%%   \todo{TODO: split cases for non-core syntax into separate figure.}

%%   \caption{Semi\naive{} term translation}
%% \end{figure*}


%% ----- Figure: Dummy function -----
\begin{figure*}
  \[\setlength\arraycolsep{.3em}\begin{array}{lcl}
    \dummy &:& A \to \D A\\
    \dummy \<(\pwild : \tbool) &=& \efalse\\
    \dummy \<(\pwild : \tset{A}) &=& \eset{}\\
    \dummy \<\eboxd{x} &=& \eboxd{\dummy\<x}\\
    \dummy \<(f : A \to B) &=& \fnof{x} \dummy\<(f\<x)\\
    \dummy \<\etuple{x,y} &=& \etuple{\dummy\<x, \dummy\<y}\\
    %% \dummy \<\etuple{x_i}_i &=& \etuple{\dummy\<x_i}_i\\
    \dummy \<(\inj i x) &=& \inj i (\dummy\<x)
  \end{array}\]
  \caption{The \dummy\ function}
  \label{fig:dummy}
\end{figure*}


\section{Logical relation}

\begin{definition}\label{def:approx}\label{def:approx-contexts}
  We define a type-indexed logical relation ${\impls_A} \subseteq \den{\Phi A} \x
  \den{A}$ as follows:

  \nopagebreak[2]
  \begin{align*}
    %% unit & products
    \tuple{x_i}_i \impls \tuple{y_i}_i &\iff \fa{i} x_i \impls y_i
    \\
    %% sums
    \inj i x \impls \inj j y &\iff i = j \wedge x \impls y
    \\
    %% functions
    f \impls_{A \to B} g &\iff \fa{x \impls_A y} f\<x \impls_B g\<y
    \\
    %% boxes
    \tuple{x,\dx} \impls_{\isof A} y
    &\iff x \impls_A y \wedge \vld{\dx} x x
    \\
    %% sets
    s \impls_{\tseteq A} t
    %% &\iff (\forall x \in s, \exists y \in t)~x\approx_{\eqt A} y
    %% \wedge (\forall y \in t, \exists x \in s)~x \approx_{\eqt A} y
    &\iff \faex{x \in s}{y \in t} x\approx_{\eqt A} y
    \wedge \faex{y \in t}{x \in s} x \approx_{\eqt A} y
  \end{align*}

  \noindent
  This lifts to contexts, ${\impls_\G} \subseteq \den{\Phi\G} \x \den\G$, as
  follows:

  \nopagebreak[2]
  \begin{align*}
    \gamma \impls_\G \rho
    &\iff \fa{\h x A \in \G} \gamma_x \impls \rho_x
    \\ &\phantom{\iff}
    \wedge \fa{\hd x A \in \G}
    (\gamma_{\dvar x} \impls \rho_{\dvar x}
    \wedge \longvld{\gamma_{\dvar{\dx}}}{\gamma_{\dvar x}}{\gamma_{\dvar x}})
  \end{align*}
\end{definition}

%% \noindent
%% Which can be lifted to morphisms (and thus term denotations) as follows:

%% \begin{align*}
%%   \impls_{\G \vdash A} &\subseteq \den{\Phi\G \vdash \Phi A} \x \den{\G \vdash A}\\
%%   f \impls_{\G \vdash A} g &\iff \fa{\gamma \impls_\G \gamma'} f\<\gamma \impls_A g\<\gamma'
%% \end{align*}

\begin{restatable}[Correctness]{theorem}{thmCorrect}\label{thm:correct}
  If $\J e \G A$ and $\gamma \impls_\G \rho$ then

  \begin{enumerate}
  \item \(\den{\phi e} \<\gamma \impls_A \den{e} \<\rho\).
  \item If $\longvld{\dgamma}{\g}{\g'}$ then \(\longvld{\den{\delta e}
    \tuple{\gamma,\dgamma}}{\den{\phi e} \<\gamma}{\den{\phi e} \<\gamma'}\).
  \end{enumerate}

  %% \nopagebreak[2]
  %% \begin{gather*}
  %% \text{(1)}~~ \den{\phi e}\<\gamma \impls_A \den{e}\<\rho
  %% \qquad\text{and}\qquad
  %% \text{(2)}~~
  %% \longvld{\den{\delta e} \tuple{\gamma,\dgamma}}{\den{\phi e} \<\gamma}{\den{\phi e} \<\gamma'}
  %% : \incdens{\Phi{A}}
  %% \end{gather*}

  \noindent
  Note that $\tuple{\gamma,\dgamma}$ is a slight abuse of notation here;
  \todo{TODO explain}.
\end{restatable}
\begin{proof}
  By induction on the derivation of $\J e \G A$. See \cpageref{proof:correct}.
\end{proof}


\section{Proof obligations when extending Datafun}

%% TODO: section on "proof obligations when extending Datafun"

\todo{This is all pretty speculative. I haven't given a proof that is
  parameterized enough to state that I've covered all my bases here. TODO: more.}

\begin{enumerate}
\item If you add a new first-order type, you must extend \dummy{} to compute
  $\zero$ for it.

\item \todo{TODO: this is out of date.} Make sure that $\delta\bot$, $\delta(e
  \vee f)$, and $\delta(\eford x e f)$ are still correct. In particular, suppose
  you add a new type constructor $T$ and consider any $\vec A$ such that $T\vec
  A$ is a semilattice type.\footnote{A base type is simply a nullary type
    constructor. If there are no $\vec A$ such that $T\vec A$ is a semilattice,
    you're done.}

  The simplest way to keep everything working is to ensure that $\D(T\vec A) =
  T\vec A$ and $\upd_{T\vec A} = \vee$; then you're done. But if $T\vec A$ is
  higher-order, this is unlikely to be true.

  Alternatively, so long as $\D(T\vec A)$ is a semilattice type whose join composes
  changes~--- that is, if $x \upd \bot = x$ and $x \upd (y \vee z) = (x \upd y)
  \upd z$~--- then $\delta\bot$ and $\delta(e \vee f)$ remain correct. This
  \emph{is} the case for functions. So how do we repair $\delta(\eford x e f)$?
  Well, Datafun's current solution is to \emph{expand away} higher-order uses of
  \kwname{for}; if you can likewise expand away uses of \kwname{for} at type
  $T\vec A$, you're set.

  Otherwise, you're on your own. You'll have to find a new definition of
  $\delta(\eford x e f)$ at type $T\vec A$ and prove it correct. Likewise, if
  $\D(T\vec A)$ isn't a semilattice whose join corresponds to change
  composition, you'll need new definitions of $\delta\bot$ and $\delta(e \vee f)$.

\item \todo{TODO: talk about letting $A \to L$ be a semilattice type and the
  pain that causes: have to $\eta$-expand \kwname{for}-loops at higher order
  types and either do the same for $\vee$ and $\bot$ or else change the semantic
  correctness proof.}

\end{enumerate}


\clearpage
\appendix
\begin{center}\Large\scshape Proofs\end{center}
\renewcommand\qed{\vspace{\baselineskip}\hrule}%FIXME hack.

%\section{Proofs}

%% \[\setlength\arraycolsep{.33em}\begin{array}{r@{\hskip 1em}ccl}
%%   \text{terms} & e,f,g &\bnfeq& x \bnfor \dvar x \bnfor \fnof{x} e
%%   \bnfor e\<f \bnfor \etuple{} \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
%%   &&&\inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
%%   &&&\bot \bnfor e \vee f \bnfor \edown{e} \bnfor \ebigvee x e f\\
%%   &&& \eboxd e \bnfor \elet{\eboxd x = e} f\\
%%   &&& \prim{isEmpty}\<e \bnfor \esplit e \bnfor \prim{eq}\<e \bnfor \efix e
%% \end{array}\]


\lemSemi*
\begin{proof}\label{proof:semi}
  By induction on $\eqt L$:

  \begin{description}
  \item[Case $\tunit$:] \(\vals{\den \tunit} = \chgs{\den \tunit} = \termO\),
    which is the trivial semilattice, and \(\tuple{} \upd \tuple{} = \tuple{}
    = \tuple{} \vee \tuple{}\).

  \item[Case $\eqt L \x \eqt M$:] \(\den{\eqt L \x \eqt M} = \den{\eqt L} \x
    \den{\eqt M}\), and by IH $\vals{\den{\eqt L}} = \chgs{\den{\eqt L}}$ and
    \(\vals{\den{\eqt M}} = \chgs{\den{\eqt M}}\) and both are semilattices. The
    product of semilattices is a semilattice itself, and update and semilattice
    join on products are both pointwise.

  \item[Case $\tseteq A$:] By \cref{eqn:CP-pfin}.
  \end{description}
\end{proof}


\thmForget*
\begin{proof}\label{proof:forget}

  We will make frequent and unremarked use of definitions from
  \cref{sec:changeposets}. First we induct on types to show $\vals{\incdens A} =
  \den A$. Equalities given by an inductive hypothesis are marked with a star,
  like so: $\stareq$.

  \begin{description}
    \item[Case $\isof A$:] \(\vals{\incdens{\isof A}}
      = \vals{\discof{\incdens A}}
      = \isof{\vals{\incdens A}} \stareq \isof{\den A}
      = \den{\isof A} \)

    %% \item[Case $\tset{\eqt A}$:]
    %%   \(\vals{\incdens{\tset{\eqt A}}} = \vals{\downof{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\vals{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\isof{\vals{\incdens{\eqt A}}}}
    %%   \stareq \downof{\isof{\den{\eqt A}}}
    %%   = \den{\tset{\eqt A}} \)

    \item[Case $\tset{\eqt A}$:]
      \(\vals{\incdens{\tset{\eqt A}}}
      = \vals{\pfinof{\incdens{\eqt A}}}
      = \pfinof{\vals{\incdens{\eqt A}}}
      \stareq \pfinof{\den{\eqt A}}
      = \den{\tset{\eqt A}} \)

    \item[Case $\tunit$:] \(\vals{\incdens \tunit} = \vals\termO = \termO = \den{\tunit}\)

    \item[Case $A \x B$:] \(\vals{\incden{A \x B}}
      = \vals{(\incdens A \x \incdens B)}
      = \vals{\incdens A} \x \vals{\incdens B}
      \stareq \den{A} \x \den{B}
      = \den{A \x B} \)

    \item[Case $A + B$:] \(\vals{\incden{A + B}}
      = \vals{(\incdens A + \incdens B)}
      = \vals{\incdens A} + \vals{\incdens B}
      \stareq \den{A} + \den{B}
      = \den{A + B}
      \)

    \item[Case $A \to B$:] \(\vals{\incden{A \to B}}
      = \vals{(\expO{\incdens A}{\incdens B})}
      = \expO{\vals\incdens A}{\vals\incdens B}
      \stareq \expO{\den A}{\den B}
      = \den{A \to B}
      \)
  \end{description}

  \noindent
  Then we induct on typing derivations to show $\vals \incdens e = \den e$:

  \begin{description}
    %% FIXME: need to use something other than color to distinguish monotone &
    %% discrete variables here!
  \item[Case $x$ (monotone)] \( \vals{\incdens x} = \vals\pi_x = \pi_x = \den{x} \)

  \item[Case $\dvar x$ (discrete)] \( \vals{\incdens {\dvar x}}
    = \vals{(\pi_{\dvar x} \then \varepsilon)}
    = \vals\pi_{\dvar x} \then \vals\varepsilon
    = \pi_{\dvar x} \then \varepsilon
    = \den{\dvar x} \)

  \item[Case $\fnof x e$]
    \( \vals{\incden{\fnof x e}}
    = \vals{\lambda\incdens e}
    = \lambda\vals{\incdens e}
    \stareq \lambda\den{e}
    \)

  \item[Case $e\<f$]
    \( \vals{\incden{e\<f}}
    = \vals{(\tuple{\incdens e, \incdens f} \then \morph{eval})}
    = \tuple{\vals{\incdens e}, \vals{\incdens f}} \then \morph{eval}
    \stareq \tuple{\den e, \den f} \then \morph{eval}
    = \den{e\<f}
    \)

  \item[Case $\etuple{e_i}_i$]
    \( \vals{\incdens\etuple{e_i}_i}
    = \vals{\tuple{\incdens {e_i}}_i}
    = \tuple{\vals{\incdens{e_i}}}_i
    \stareq \tuple{\den{e_i}}_i = \den{\etuple{e_i}_i}
    \)

  \item[Case $\pi_i\<e$]
    \( \vals{\incden{\pi_i\<e}} = \vals{(\incdens e \then \pi_i)}
    = \vals\incdens e \then \pi_i \stareq \den{e} \then \pi_i = \den{\pi_i\<e}
    \)

  \item[Case $\inj i e$]
    \(
    \vals{\incden{\inj i e}} = \vals{(\incdens e \then \injc_i)}
    = \vals\incdens e \then \injc_i
    \stareq \den{e} \then \injc_i = \den{\inj i e}
    \)

  \item[Case $(\ecase{e} (\inj i x \caseto f_i)_i)$]
    \begin{align*}
      \vals{\incden{\ecase{e} (\inj i x \caseto f_i)_i}}
      &= \vals{\left(\tuple{\id, \incdens{e}} \then \morph{dist}^\x_+
        \then \bigkrof{\incdens{f_i}}_i\right)}
      \\
      &= \tuple{\id,\vals\incdens e} \then \morph{dist}^\x_+
      \then \bigkrof{\vals\incdens{f_i}}_i
      && \text{by \cref{lem:vals-distx+}}
      \\
      &\stareq \tuple{\id, \den e} \then \morph{dist}^\x_+ \then \bigkrof{\den{f_i}}_i
      && \text{by IH}
      \\
      &= \den{\ecase{e} (\inj i x \caseto f_i)_i}
    \end{align*}

  \item[Case $\eboxd e$]
    \begin{align*}
      \vals\incdens{\eboxd e}
      &= \vals(\strip \then \isof{\incdens e})\\
      &= \strip \then \isof{\vals\incdens e}
      && \text{by \cref{lem:vals-strip}}\\
      &\stareq \strip \then \isof{\den e} && \text{by IH}\\
      &= \den{\eboxd e}
    \end{align*}

  \item[Case $(\elet{\eboxd x = e} f)$]
    \begin{align*}
      \vals\incden{\elet{\eboxd x = e} f}
      &= \vals(\tuple{\id, \incdens{e}} \then \incdens{f}))\\
      &= \tuple{\id, \vals\incdens e} \then \vals\incdens f\\
      &\stareq \tuple{\id, \den{e}} \then \den f &&\text{by IH}\\
      &= \den{\elet{\eboxd x = e} f}
    \end{align*}

  \item[Case $\bot$] \( \vals\incdens\bot = \vals{(\termI \then \morph{join}_0)}
    = \termI \then \morph{join}_0 = \den\bot \)

  \item[Case $e_1 \vee e_2$]
    \begin{align*}
      \vals{\incden{e_1 \vee e_2}}
      &= \vals{(\fork{\incdens{e_i}}_i \then \morph{join}_2)}
      && \text{by definition}\\
      &= \vals{\fork{\incdens{e_i}}_i} \then \vals{\morph{join}_2}
      && \text{functoriality of }\valfn\\
      &= \fork{\vals{\incdens{e_i}}}_i \then \morph{join}_2
      && \text{refinement along $\valfn$ (\cref{sec:CP-cartesian,sec:CP-semilattice})}\\
      &= \fork{\den{e_i}}_i \then \morph{join}_2
      && \text{inductive hypothesis}\\
      &= \den{e_1 \vee e_2}
      && \text{by definition}
    \end{align*}

  \item[Case $\esetd{e_i}_i$]
    \begin{align*}
      \vals{\incdens{\esetd{e_i}_i}}
      &= \vals{(\tuple{\incdens{\eboxd{e_i}} \then \morph{singleton}}_i \then \morph{join})}
      \\
      &= \tuple{\vals{\incdens{\eboxd{e_i}}} \then \morph{singleton}}_i \then \morph{join}
      && \text{refinement along \valfn}
      \\
      &\stareq \tuple{\den{\eboxd{e_i}} \then \morph{singleton}}_i \then \morph{join}
      && \text{same as case for $\eboxd e$}\\
      &= \den{\esetd{e_i}_i}
    \end{align*}

  \item[Case $(\eford x e f)$]
    \begin{align*}
      \vals{\incden{\eford x e f}}
      &= \vals{(\tuple{\id, \incdens e} \then \pcollect{\incdens f})}\\
      &= \tuple{\id, \vals{\incdens e}} \then \pcollect{\vals{\incdens f}}
      && \text{refinement along \valfn}\\
      &\stareq \tuple{\id,\den e} \then \pcollect{\den f} && \text{by IH}\\
      &= \den{\eford x e f}
    \end{align*}

  \item[Case $\eisEmpty e$]
    \begin{align*}
      \vals{\incden{\eisEmpty e}}
      &= \vals{(\incdens{\eboxd e} \then \morph{isEmpty})}\\
      &= \vals{\incdens{\eboxd e}} \then \morph{isEmpty}
      && \text{refinement along \valfn}\\
      &\stareq \den{\eboxd e} \then \morph{isEmpty}
      && \text{same as case for $\eboxd e$}\\
      &= \den{\eisEmpty e}
    \end{align*}

  \item[Case $\esplit e$]
    \begin{align*}
      \vals{\incden{\esplit e}}
      &= \vals{(\incdens{e} \then \morph{dist}^\iso_+)}\\
      &= \vals{\incdens e} \then \morph{dist}^\iso_+
      && \text{refinement along \valfn}\\
      &\stareq \den e \then \morph{dist}^\iso_+
      && \text{by IH}\\
      &= \den{\esplit e}
    \end{align*}

  \item[Case $\eeqd e f$]
    \begin{align*}
      \vals{\incden{\eeqd e f}}
      &= \vals{(\tuple{\incdens e, \incdens f} \then \morph{eq})}\\
      &= \tuple{\vals{\incdens e}, \vals{\incdens f}} \then \morph{eq}
      && \text{refinement along \valfn}\\
      &\stareq \tuple{\den e, \den f} \then \morph{eq}
      && \text{by IH}\\
      &= \den{\eeqd e f}
    \end{align*}

  \item[Case $\efix e$]
    \begin{align*}
      \vals{\incden{\efix e}}
      &= \vals{(\incdens e \then \morph{fix})}\\
      &= \vals{\incdens e} \then \morph{fix}
      && \text{refinement along \valfn}\\
      &\stareq \den{e} \then \morph{fix}\\
      &= \den{\efix e}
    \end{align*}
  \end{description}
\end{proof}


\begin{lemma}\label{lem:vals-distx+}
  \(\vals{\morph{dist}^\x_+} = \morph{dist}^\x_+\)
\end{lemma}
\begin{proof}
  \begin{align*}
    \vals{\morph{dist}^\x_+} &=
    \vals{(\fork{\pi_2 \then \krof{\lambda (\fork{\pi_2,\pi_1} \then \injc_i)}_i, \pi_1}
    \then \morph{eval})}\\
    &= \fork{\pi_2 \then \krof{\lambda (\fork{\pi_2,\pi_1} \then \injc_i)}_i, \pi_1}
    \then \morph{eval}
    && \text{refinement along \valfn}\\
    &= \morph{dist}^\x_+
  \end{align*}
\end{proof}

\begin{lemma}\label{lem:vals-strip}
  \(\vals{\strip} = \strip\)
\end{lemma}
\begin{proof}
  \XXX
\end{proof}


\thmDeltaDen*
\begin{proof}
  \label{proof:delta-den}
  By induction on types. Again, $\stareq$ marks equalities given by an inductive
  hypothesis; additionally, $\daggereq$ indicates an appeal to
  \cref{thm:forget}.
  \begin{description}
    \item[Case $\isof A$:] \(\chgs{\incdens{\isof A}}
      = \chgs{\discof{\incdens A}}
      = \termO = \den{1} = \den{\D \isof A}\)

    %% \item[Case $\tset{\eqt A}$:] \(\chgs{\incdens{\tseteq A}}
    %%   = \chgs{\downof{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\vals{\discof{\incdens{\eqt A}}}}
    %%   = \downof{\isof{\vals{\incdens{\eqt A}}}}
    %%   \daggereq \downof{\isof{\den{\eqt A}}}
    %%   = \den{\tseteq A}
    %%   \)

    \item[Case $\tset{\eqt A}$:] \(\chgs{\incdens{\tseteq A}}
      = \chgs{\pfinof{\incdens{\eqt A}}}
      = \pfinof{\vals{\incdens{\eqt A}}}
      \daggereq \pfinof{\den{\eqt A}}
      = \den{\tseteq A}
      \)

    \item[Case $\tunit$:] \(\chgs{\incdens \tunit}
      = \chgs \termO = \termO = \den{\tunit} \)

    \item[Case $A \x B$:] \(\chgs{\incden{A \x B}}
      = \chgs{(\incdens A \x \incdens B)}
      = \chgs{\incdens A} \x \chgs{\incdens B}
      \stareq \den{\D A} \x \den{\D B}
      = \den{\D A \x \D B}
      = \den{\D(A \x B)} \)

    \item[Case $A + B$:] \(\chgs{\incden{A + B}}
      = \chgs{(\incdens A + \incdens B)}
      = \chgs{\incdens A} + \chgs{\incdens B}
      \stareq \den{\D A} + \den{\D B}
      = \den{\D A + \D B}
      = \den{\D(A + B)} \)

    \item[Case $A \to B$:]
      \begin{align*}
        \chgs{\incden{A \to B}}
        &= \chgs{(\expO{\incdens A}{\incdens B})}\\
        &= \expO {\isof{\vals{\incdens A}}} {
          \expO {\chgs{\incdens A}} {\chgs{\incdens B}}}
        & \text{by definition in \cref{sec:CP-exponentials}}
        \\
        &\stardaggereq \expO {\isof {\den A}} {\expO {\den{\D A}} {\den{\D B}}}\\
        &= \den{\isof A \to \D A \to \D B}\\
        &= \den{\D(A \to B)}
      \end{align*}
  \end{description}
\end{proof}


\thmTypeCorrect*

\newcommand\deltacx[1]{\isocx{\Phi{#1}},\DP{#1}}
\newcommand\weirdover[2]{\hbox{\(\displaystyle\genfrac{}{}{-1pt}{}{#1}{#2}\)}}
\newcommand\deduce[2]{\infer*[myfraction=\weirdover]{#1}{#2}}

\begin{proof}\label{proof:typeCorrect}
  By induction on the typing derivation for $\J e \G A$.
  \begin{description}
  \item[Case $x$ (monotone):] $\phi x = x$ and $\delta x = dx$. Since $\h x A
    \in \G$, we have $\h x {\Phi A} \in \Phi\G$ and $\h\dx{\DP A} \in
    \DP\G$, so by weakening:
    %
    \begin{mathpar}
      \infer{\h x {\Phi A} \in \Phi\G}{\J x {\Phi\G} {\Phi A}}

      \infer{\h\dx{\DP A} \in \deltacx\G}{\J \dx {\deltacx\G} {\DP A}}
    \end{mathpar}

  \item[Case $\dvar x$ (discrete):] $\phi{\dvar x} = \dvar x$ and $\delta{\dvar
    x} = \dvar\dx$. Since $\hd x A \in \G$, we have $\hd x {\Phi A} \in \Phi\G$
    and $\hd\dx{\DP A} \in \isof{\Phi\G}$, so by weakening:
    %
    \begin{mathpar}
      \infer{\hd x {\Phi A} \in \Phi\G}{\J {\dvar x} {\Phi\G} {\Phi A}}

      \infer{\hd\dx{\DP A} \in \deltacx\G}{\J{\dvar\dx}{\deltacx\G}{\DP A}}
    \end{mathpar}

  \item[Case $\fnof x e$:]
    \todo{FIXME: this is all wrong now that I've changed notations!}
    \begin{align*}
      \phi(\fnof x e) &= \fnof x \phi e &
      \delta(\fnof x e) &= \fnof{\eboxd x} \fnof \dx \delta e\\
      &&&\desugars \fnof y \elet{\eboxd x = y} \fnof \dx \delta e
    \end{align*}

    So:
    \begin{mathpar}
      \infer*{
        \infer*[fraction={===},leftstyle={},Left={rewrite context}]{
          \deduce{\textit{by IH}}{\J{\phi e} {\Phi{(\G,\h x A)}} B}
        }{\J {\phi e} {\Phi{\G}, \h x {\Phi A}} {\Phi B}}
      }{\J {\fnof x \phi e} {\Phi\G} {\Phi A \to \Phi B}}

      \infer*{
        \infer*{
          \J y {\XXX} {\isof \Phi A} \\
          \J {\fnof\dx \delta e}
             {\deltacx\G, \h y {\isof{\Phi A}}, \hd x {\Phi A}}
             {\DP A \to \DP B}}{
          \J {\elet{\eboxd x = y} \fnof\dx \delta e}
             {\deltacx\G, \h y {\isof{\Phi A}}}
             {\DP A \to \DP B}}}{
        \J {\fnof y \elet{\eboxd x = y} \fnof{\dx} \delta e}
           {\deltacx\G}
           {\isof{\Phi A} \to \DP A \to \DP B}}
    \end{mathpar}

  \item[Case \(e\<f\):] \XXX
  \item[Case \(\etuple{}\):] \XXX
  \item[Case \(\etuple{e,f}\):] \XXX
  \item[Case \(\pi_i\<e\):] \XXX
  \item[Case \(\inj i e\):] \XXX
  \item[Case \((\ecase{e} (\inj i x \caseto f_i)_i)\):] \XXX
  \item[Case \(\eboxd e\):] \XXX
  \item[Case \((\elet{\eboxd x = e} f)\):] \XXX
  \item[Case \(\bot\):] \XXX
  \item[Case \(e \vee f\):] \XXX
  \item[Case \(\esetd{e_i}_i\):] \XXX
  \item[Case \(\eford x e f\):] \XXX
  \item[Case \(\eeqd e f\):] \XXX
  \item[Case \(\eisEmpty e\):] \XXX
  \item[Case \(\esplit e\):] \XXX
  \item[Case \(\efix e\):] \XXX
  \end{description}
\end{proof}


\thmCorrect*
\begin{proof} \label{proof:correct}
  By induction on $\J e \G A$. But first, it is useful to observe some facts
  about variable denotations. For monotone $x$,
  \[ \den{x}\<\rho = \rho_x
  \quad\text{and}\quad
  \den{\phi x}\<\g = \g_x
  \quad\text{and}\quad
  \den{\delta x}\<\tuple{\g,\dgamma} = \dgamma_\dx
  \]
  while for discrete $\dvar x$,
  \[ \den{\dvar x}\<\rho = \rho_{\dvar x}
  \quad\text{and}\quad
  \den{\phi{\dvar x}}\<\g = \g_{\dvar x}
  \quad\text{and}\quad
  \den{\delta{\dvar x}}\<\tuple{\g,\dgamma} = \gamma_{\dvar \dx}
  \]
  These follow by chasing the definitions in
  \cref{fig:semantics,fig:seminaive-phi,fig:seminaive-delta}. Now for our
  inductive cases:

  \begin{description}
  \item[Case $x$ (monotone):]\
    \begin{enumerate}
    \item \(\den{\phi x}\<\g = \g_x \approx \rho_x = \den{x}\<\rho\).
    \item \(\den{\delta x}\<\tuple{\g,\dgamma} = \dgamma_x\) and
      from $\vld{\dgamma}{\g}{\g'}$ we have \(\longvld{\dgamma_\dx}{\g_x}{\g_x}\).
    \end{enumerate}

  \item[Case \(\dvar x\) (discrete):]\
    \begin{enumerate}
    \item \(\den{\phi{\dvar x}}\<\g = \g_{\dvar x} \approx \rho_{\dvar x} = \den{\dvar x}\<\rho\).
    \item \(\den{\delta{\dvar x}}\<\tuple{\g,\dgamma} = \g_{\dvar\dx}\) and from
      \(\g \approx \rho\) and \cref{def:approx-contexts} we have
      \(\longvld{\g_{\dvar\dx}}{\g_{\dvar x}}{\g_{\dvar x}}\).
    \end{enumerate}

  \item[Case \(\fnof x e\):] \XXX

  \item[Case \(e\<f\):] \XXX

  \item[Case \(\etuple{}\):] \XXX

  \item[Case \(\etuple{e,f}\):] \XXX

  \item[Case \(\pi_i\<e\):] \XXX

  \item[Case \(\inj i e\):] \XXX

  \item[Case \((\ecase{e} (\inj i x \caseto f_i)_i)\):] \XXX

  \item[Case \(\eboxd e : \isof A\):] Note that $\phi\eboxd{e} = \eboxd{\phi e, \delta e}$
    and $\delta\eboxd{e} = \etuple{}$ and $\den{\eboxd e} = \strip \then
    \isof{\den e}$. Applying our semantics, we have

    \nopagebreak[2]
    \begin{align*}
      \den{\phi{\eboxd e}}\<\g
      &= \isof{\fork{\den{\phi e}, \den{\delta e}}} (\strip\<\g)\\
      &= \tuple{\den{\phi e} (\strip\<\g), \den{\delta e} (\strip \<\g)}
      && \text{b/c $\isof f = f$ for morphisms $f$}
      \\
      \den{\eboxd e}\<\rho &= \den e (\strip\<\rho) && \text{similarly}
    \end{align*}

    \begin{enumerate}
    \item Applying \cref{def:approx} we need to show:

      \nopagebreak[2]
      \begin{gather*}
        \den{\phi e} (\strip\<\g) \approx_A \den e (\strip\<\rho)
        \\\text{and}\\
        \longvld{\den{\delta e}(\strip\<\g)}
                {\den{\phi e} (\strip\<\g)}
                {\den{\phi e} (\strip\<\g)}
      \end{gather*}

      Since $\strip\<\g \approx \strip\<\rho$ by \cref{lem:strip-approx} and
      $\vld{\tuple{}}{\strip\<\g}{\strip\<\g}$ by \XXX, these follow follow from
      our IH, \todo{TODO: explain why $\den{\delta e}(\strip\<\g)$ typechecks}.

    \item We wish to show
      \[\vld{\tuple{}}
            {\tuple{\den{\phi e}(\strip\<\g), \den{\delta e}(\strip\<\g)}}
            {\tuple{\den{\phi e}(\strip\<\g'), \den{\delta e}(\strip\<\g')}}
       \]

      At $\incdens{\Phi{\isof A}} = \incden{\isof{(\Phi A \x \DP A)}} =
      \isof{(\incdens{\Phi A} \x \incdens{\DP A})}$, this is true iff both sides
      are equal (\cref{sec:CP-iso}). Thankfully, by \cref{lem:strip-equal}, we
      have $\strip\<\g = \strip\<\g'$, so they are.
    \end{enumerate}

  \item[Case \((\elet{\eboxd {x : A} = e} f)\):] From
    \cref{fig:seminaive-phi,fig:seminaive-delta} we have:
    \begin{align*}
      \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f\\
      \delta(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f
    \end{align*}

    \noindent
    Let \(\sigma_\g = \tuple{ \dvar x \substo \pi_1 \<(\den{\phi e}\<\g),\,
      \dvar \dx \substo \pi_2 \<(\den{\phi e}\<\g)}\). Then from our semantics
    and \cref{lem:letboxtuple} we have
    \begin{align*}
      \den{\elet{\eboxd x = e} f} \<\rho
      &= \den{f} \<\extend{\rho}{\dvar x \substo \den{e}\<\rho}
      \\
      \den{\elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f}\<\g
      &= \den{\phi f} \<\extend{\g}{\sigma_\g}
      \\
      \den{\elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f}\<\extend{\g}{\dgamma}
      &= \den{\delta f} \<\extend{\g,\,\dgamma}{\sigma_{\extend{\g}{\dgamma}}}
    \end{align*}

    \begin{enumerate}
    \item We want to show that
      \(
      \den{\phi f} \<\extend{\g}{\sigma_\g}
      \approx
      \den{f} \<\extend{\rho}{\dvar x \substo \den{e}\<\rho}
      \).
%
      By our IH for $f$, it suffices to show that $\extend{\g}{\sigma_\g}
      \approx \extend{\rho}{\dvar x \substo \den{e}\<\rho}$, and since $\g
      \approx \rho$ we merely need show $\sigma_\g \approx \tuple{\dvar x
        \substo \den{e}\<\rho}$. This follows from $\den{\phi e}\<\g
      \approx_{\isof A} \den{e}\<\rho$, which we get from our IH for $e$.

    \item We wish to show that
      \[
      \longvld
          {\den{\delta f} \<\extend{\g}{\dgamma, \sigma_{\extend\g\dgamma}}}
          {\den{\phi f} \<\extend{\g}{\sigma_\g}}
          {\den{\phi f} \<\extend{\g'}{\sigma_{\g'}}}
      \]

      \todo{TODO: hold on, since $\phi e$ is weakened wherever it appears in
        $\delta e$ we can actually project out $d\gamma$ and just use $\sigma_\g$. hm.}
      \XXX
    \end{enumerate}

  \item[Case \(\bot\):] \XXX

  \item[Case \(e \vee f\):] \XXX

  \item[Case \(\esetd{e_i}_i\):] \XXX

  \item[Case \(\eford x e f\):] \XXX

  \item[Case \(\eeqd e f\):] \XXX

  \item[Case \(\eisEmpty e\):] \XXX

  \item[Case \(\esplit e\):] \XXX

  \item[Case \(\efix e\):] \XXX

  \end{description}
\end{proof}


\begin{lemma}\label{lem:strip-approx}
  If $\gamma \approx_\G \rho$ then $\strip\<\gamma \approx_{\stripcxd\G}
  \strip\<\rho$.
\end{lemma}
\begin{proof}
  \XXX
\end{proof}


\begin{lemma}\label{lem:strip-equal}
  If $\vld{\dgamma}{\g}{\g'} : \incdens\G$ then $\strip\<\g = \strip\<\g'$.
\end{lemma}
\begin{proof}
  From \cref{def:strip}, we have \(\strip\<\g = \tuple{\gamma_{\dvar x}}_{\hd x
    A \in \G}\) and \(\strip\<\g' = \tuple{\gamma'_{\dvar x}}_{\hd x A \in
    \G}\). From our assumption (\todo{TODO: intuition? reference to
    \emph{something}!}) we have $\vld{\tuple{}}{\gamma_{\dvar x}}{\gamma'_{\dvar
      x}} : \isof{\incdens A}$, which means $\gamma_{\dvar x} = \gamma'_{\dvar
    x}$ (see \cref{sec:CP-iso}), so we are done.
\end{proof}


\begin{lemma}\label{lem:letboxtuple}
  \[\den{\elet{\eboxd{\etuple{x,y}} = e} f} \<\g
  = \den{f} \<\extend{\g}{
    \dvar x \substo \pi_1\<(\den{e}\<\g),\,
    \dvar y \substo \pi_2 \<(\den{e}\<\g)}
  \]
\end{lemma}
\begin{proof}
  First, observe that for any $\hd z A \in \G$ and $\g : \den\G$,

  \nopagebreak[2]
  \begin{equation}\label{eqn:piz}
    \den{\eboxd{\pi_i\<\dvar z}}\<\g
  = \pi_i\<(\pi_{\dvar z}\<(\strip\<\g))
  = \pi_i\<\g_{\dvar z}
  \end{equation}

  \noindent So furthermore, for any $\dvar x$ and $e$:

  \nopagebreak[2]
  \begin{align*}
  \den{\elet{\eboxd{\dvar x} = \eboxd{\pi_i\<\dvar z}} e} \<\g
  &= \den{e} \<\extend{\g}{\dvar x \substo \den{\eboxd{\pi_i\<\dvar z}}\<\g}
  && \text{by \cref{fig:semantics}}\\
  &= \den{e} \<\extend{\g}{\dvar x \substo \pi_i\<\g_{\dvar z}}
  && \text{by \cref{eqn:piz}}
  \end{align*}

  \noindent
  Finally:

  \nopagebreak[2]
  \begin{align*}
    &\den{\elet{\eboxd{\etuple{x,y}} = e} f} \<\g\\
    &= \den{\elet{\eboxd{\freshvar z} = e}
      \elet{\eboxd{x} = \eboxd{\pi_1\<\freshvar z}}
      \elet{\eboxd{y} = \eboxd{\pi_2\<\freshvar z}}
      f}\<\g
    && \text{by \cref{fig:desugaring-pattern-matching}}\\
    &= \den{\elet{\eboxd{x} = \eboxd{\pi_1\<\freshvar z}}
      \elet{\eboxd{y} = \eboxd{\pi_2\<\freshvar z}} f}
    \<\extend{\g}{\freshvar z \substo \den{e} \<\g}
    && \text{by \cref{fig:semantics}}
    \\
    &= \den{\elet{\eboxd{y} = \eboxd{\pi_2\<\freshvar z}} f}
    \<\extend{\g}{
      \freshvar z \substo \den{e} \<\g,\,
      \dvar x \substo \pi_1\<(\den{e}\<\g)}
    \\
    &=
    \den{f} \<\extend{\g}{
      \freshvar z \substo \den{e} \<\g,\,
      \dvar x \substo \pi_1\<(\den{e}\<\g),\,
      \dvar y \substo \pi_2\<(\den{e}\<\g)}
    \\
    &=
    \den{f} \<\extend{\g}{
      \dvar x \substo \pi_1\<(\den{e}\<\g),\,
      \dvar y \substo \pi_2\<(\den{e}\<\g)}
    && \text{$\freshvar z$ is fresh}
  \end{align*}

  \noindent
  \todo{TODO: Don't feel entirely comfortable with ``$\freshvar z$ is fresh''
    reasoning. Really it needs the following lemma: if $f_{\Psi}$ is $\J f \G A$
    weakened to $\J f {\G,\Psi} A$, then $\den{f_\Psi}\<\extend{\g}{\psi} =
    \den{f}\<\g$.}
\end{proof}


\end{document}
