\documentclass{rntz}\usepackage[a5]{rntzgeometry}\usepackage[fullwidth=13cm,width=320pt,width=115mm]{narrow}
%\documentclass{rntz}\usepackage[b5]{rntzgeometry}\usepackage[fullwidth=15cm,width=13cm]{narrow}
%\documentclass[12pt]{rntz}\usepackage[a4]{rntzgeometry}\usepackage[fullwidth=19cm,width=37.94em]{narrow}
%\documentclass[nomarginums]{rntz}\usepackage[phone]{fantasy}

\usepackage{latexsym}               % \rightsquigarrow
\usepackage{stmaryrd}               % \shortrightarrow, \llbracket, etc.
\usepackage{amssymb,amsmath,amsthm} % \square etc.
\usepackage{mathtools}              %\dblcolon
%\usepackage{array}                  % >{blah}, <{blah} in array formats.
%\usepackage{booktabs}               % \midrule
\usepackage{mathpartir}             % \begin{mathpar}, \infer, etc.
%% FIXME: get rid of esvect
%\usepackage[f]{esvect}              % \vv for wide vector arrows
\usepackage{nccmath}                % fix align* (etc.) spacing
\usepackage{anyfontsize}

% hang is only relevant for long captions, which I don't have
%\usepackage[labelfont=it,textfont=it,format=hang]{caption}
\usepackage[skip=.5\baselineskip,labelfont=sc,labelsep=period,format=hang]{caption}

\usepackage{enumitem}\setlist{labelindent=1em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=.5em,labelsep=.75em,leftmargin=*}
\setlist{labelindent=0em,labelsep=.75em,leftmargin=*}

%% \usepackage[textosf,mathlf,onlytext]{MinionPro}
%% \makeatletter\edef\zeu@Scale{.965}\makeatletter\usepackage{eulervm}

% scaled=.9091 to match minion, scaled=.92 to match libertine at default scale.
%\usepackage[charter,scaled=.92,linespread=1.13]{rntzfont}
%\PassOptionsToPackage{bb=ams,bbscaled=.943}{mathalfa}\usepackage[baskervald,newmath,scaled=.9215,linespread=1]{rntzfont}
%\usepackage{libertine}\usepackage[libertine,smallerops]{newtxmath}\usepackage[bb=ams,bbscaled=0.94]{mathalfa}

%\usepackage[charter,scaled=.98]{rntzfont} % for phone
%\usepackage[scaled=1.04,linespread=1.12,]{rntzfont} % for b5/a4
%\usepackage[scaled=.96]{rntzfont} % a5
\usepackage[scaled=.92,linespread=1.14,]{rntzfont} % a5

%% \usepackage[default,scale=.93,scale=.98]{lato}
%% \usepackage{eulervm}\makeatletter\edef\zeu@Scale{1.022}\edef\zeu@Scale{1.077}\makeatother
%% \usepackage[italic,basic,defaultmathsizes]{mathastext}
%% \linespread{1.054}

\ifdefined\mathbold\else\newcommand\mathbold{\boldsymbol}\fi
\usepackage[spacing=true]{microtype}\frenchspacing

\newcommand\mathvar[1]{\ensuremath{#1}} % For upright math font.
%\renewcommand\mathvar[1]{\ensuremath{\mathit{#1}}} % For italic math font.

%% Ooh, check out the typeface package:
%% https://ctan.org/pkg/typeface?lang=en
%% https://mirror.hmc.edu/ctan/macros/latex/contrib/typeface/typeface.pdf
%%
%% Hm, it doesn't handle:
%% - scaling the main text font (!)
%% - all newtxmath's options
%% - newpxtext or newpxmath

\hyphenation{eq-uip-ped}
\hyphenation{inv-olv-ing}


%% ===== Commands =====
\newcommand\todo[1]{{\color{ACMRed}#1}}
\newcommand\isocolor{\color{ACMBlue}}
\newcommand\commentcolor{\color{ACMPurple}}
%\renewcommand\isocolor{}

\newcommand\naive{na\"ive}
\newcommand\Naive{Na\"ive}
\newcommand\cat\textbf
\ifdefined\strong\else\newcommand\strong\textbf\fi
\newcommand\CP{\cat{\texorpdfstring{$\boldsymbol\Delta$Poset}{DeltaPoset}}}
\newcommand\Poset{\cat{Poset}}
\newcommand\initO{\ensuremath{\mathbold{0}}}
\newcommand\termO{\ensuremath{\mathbold{1}}}
\newcommand\expO[2]{#1 \Rightarrow #2}
\newcommand\initE{\mathop{\text{\textexclamdown}}}
\newcommand\termI{\mathop{!}}

\ifdefined\G\renewcommand\G\Gamma\else\newcommand\G\Gamma\fi
\newcommand\D\Delta
\newcommand\x\times
\newcommand\pto\rightharpoonup
\newcommand\fn\lambda
\newcommand\dee\delta
\newcommand\tuple[1]{\left({#1}\right)}
\newcommand\triv{\star}
\newcommand\injc{\text{in}}
\newcommand\inj[1]{\injc_{#1}\,}
\newcommand\zero{\ensuremath{\mathbold{0}}}
\newcommand\bnfor{~~|~~}
\newcommand\bnfeq\Coloneqq

% Space for function application. Between \; and \:.
\newcommand\<{\mskip 4mu plus 4mu minus 1mu}
%\renewcommand\<\;
\newcommand\da{\mathvar{da}}
\newcommand\db{\mathvar{db}}
\newcommand\dx{\mathvar{dx}}
\newcommand\dy{\mathvar{dy}}
\newcommand\df{\mathvar{df}}
%\renewcommand\df{d\kern-.1em f\kern-.1em} % fucking kerning.
\newcommand\dg{\mathvar{dg}}

\newcommand\iso{{\texorpdfstring{\ensuremath{\square}}{iso}}}
\newcommand\isof{\iso}
\newcommand\fname\text
\newcommand\id{\fname{id}}
\newcommand\dummy{\fname{dummy}}
\newcommand\extract{{\color{Red}\fname{extract}}}

%% TODO: look at other latex arrows
\newcommand\valfn{\ensuremath{\mathbb{U}}}
%\renewcommand\valfn{\ensuremath{\mathcal{U}}}
\newcommand\vals{\valfn}
\newcommand\chgs[1]{\D{#1}}
\newcommand\deriv[1]{\ensuremath{#1'}}
\newcommand\upd{\mathbin{\oplus}}
\newcommand\updfn{\ensuremath{{\upd}}}

%% \renewcommand\vals[1]{{#1}^v}
%% \renewcommand\valfn{\ensuremath{\vals{-}}}

\newcommand\fork[1]{\langle{#1}\rangle}
\newcommand\krof[1]{[{#1}]}
%\newcommand\Fork[1]{\left\langle{#1}\right\rangle}
%\newcommand\Krof[1]{\left[{#1}\right]}

\newcommand\quantifierspace{~\,}
\newcommand\fa[1]{\forall #1.\quantifierspace}
\newcommand\ex[1]{\exists #1.\quantifierspace}
\newcommand\fnspace{\;}
\newcommand\fnof[1]{\fn{#1}.\fnspace}

\newcommand\kwname\textbf
\newcommand\tset[1]{\{{#1}\}}
\newcommand\tbool{{\boldsymbol 2}}
\newcommand\efor[1]{\kwname{for}\:({#1})\fnspace}
%\renewcommand\efor[1]{\bigvee(#1)\;}
\newcommand\ewhen[1]{\kwname{when}\:({#1})\fnspace}
\newcommand\ecase[1]{\kwname{case} \;{#1}\; \kwname{of}\;}
\newcommand\caseto\shortrightarrow
\newcommand\eset[1]{\{{#1}\}}
\newcommand\etrue{\mathrm{true}}
\newcommand\efalse{\mathrm{false}}
\newcommand\eif[2]{\kwname{if}\;{#1}\;\kwname{then}\;{#2}\;\kwname{else}\;}
\newcommand\ebox[1]{[{#1}]}
\newcommand\elet[1]{\kwname{let}\;#1\;\kwname{in}\;}
\newcommand\efix{\kwname{fix}\<}
\newcommand\eboxd[1]{\ebox{\isocolor #1}}
\newcommand\esetd[1]{\eset{\isocolor #1}}
\newcommand\eford[2]{\efor{{\isocolor #1} \in #2}}
\newcommand\eifd[2]{\eif{\isocolor #1}{#2}}
\newcommand\pwild{\underline{\phantom{a}}}
\newcommand\etuple[1]{\langle#1\rangle}
\newcommand\splitsum{\kwname{split}\<}

\newcommand\subst[2]{{#1}\,\{{#2}\}}
\newcommand\substd[2]{\subst{#1}{\isocolor #2}}
\newcommand\substo\coloneqq


%% Option A
% \leadsto, \rightsquigarrow, \Rightarrow
\newcommand\validarrow\to
\newcommand\valid[1]{\mathrel{\overset{#1}{\validarrow}}}
\newcommand\longvalid[1]{\mathrel{\xrightarrow{#1}}}
\newcommand\vld[3]{{#2 \valid{#1} #3}}
\newcommand\longvld[3]{{#2 \longvalid{#1} #3}}


%% %% Option B
%% \renewcommand\validarrow\leadsto
%% \newcommand\longvalidarrow\validarrow
%% \renewcommand\longvld[3]{{#2 \mathrel{\overset{#1}{\longvalidarrow}} #3}}


%% %% Option C
%% \renewcommand\vld[3]{{#2 \xrsquigarrow{#1} #3}}
%% \renewcommand\longvld[3]{{#2 \xrsquigarrow{#1} #3}}

%% %% Adapted from https://tex.stackexchange.com/questions/233676/leadsto-with-text
%% \usepackage{tikz}
%% \usetikzlibrary{decorations.pathmorphing,shapes}

%% \usepackage{tikz-cd}
%% \usetikzlibrary{decorations.pathmorphing}
%% \newcommand\xrsquigarrow[1]{%
%%     \mathrel{%
%%         \begin{tikzpicture}[%
%%             baseline={(current bounding box.south)}
%%             ]
%%         \node[%
%%             ,inner sep=.44ex
%%             ,align=center
%%             ] (tmp) {$\scriptstyle #1$};
%%         \path[%
%%             ,draw,<-
%%             ,decorate,decoration={%
%%                 ,zigzag
%%                 ,amplitude=0.7pt
%%                 ,segment length=1.2mm,pre length=3.5pt
%%                 }
%%             ]
%%         (tmp.south east) -- (tmp.south west);
%%         \end{tikzpicture}
%%         }
%%     }


\title{Change Semantics for Semi\naive{} Datafun}
\author{\scshape Michael Arntzenius}
\date{5 November 2018}

\begin{document}

\maketitle
\begin{abstract}
  We give two transformations on Datafun programs: \emph{incrementalization} and
  \emph{semi\naive{} evaluation}, generalizing the classic Datalog optimization.

  Our approach is to define a category \CP{} of posets equipped with increasing
  changes, whose morphisms are monotone maps equipped with \emph{derivatives}
  taking input changes to output changes. We give a general categorical
  semantics for Datafun, and construct two instances of it in \CP: an
  \emph{incremental} semantics (extending Datafun's existing semantics in
  \Poset) and a \emph{semi\naive} semantics. From each semantics we read off a
  program transformation. To prove these correct, we construct a type-indexed
  family of natural isomorphisms connecting these semantics.
\end{abstract}

\todo{TODO: rewrite to match above abstract}

%% X-height test: x$x$\emph{x} y$y$\emph{y} v$v$\emph{v} w$w$\emph{w} X$X$\emph{X}


\section{Notation and conventions}

\begin{enumerate}
\item Adjacency $f\<x$ denotes the function $f$ applied to an argument $x$.

  \newcommand\iexpr{\phi}
\item I write $(\iexpr(i))_i$ for the tuple or sequence $(\iexpr(0), \iexpr(1),
  ..., \iexpr(n))$, leaving $n$ unspecified. For example,
  \[ (2^ix + y_i)_i \quad\text{means}\quad
  (2^0x + y_0,~ 2^1x + y_1,~ ...,~ 2^nx + y_n) \]

  \noindent
  I also use this notation with other braces, eg. $\fork{\iexpr(i)}_i =
  \fork{\iexpr(0), ..., \iexpr(n)}$.

\item $\initE_A : \initO \to A$ is the unique map out of an initial object;\\
  $\termI_A : A \to \initO$ is the unique map into a terminal object.

\item Given a family of morphisms $f_i : A \to B_i$ in a category with finite
  products, their \emph{``fork''} $\fork{f_i}_i : A \to \textstyle\prod_{i} B_i$
  uniquely satisfies $\pi_i \circ \fork{f_i}_i = f_i$. Dually, given $f_i : A_i
  \to B$ in a category with finite sums, their \emph{``split''} $\krof{f_i}_i :
  \sum_i A_i \to B$ uniquely satisfies $\krof{f_i}_i \circ \injc_i = f_i$. So in
  particular, $\fork{} = \termI$ and $\krof{} = \initE$.

\item The comonad $\iso : \Poset \to \Poset$ takes a poset to the
  \emph{discrete} poset on the same elements, defined:
  \[\setlength\arraycolsep{.33em}
  \begin{array}{rcl}
    x \in \isof A &\iff& x \in A\\
    x \le y : \isof A &\iff& x = y\\
    \isof(f : A \to B) &=& f : \isof A \to \isof B
  \end{array}\]
\end{enumerate}


\section{The category \CP}

Objects $A$ of \CP{} are tuples $(\vals A, \chgs A, \updfn_A)$, where
%
\begin{enumerate}
\item $\vals A \in \Poset$ is the poset of values.

\item $\chgs A \in \Poset$ is the poset of changes.

\item $\updfn : \vals A \x \chgs A \pto \vals A$ is a partial map taking a value
  and a change to an updated value. If $x \upd \dx$ is defined, we say $\dx$ is a
  \emph{valid} change to $x$.

  $\vld{\dx} x y$ means $x \upd \dx$ is defined and equal to $y$. Otherwise,
  equations inv\-olv\-ing \updfn{} should be understood to hold only when it is
  defined.
\end{enumerate}

\noindent
These must satisfy the following conditions:\footnote{There are other conditions
  one might sensibly impose here, most notably, that $x \upd \dx$ is monotone in
  $\dx$. I have not needed this, but the lack of an obvious ``correct'' set of
  conditions bothers me.}

\begin{align*}
  x \le y &\implies \ex{\dx} \vld{\dx} x y
  & \text{complete for increases}\\
  x \le y &\impliedby \ex{\dx} \vld{\dx} x y
  & \text{sound for increases}
\end{align*}

\noindent
Morphisms $f \in \CP(A,B)$ are differentiable maps $f \in \Poset(\vals A, \vals
B)$. A map is differentiable iff it has a derivative $\deriv f : \vals A \to
\Poset(\chgs A, \chgs B)$ such that:

\[ \vld{\dx} x y \implies \longvld{\deriv f\<x\<\dx}{f\<x}{f\<y}\]

\noindent Or, equivalently:
\[ f\<(x \upd \dx) = f\<x \upd \deriv f\<x\<\dx \]

\noindent
The same morphism may have many different derivatives; all that matters is that
one exist. We will later exhibit an algorithm to find a derivative of a Datafun
term.

Composition of derivatives follows the chain rule:

\begin{align*}
  \deriv\id \<x\<\dx &= \dx
  & \deriv{(f \circ g)} \<x\<\dx &= \deriv f \<(g\<x) \<(\deriv g\<x\<\dx)
\end{align*}


\subsection{Zero changes and change composition}

Applying the axiom of choice to soundness \& completeness for increases, we
recover operators $\zero$, $(\cdot)$ such that $x \upd \zero_x = x$ and $x \upd
(\dx \cdot \dy) = (x \upd \dx) \upd \dy$. These do not necessarily satisfy the
identity and associativity laws of a category, but $\zero$ will be useful
nonetheless. We will see how to duck this non-constructive use of the axiom of
choice in \cref{sec:derivative-transform}.


\subsection{\CP{} refines \Poset{}}
\label{sec:refines}

The forgetful functor $\valfn : \CP \to \Poset$ takes objects $A$ to $\vals{A}$
and morphisms $f$ to themselves. The structures we will build in \CP{}
\emph{refine} those in \Poset{}, in the sense of commuting with $\valfn$. For
example, for cartesian products, $\vals{(A \x B)} = \vals{A} \x \vals{B}$ and
$\vals{\fork{f,g}} = \fork{\vals f, \vals g}$.
%
For brevity, we omit the ``value components'' of our constructions when they can
be derived from this fact, only defining $\chgs{A}$ and $\oplus$ and showing the
existence of derivatives.


\section{Cartesian structure}

\begin{theorem}
  \CP{} has all finite products and sums.
\end{theorem}

\begin{proof}
  The value-level structure is inherited from \Poset{} along \valfn{}. The
  change-poset structure is also inherited from \Poset{}, while the projection
  and injection's derivatives operate pointwise on changes:

  \begin{align*}
    \chgs{\prod_{i \in I} A_i} &= \prod_{i \in I} \chgs A_i &
    \chgs{\sum_{i \in I} A_i} &= \sum_{i \in I} \chgs A_i
    \\
    \deriv\pi_i\<x\<\dx &= \pi_i\<\dx & \deriv\injc_i\<x\<\dx &= \inj i \dx
  \end{align*}

  \noindent Updates are pointwise, noting that $(\inj i x \upd \inj j \dx)$ is
  undefined for $i \ne j$:

  \begin{align*}
    (x_i)_i \upd (\dx_i)_i &= (x_i \upd \dx_i)_i &
    \inj i x \upd \inj i \dx &= \inj i (x \upd \dx)
  \end{align*}

  \noindent
  Soundness \& completeness for increases follow directly from the pointwise
  orderings of products \& coproducts in \Poset{}.

  Fork's derivative $\deriv{\fork{f_i}_i}$ is $\fork{\deriv f_i}_i$:

  \begin{gather*}
    \fork{f_i}_i \<(x \upd \dx)
    = (f_i(x \upd \dx))_i
    = (f_i\<x \upd \deriv f_i \<x \<\dx)_i
    = \fork{f_i}_i \<x \upd \fork{\deriv f_i}_i \<x \<\dx
  \end{gather*}

  \noindent
  A derivative for split must obey \[ \krof{f_i}_i\<(\inj i x \upd \inj i \dx)
  = f_i\<x \upd \deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj i \dx) \] so one
  valid choice is

  \[\deriv{\krof{f_i}_i} \<(\inj i x) \<(\inj j \dx)
  =
  \begin{cases}
    \deriv f_i \<x \<\dx & \text{if}~i = j\\
    \deriv f_i \<x \<\zero_x & \text{otherwise}
  \end{cases}
  \]

  \noindent
  The second case is dead code; any value of the right type would do. We will
  exploit this later to avoid needing the axiom of choice (used to define
  $\zero_x$) in the context of Datafun.
\end{proof}


\section{Exponential objects}

The change poset of the exponential object $\expO A B \in \CP$ consists of maps
$\vals A \to \Poset(\chgs A, \chgs B)$, ordered pointwise. The update relation
is:

\begin{equation}\label{eqn:function-update}
  f \valid\df g : \expO A B
  \iff \fa{x \valid\dx y} f\<x \longvalid{\df\<x\<\dx} g\<y
\end{equation}

\noindent Informally, this says a function change $\df$ is valid so long as it
takes valid input changes to valid output changes: if $\dx$ is a change to $x$,
then $\df\<x\<\dx$ must be a change to $f\<x$.

To show this defines a unique partial function \updfn, suppose $\vld\df f g$ and
$\vld\df f h$ and consider any $x : A$. \Cref{eqn:function-update} applied to
$\vld{\zero_x} x x$ gives us $\longvld{\df\<x\<\zero_x}{f\<x}{g\<x}$ and
$\longvld{\df\<x\<\zero_x}{f\<x}{h\<x}$. Then we know \(f\<x \upd
\df\<x\<\zero_x = g\<x = h\<x \), proving $g = h$. And so, whenever $f \upd \df$
is defined, we have
%
\[ (f \upd \df)\<x = f\<x \upd \df\<x\<\zero_x \]
%
and more generally, \cref{eqn:function-update} can be rewritten:
%
\begin{equation*}
  f\<x \upd \df\<x\<\dx = (f \upd \df)\<(x \upd \dx)
\end{equation*}

\noindent
Soundness \& completeness for increases at $\expO A B$ follows from soundness \&
completeness at $A$ and $B$ and the axiom of choice. % TODO?: Elaborate?

The derivative of the evaluation map is given by

\[\begin{array}{l}
  \deriv{\fname{eval}} \,:\,
  %(\expO{\vals A}{\vals B})
  \Poset(\vals A, \vals B)
  \x \vals A \to
  \Poset({\chgs{(\expO A B)} \x \chgs A},{\chgs B})
  \\
  \deriv{\fname{eval}} \<(f,a) \<(\df,\da) = \df\<a\<\da
\end{array}\]

\noindent
And for $f : \CP(\G \x A, B)$, the derivative of the curried $\fn f : \CP(\G,
\expO A B)$ is given by currying the derivative:

\[
\begin{array}{l}
  \deriv{(\fn f)} \,:\, \vals\G \to \expO{\chgs \G}{\chgs{(\expO A B)}}\\
  \deriv{(\fn f)} \<\gamma \<\mathvar{d\gamma} \<a \<\da
  = \deriv f \<(\gamma,a) \<(\mathvar{d\gamma}, \da)
\end{array}
\]

\noindent
Correctness of $\deriv{\fname{eval}}$ follows from the validity of \df\ and \da;
correctness of $\deriv{(\fn f)}$ follows from correctness of \deriv{f}.

%% Exponential is:
%% eval : (A => B) x A -> B
%%
%% Given f : Γ x A -> B
%% Exists λf : Γ -> (A => B)
%% such that f = (λf × id); eval

% WTS: f ≤ g ⇔ ∃df. f -df-> g

% Suppose f ≤ g.
% WTS: ∃df. f --df--> g.
% Let's calculate! df has to be such that
% ∀(x -dx-> y) f x --df x dx--> g y
% Suppose (x -dx-> y)
%
% Suppose f -df-> g.
% Consider x : A. WTS: f x <= g y. Know x --0x--> x.
% Thus f x --df x 0x--> g x. So by soundness f x <= g x.

%% \begin{align*}
%%   f \le g : \vals{(\expO A B)}
%%   &\iff f \le g : \expO{\vals A}{\vals B}\\
%%   &\iff \fa{x \le y} f\<x \le g\<y\\
%%   &\iff \fa{x,y} (\ex{\dx} \vld{\dx} x y)
%%   \implies \ex{\dx} \vld{\dx}{f\<x}{g\<y}\\
%%   &\iff \todo{???}\\
%%   &\iff \ex{\df} \vld{\df} f g
%% \end{align*}


\section{The lifted \iso{} comonad}

\newcommand\setfor[2]{\ensuremath{\{#1 \mathrel{|} #2\}}}

Now we construct a comonad $\iso$ on \CP\ such that $\valfn\iso_\CP =
\iso_\Poset\valfn$. This requirement defines the value-level structure, leaving
only the change poset and update map:

\begin{align*}
  \chgs{\isof A} &= \isof{\chgs A}
  &
  x \oplus_{\isof A} \dx = y &\iff x = y \wedge x \oplus_A \dx = y
\end{align*}

\noindent
So changes are ordered discretely, and \emph{only zero-changes are valid}. This
maintains soundness \& completeness for increases, since $x \le y : \isof A \iff
x = y$.

Functoriality is straightforward to verify:

\begin{align*}
  \iso_\CP(f) = \iso_\Poset(f) = f
  && \deriv{\iso_\CP(f)} = \deriv{\iso_\Poset(f)} = \deriv f
\end{align*}

\noindent
To show $\iso$ is a comonad, it's easy to see that ${\iso} = {\iso\iso}$, so the
duplication natural transformation $\delta : {\iso} \to {\iso\iso}$ is the
identity; the extraction natural transformation $\varepsilon : {\iso} \to
\mathbold{1}$ is given by the subposet inclusion from $\isof A$ to $A$, with
$\deriv{\varepsilon_A} \<x \<\dx = \dx$.

Finally, $\iso_\CP$, like $\iso_\Poset$, distributes over products \& sums. This
follows from the definitions of $\chgs{\iso A}$ and $\updfn_{\iso A}$ and of
products and sums in $\CP$.


\section{Semilattice objects}

\todo{What do we need from semilattice objects? We need
  \begin{enumerate}
  \item That $\vals A$ is a semilattice, to interpret $\bot$ and $M \vee N$.
  \item That $\chgs A$ is a semilattice, and that $\delta\bot = \bot$ and
    $\delta(M \vee N) = \delta M \vee \delta N$ and ditto for $\delta(\bigvee(x
    \in M)~N)$.
  \end{enumerate}
}


\section{Fixed points}

\todo{What do we need from fixed point types? We need
  \begin{enumerate}
  \item $\vals A$ has a least element and satisfies ACC.
  \item Our proof for $\delta(\mathop{\text{fix}} f)$ requires that $\chgs A =
    \vals A$ and $\updfn = {\vee}$ and $x \valid{\bot} x$.
  \end{enumerate}
}


\section{``Reading off'' the derivative transformation}
\label{sec:derivative-transform}

\todo{TODO: explain how we avoid non-constructive use of $\zero$ via
  $\fname{dummy} : A \to \chgs A$.}

%% TODO: variadic tuples & sums?
\begin{figure*}
  \[\setlength\arraycolsep{.33em}\begin{array}{l@{\hskip 1em}lcl}
    \text{types} & A,B &\bnfeq& \tbool \bnfor \tset{A} \bnfor
    \iso A
    \bnfor A \to B \bnfor A \x B \bnfor A + B
    \\[.5em]
    \text{terms} & e,f,g &\bnfeq& x \bnfor \fnof{x} e \bnfor e\<f
    \bnfor \etuple{e,f} \bnfor \pi_i\<e\\
    &&&\inj i e \bnfor \ecase{e} (\inj i x \caseto f_i)_{i\in\{1,2\}}\\
    &&&\etrue \bnfor \efalse \bnfor \eifd e f g\\
    &&&\bot \bnfor e \vee f \bnfor \esetd{e_i}_i \bnfor \eford{x}{e} f
    \bnfor \ewhen e f\\
    &&& \eboxd e \bnfor \elet{\eboxd x = e} f \bnfor \splitsum e
  \end{array}\]
  \caption{Syntax of Datafun}
  \label{fig:syntax}
\end{figure*}

\newcommand\expandsto{\rightsquigarrow}
\begin{figure*}
  %% TODO: pattern-matching on box types.
  \[\setlength\arraycolsep{.15em}\begin{array}{rcl}
    \ecase{e,\vec f} (p_i, \vec q_{i,j} \caseto g_{i,j})_{i,j}
    &\expandsto& \ecase{e} (p_i \caseto \ecase{\vec f} (\vec q_{i,j} \caseto g_{i,j})_j)_i
    \\[.33em]
    \ecase{e} x \caseto f;\ (p_i \caseto g_i)_i
    &\expandsto& \elet{x = e} f
    \\[.33em]
    \ecase{e} \eboxd x \caseto f;\ (p_i \caseto g_i)_i
    &\expandsto& \elet{\eboxd x = e} f
    \\[.33em]
    \ecase{e} (\etuple{p_i,q_i} \caseto f_i)_i
    &\expandsto& \elet{x = e}\\
    && \ecase{\pi_1\< x,\, \pi_2\< x} (p_i,q_i \caseto f_i)_i
    \\[.33em]
    \ecase{e} (\eboxd{\etuple{p_i,q_i}} \caseto f_i)_i
    &\expandsto& \elet{\eboxd x = e}\\
    && \ecase{\eboxd{\pi_1\<x}, \eboxd{\pi_2\<x}}
    (\eboxd{p_i}, \eboxd{q_i} \caseto f_i)
    \\[.33em]
    \ecase{e} (\inj i p_{i,j} \caseto f_{i,j})_{i,j}
    &\expandsto& \ecase{e} (\inj i x \caseto \ecase{x} (p_{i,j} \caseto f_{i,j})_j)_i
    \\[.33em]
    \ecase{e} (\eboxd{\inj i p_i} \caseto f_i)_i
    &\expandsto& \ecase{\splitsum e} (\inj i \eboxd{p_i} \caseto f_i)_i
  \end{array}\]
  \caption{Some pattern-matching elaboration rules}
\end{figure*}

\renewcommand\extract{\error{don't use extract}}
\begin{figure*}
  \begin{mathpar}
    \setlength\arraycolsep{.3em}\begin{array}{lcl}
      \dummy &:& A \to \D A\\
      \dummy \<(\pwild : \tbool) &=& \efalse\\
      \dummy \<(\pwild : \tset{A}) &=& \eset{}\\
      \dummy \<\eboxd{x} &=& \eboxd{\dummy\<x}\\
      \dummy \<(f : A \to B) &=& \fnof{x} \dummy\<(f\<x)\\
      \dummy \<\etuple{x,y} &=& \etuple{\dummy\<x, \dummy\<y}\\
      %% \dummy \<\etuple{x_i}_i &=& \etuple{\dummy\<x_i}_i\\
      \dummy \<(\inj i x) &=& \inj i (\dummy\<x)
    \end{array}
    %%
    %% \begin{array}{l}
    %%   \extract_i ~:~ A_i \to \D A_1 + \D A_2 \to \D A_i\\
    %%   \extract_i\<x\<\dx = \ecase{\dx} \inj i \dx \caseto \dx;\;%\\
    %%   %\phantom{\extract_i\<x\<\dx = \ecase{\dx}}
    %%   \pwild \caseto \dummy\<x
    %%   %\quad\ {\color{ACMPurple} \longleftarrow \textit{Dead code.}}
    %% \end{array}
  \end{mathpar}
  \caption{The \dummy\ function}
  \label{fig:dummy}
\end{figure*}

\begin{figure*}
  \begin{align*}
    \delta x &= \dx\\
    \delta (\fnof{x} e) &= \fnof{\eboxd x}\fnof\dx \delta e &
    \delta (e\<f) &= \delta e \<\eboxd f \<\delta f\\
    \delta \etuple{e,f} &= \etuple{\delta e, \delta f} &
    \delta (\pi_i\<e) &= \pi_i\< \delta e\\
    \delta (\inj i e) &= \inj i {\delta e}\\
    \delta \bot &= \bot &
    \delta (e \vee f) &= \delta e \vee \delta f\\
    \delta \etrue = \delta \efalse &= \efalse
    & \delta\esetd{e_i}_i &= \eset{}\\
    \delta \eboxd{e} &= \eboxd{\delta e}
    & \delta(\splitsum e) &= \splitsum \delta e
  \end{align*}

  \begin{align*}
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd x = e \mathrel{\kwname{and}} \eboxd\dx = \delta e} \delta f
    \\
    \delta (\efix e) &= \efix (\delta e \<\eboxd{\efix e}) \\
    \delta (\eifd e f g) &= \eifd{e}{\delta f}{\delta g}\\
    \delta (\ewhen e f) &= \eifd e {\delta f} \ewhen{\delta e} f \vee \delta f\\
    \delta (\eford x e f)
    &= (\eford x {\delta e} f)\\
    &\vee (\eford x{e \vee \delta e} \substd{\delta f}{\dx \substo \zero\< x})\\
    \delta (\ecase e (\inj i x \caseto f_i)_i)
    %% &= \ecase{\splitsum{\eboxd e}}\\
    %% &\qquad(\inj i \eboxd{x} \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i
    &= \ecase{\splitsum{\eboxd e},\, \delta e}\\
    &\qquad ({\inj i \eboxd x,\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad \textit{\commentcolor --- The following cases are unreachable.}\\
    &\qquad ({\inj i \eboxd x,\, \pwild} \caseto
    %\elet{\dx = \dummy\<x}
    \subst{\delta f_i}{\dx \coloneqq \dummy\<x})_i
  \end{align*}
  \caption{The derivative translation}
  \label{fig:derivatives}
\end{figure*}


\section{Semi\naive{} evaluation}

\todo{TODO: Explain the use of weakening in semi\naive{} $\delta(e\<f)$,
  hilighted in {\color{Rhodamine}pink}.}

\begin{figure*}
  \begin{align*}
    \Phi \tbool &= \tbool & \D\tbool &= \tbool\\
    \Phi \tset{A} &= \tset{\Phi A} & \D\tset{A} &= \tset{\Phi A}\\
    \Phi \isof A &= \isof{(\Phi A \x \D A)}
    & \D\isof A &= \isof \D A\\
    \Phi(A \to B) &= \Phi A \to \Phi B
    & \D(A \to B) &= \isof \Phi A \to \D A \to \D B\\
    \Phi(A \x B) &= \Phi A \x \Phi B & \D(A \x B) &= \D A \x \D B\\
    \Phi(A + B) &= \Phi A + \Phi B & \D(A + B) &= \D A + \D B
  \end{align*}
  \caption{Semi\naive{} type translation}
\end{figure*}

\begin{figure*}
  \begin{align*}
    \phi x &= x & \delta x &= \dx\\
    \phi(\fnof x e) &= \fnof x \phi e
    & \delta(\fnof{x} e) &= \fnof{\eboxd x} \fnof\dx \delta e\\
    \phi(e\<f) &= \phi e\<\phi f
    & \delta(e\<f) &= \delta e \<\eboxd{\color{Rhodamine}\phi e} \<\delta f\\
    \phi\etuple{e,f} &= \etuple{\phi e, \phi f}
    & \delta\etuple{e,f} &= \etuple{\delta e, \delta f}\\
    \phi(\pi_i\<e) &= \pi_i\<\phi e
    & \delta(\pi_i\<e) &= \pi_i\<\delta e\\
    \phi(\inj i e) &= \inj i \phi e
    & \delta(\inj i e) &= \inj i \delta e\\
    \phi\etrue &= \etrue & \delta\etrue &= \efalse\\
    \phi\efalse &= \efalse & \delta\efalse &= \efalse\\
    \phi\bot &= \bot & \delta\bot &= \bot\\
    \phi(e \vee f) &= \phi e \vee \phi f
    & \delta(e \vee f) &= \delta e \vee \delta f\\
    \phi\esetd{e_i}_i &= \esetd{\phi e_i}_i & \delta\esetd{e_i}_i &= \esetd{}\\
    \phi\eboxd{e} &= \eboxd{\etuple{\phi e, \delta e}}
    & \delta\eboxd{e} &= \eboxd{\delta e}
  \end{align*}

  %% TODO: determine exactly how much syntax sugar I want to allow in the target
  %% of this translation. for example, the case-split I use in \phi(\splitsum e)
  %% is only valid *because* \splitsum exists.
  %%
  %% Would be nice to give the syntax sugar explicitly, but maybe more effor
  %% than its worth? Might be clearer to mostly avoid syntax sugar? Not sure.

  %% TODO FIXME: \phi(\fix e), \delta(\fix e)!
  %% TODO FIXME: \phi(if then else), \delta(if then else)!

  \begin{align*}
    \phi(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\phi e} (\inj i x \caseto \phi f_i)_i
    \\
    \delta(\ecase e (\inj i x \caseto f_i)_i)
    &= \ecase{\splitsum{\eboxd{\phi e}},\, \delta e}\\
    &\qquad ({\inj i {\eboxd x},\, \inj i \dx} \caseto \delta f_i)_i\\
    &\qquad ({\inj i {\eboxd x},\, \pwild}
      \caseto \subst{\delta f_i}{\dx \substo \dummy\<x})_i
    %% &= \ecase{\splitsum{\eboxd{\phi e}}}\\
    %% &\qquad (\inj i \eboxd x
    %% \caseto \subst{\delta f_i}{\dx \substo \extract_i\<x\<\delta e})_i\\
    %% \phi(\eif e f g) &= \eif{\phi e}{\phi f}{\phi g}\\
    %% \delta(\eif e f g) &= \eif{\phi e}{\delta f}{\delta g}
    \\
    \phi(\eford x e f)
    &= \eford{x}{\phi e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
    \substd{\phi f}{\dx \substo \zero\<x}
    \\
    \delta(\eford x e f)
    &= (\eford x{\delta e} \substd{\phi f}{\dx \substo \zero\<x}) \\
    &\vee (\eford x{e \vee \delta e} %\elet{\eboxd\dx = \eboxd{\zero\<x}}
    \substd{\delta f}{\dx \substo \zero\<x})
    \\
    \phi(\ewhen e f) &= \ewhen{\phi e} \phi f
    \\
    \delta(\ewhen e f)
    &= \eifd{\phi e}{\delta f} \ewhen{\delta e} \phi f \vee \delta f
    \\
    \phi(\elet{\eboxd x = e} f) &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \phi f
    \\
    \delta(\elet{\eboxd x = e} f)
    &= \elet{\eboxd{\etuple{x,\dx}} = \phi e} \delta f
    \\
    \phi(\splitsum e) &=
    %% \elet{\eboxd{\etuple{y,\dy}} = \phi e}\\
    %% &\phantom{{}={}} \ecase{\splitsum{\eboxd y}}\\
    %% &\qquad (\inj i \eboxd x \caseto
    %% \substd{\phi f_i}{\dx \substo \extract_i\<y\<\dy})_i
    %%
    %% \elet{\eboxd{\etuple{x,\dx}} = \phi e}\\
    %% &\phantom{{}={}}\ecase{\splitsum {\eboxd x}, \splitsum {\eboxd\dx}}\\
    %% &\qquad (\inj i \eboxd x, \inj i \eboxd\dx
    %% \caseto \inj i \eboxd{\etuple{x,\dx}})_i\\
    %% &\qquad (\inj i \eboxd x, \pwild
    %% \caseto \inj i \eboxd{\etuple{x,\dummy\<x}})_i
    %%
    \elet{\eboxd{x} = \phi e}\\
    &\phantom{{}={}} \splitsum [\isocolor \ecase x\\
    &\phantom{= \splitsum}\quad\isocolor
      (\etuple{\inj i y, \inj i \dy} \caseto \inj i \etuple{y,\dy})_i\\
    &\phantom{= \splitsum}\quad
      {\isocolor(\etuple{\inj i y, \pwild}
        \caseto \inj i \etuple{y, \dummy\<y})_i}]
    %%
    %% \ecase{\phi e}\\
    %% &\qquad (\eboxd{\etuple{\inj i x, \inj i \dx}}
    %% \caseto \inj i \eboxd{x,\dx})_i\\
    %% &\qquad (\eboxd{\etuple{\inj i x, \pwild}}
    %% \caseto \inj i \eboxd{x, \dummy\<x})_{i}
    \\
    \delta(\splitsum e) &= \splitsum \delta e
  \end{align*}
  \caption{Semi\naive{} term translation}
\end{figure*}

\end{document}
