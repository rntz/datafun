% ========== Notation for semantics.tex ==========
\newcommand\todo[1]{{\color{ACMRed}#1}}
\newcommand\XXX{\todo{\text{XXX}}}
\newcommand\naive{na\"ive}
\newcommand\Naive{Na\"ive}
\newcommand\figsectionname\textsc

% Red is too attention-grabbing. Blue can be confused with links (also blue),
% and doesn't stand out well. Green works well, but make sure it's dark enough
% to be legible but light enough to be clearly non-black.
\definecolor{IsoGreen}{cmyk}{1, 0, 1, 0.12} % or ForestGreen
\definecolor{IsoBlue}{cmyk}{1, 0, 0, 0.16}
\newcommand\isocolor{\color{ForestGreen}}

\let\oldboldmath\boldmath
\renewcommand\boldmath{\texorpdfstring{\oldboldmath}{}}


%% ===== General math & PL notation =====
\ifdefined\G\renewcommand\G\Gamma\else\newcommand\G\Gamma\fi
\newcommand\g\gamma
\newcommand\emptycx{\varepsilon}
\newcommand\D\Delta
\newcommand\DP{\D\Phi}
\newcommand\x\times
\newcommand\pto\rightharpoonup
\newcommand\fn{\texorpdfstring{\ensuremath{\lambda}}{lambda}}
\newcommand\injc{\mathrm{in}}
\newcommand\prj[1]{\pi_{#1}\<}
\newcommand\inj[1]{\injc_{#1}\<}
\newcommand\bnfor{\mathrel{~|~}}
\newcommand\bnfeq\Coloneqq
\newcommand\N{\mathbb{N}}
\newcommand\tuple[1]{\langle{#1}\rangle}
\newcommand\den[1]{\ensuremath{\llbracket{#1}\rrbracket}}
\newcommand\bigden[1]{\ensuremath{\bigl\llbracket{#1}\bigr\rrbracket}}
% Space for function application. Between \; and \:.
% TODO: maybe just replace this by \;?
\newcommand\<{\mskip 4mu plus 4mu minus 1mu}
%\renewcommand\<\;
\newcommand\fnspace{\;}
\newcommand\fnof[1]{\fn{#1}.\fnspace}
%\newcommand\setfor[2]{\ensuremath{\{#1 \mathrel{|} #2\}}}

\newcommand\quantcolor\relax
%\renewcommand\quantcolor{\color{green}}
\newcommand\quantifierspace{\ }
%\renewcommand\quantifierspace{\ \,}
\newcommand\quantify[1]{({\quantcolor #1})\quantifierspace}
\newcommand\fa[1]{\quantify{\forall #1}}
\newcommand\ex[1]{\quantify{\exists #1}}
\newcommand\faex[2]{\quantify{\forall #1, \exists #2}}

%% \renewcommand\fa[1]{\forall({\quantcolor #1})\quantifierspace}
%% \renewcommand\ex[1]{\exists({\quantcolor #1})\quantifierspace}

%% various marked equalities.
\newcommand\stareq{\overset{\boldsymbol\star}{=}}
\newcommand\daggereq{\overset{\dagger}{=}}
\newcommand\stardaggereq{\overset{\boldsymbol\star\dagger}{=}}

\newcommand\subst[2]{{#1}\,\{{#2}\}}
\newcommand\substd[2]{\subst{#1}{\isocolor #2}}
\newcommand\substo\mapsto
%% TODO: get rid of \extend.
%% for extending a substitution
\newcommand\extend[2]{\tuple{#1,\, #2}}


%% ===== Derivative variables! =====
\newcommand\da{\mathvar{da}}
\newcommand\db{\mathvar{db}}
\newcommand\dx{\mathvar{dx}}
\newcommand\dy{\mathvar{dy}}
\newcommand\df{\mathvar{df}}
%\renewcommand\df{d\kern-.1em f\kern-.1em} % fucking kerning.
\newcommand\dg{\mathvar{dg}}
\newcommand\ds{\mathvar{ds}}
\newcommand\dgamma{d\gamma}


%% ===== Categorical notation =====
\newcommand\cat\textbf
\ifdefined\textsb\renewcommand\cat\textsb\else\fi
\providecommand\strong\textbf
\newcommand\BD{{\texorpdfstring{\ensuremath{\boldsymbol\Delta}}{Delta}}}
\newcommand\CP{\cat{\BD{}Poset}}
\newcommand\Poset{\cat{Poset}}
\newcommand\initO{0}
\newcommand\termO{1}
\newcommand\expO[2]{#1 \Rightarrow #2}
\newcommand\then\cdot
%\renewcommand\then{\mathbin{;}}
%\renewcommand\then{\,{;}\,}
\newcommand\catC{\ensuremath{\mathcal{C}}}
\newcommand\morph\textit
\newcommand\id{\morph{id}}
\newcommand\idfunctor{\morph{Id}} % not used yet

\newcommand\fork[1]{\langle{#1}\rangle}
\newcommand\krof[1]{[{#1}]}
\newcommand\bigkrof[1]{\bigl[{#1}\bigr]}
%\newcommand\Fork[1]{\left\langle{#1}\right\rangle}
%\newcommand\Krof[1]{\left[{#1}\right]}
\newcommand\initE{\krof{\kern .08em}}
\newcommand\termI{\fork{}}
\newcommand\eval{\morph{eval}}


%% ===== Datafun model notation =====
%\newcommand\disco{\ensuremath{W}}
\newcommand\disco{\iso}
\newcommand\discof[1]{\ensuremath{\disco #1}}
\newcommand\discox{\ensuremath{\morph{dist}^\x_\disco}}
\newcommand\discosum{\ensuremath{\morph{dist}^\disco_+}}

\newcommand\pfin{\ensuremath{P}}
%\renewcommand\pfin{\texorpdfstring{\ensuremath{\mathcal{P}}}{P}}
\newcommand\pfinof[1]{\pfin #1}
\newcommand\pcollect[1]{\morph{collect}(#1)}

\newcommand\boxd[1]{\morph{box}({\isocolor #1})}


%% ===== Datafun syntax =====
\newcommand\kw\textbf
%\newcommand\prim[1]{\textmd{\itshape #1}}
\newcommand\prim[1]{\text{\itshape #1}}
\newcommand\caseto\shortrightarrow
\newcommand\pwild{\underline{\phantom{a}}}
\newcommand\desugars{~\rightsquigarrow~}
%\renewcommand\desugars{~\overset{\text{def}}{=}~}
%\renewcommand\desugars{~\coloneqq~}
%\renewcommand\desugars{\,\xrsquigarrow{\text{expand}}\,}

\newcommand\undertype[2]{\underaccent{\textsf{\upshape #1}}{#2}}
\newcommand\eqt[1]{\undertype{eq}{#1}}
\providecommand\fint{}
\renewcommand\fint[1]{\undertype{fin}{#1}}
\newcommand\fixt[1]{\undertype{fix}{#1}}

\newcommand\tset[1]{\{{#1}\}}
\newcommand\tbool{2}
\newcommand\tunit{1}
%\newcommand\tdown[1]{\color{red}\downof{#1}}
\newcommand\tseteq[1]{\tset{\eqt{#1}}}

\newcommand\ebox[1]{[{#1}]}
\newcommand\elet[1]{\kw{let}\;{#1}\;\kw{in}\;}
\newcommand\etuple[1]{\langle{#1}\rangle}
\newcommand\Etuple[1]{\left\langle{#1}\right\rangle}
\newcommand\ecase[1]{\kw{case} \;{#1}\; \kw{of}\;}
\newcommand\eset[1]{\{{#1}\}}
\newcommand\efor[1]{\kw{for}\:({#1})\fnspace}
\newcommand\eeq[2]{{#1} = {#2}}
%% surface syntax
\newcommand\ewhen[1]{\kw{when}\:({#1})\fnspace}
\newcommand\edcase[1]{\kw{case}^\iso \;{\isocolor #1}\; \kw{of}\;}
\newcommand\etrue{\prim{true}}\newcommand\efalse{\prim{false}}
\newcommand\eif[2]{\kw{if}\;{#1}\;\kw{then}\;{#2}\;\kw{else}\;}
\newcommand\efixis[1]{\kw{fix}\;#1\;\kw{is}\;}
%% desugared syntax
\newcommand\efix{\prim{fix}\<}
\newcommand\esplit{\prim{split}\<}
%\newcommand\esplitd[1]{\esplit{\isocolor #1}}
\newcommand\eisempty[1]{\prim{empty?}\<{\isocolor #1}}
%% TODO: remove \edown, \ebigvee
\newcommand\edown{\color{red}\mathop{\downarrow}}
\newcommand\ebigvee[2]{\color{red}\mathop{\textstyle\bigvee}({#1} \in {#2})\fnspace}

\newcommand\esetd[1]{\eset{\isocolor #1}}
\newcommand\eboxd[1]{\ebox{\isocolor #1}}
\newcommand\eford[2]{\efor{{\isocolor #1} \in #2}}
\newcommand\eifd[2]{\eif{\isocolor #1}{#2}}
\newcommand\efixisd[2]{\efixis{#1}{\isocolor #2}}
\newcommand\eeqd[2]{\eeq{\isocolor #1}{\isocolor #2}}

\newcommand\fastfix{\prim{semifix}}

%\newcommand\J[3]{{#1} \mathrel{\,:\,} {#2} \vdash {#3}}
\newcommand\J[3]{{#2} \vdash {#1} \mathrel{:} {#3}}
\newcommand\Jalign[3]{{#2} &\vdash {#1} \mathrel{:} {#3}}
\newcommand\h[2]{{#1} : {#2}}
\newcommand\dvar[1]{{\isocolor #1}}
\newcommand\freshvar[1]{{\color{Rhodamine}#1}}
\newcommand\hd[2]{\dvar{#1} \dblcolon {#2}}

\newcommand\stripcx[1]{\lceil{#1}\rceil}
\newcommand\stripcxd[1]{{\isocolor\stripcx{\isocolor #1}}}


%% ===== Poset, ChangePoset, derivative & seminaive notation =====
%% TODO: replace \fname with \morph or vice-versa?
\newcommand\fname\morph
\newcommand\dummy{\fname{dummy}}

\newcommand\iso{{\texorpdfstring{\ensuremath{\square}}{box}}}
\newcommand\blackiso{{\texorpdfstring{\ensuremath{\blacksquare}}{black box}}}
\newcommand\altiso{\texorpdfstring{\ensuremath{\iso_{\textrm{alt}}}}{altiso}}

\newcommand\zero{\texorpdfstring{\ensuremath{\mathbold{0}}}{0}}
\newcommand\valfn{\texorpdfstring{\ensuremath{V}}{V}}
\newcommand\vals{\valfn}
\newcommand\chgfn{\ensuremath{\D}}
\newcommand\chgs\chgfn
\newcommand\deriv[1]{\ensuremath{#1'}}

\newcommand\tangfn{\texorpdfstring{\ensuremath{T}}{T}}
\newcommand\tang{\tangfn}

%% Validity/update relation arrows
\newcommand\validto\to
\newcommand\longvalidto[1]{\mathrel{\xrightarrow{#1}}}
\newcommand\validcolon:
\newcommand\vld[3]{{#2 \longvalidto{#1} #3}}
\newcommand\vldat[4]{{#3 \longvalidto{#2} #3} : {#1}}
\newcommand\valid[3]{{#1 \validcolon #2 \validto #3}}
\newcommand\validat[4]{\valid{#2}{#3}{#4} : {#1}}

%\renewcommand\validcolon\dblcolon
%\renewcommand\validto\shortrightarrow
\renewcommand\validat[4]{{#2 \validcolon_{#1} #3 \validto #4}}
%\renewcommand\vld\valid
%\renewcommand\vldat\validat


%% ===== Logical relations =====
\newcommand\agrees\approx

\newcommand\impls{\mathrel{\lightning}}

\newcommand\changesto\shortrightarrow
\newcommand\changescolon{:}
\newcommand\changes[3]{{#1} \changescolon #2 \changesto #3}
\newcommand\changesat[4]{{#2} \changescolon_{#1} {#3} \changesto {#4}}

%\renewcommand\impls{\mathop{\lightning}}
\newcommand\weird[5]{{#1} \changescolon #2 \impls #3 \changesto #4 \impls #5}
\newcommand\weirdat[6]{{#2} \changescolon_{#1} #3 \impls #4 \changesto #5 \impls #6}

\renewcommand\changescolon\dblcolon
%\renewcommand\changesat[4]{\changes{#2}{#3}{#4} : {#1}}
\renewcommand\weirdat[6]{\weird{#2}{#3}{#4}{#5}{#6} : #1}

%\renewcommand\changesto\leadsto
%\renewcommand\changesto\to


