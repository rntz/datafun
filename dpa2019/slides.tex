\documentclass[dvipsnames,fleqn]{beamer}

\usefonttheme{professionalfonts} % using non-standard fonts
\usefonttheme{serif} % Make serif default.

%\PassOptionsToPackage{scaled=1.04}{rntzfont}

\usepackage[charter,source,]{rntzfont}
%\usepackage[charter,newmath,]{rntzfont}

\providecommand\EMPH\textsc

\usepackage{booktabs}
\usepackage{stmaryrd}
\usepackage{nccmath} % \begin{ceqn}
\usepackage{anyfontsize} % suppress warnings about stmaryrd sizes

\setlength{\mathindent}{1em}

% Give \cup more spacing
\let\oldcup\cup
\renewcommand\cup{\mathrel{\oldcup}}


\newcommand\kw\textbf
%\renewcommand\gets\shortleftarrow
%\renewcommand\gets{:\mathrel{-}}
\newcommand\name\text
%\renewcommand\name[1]{\ensuremath{\mathrm{#1}}}
\newcommand\tset[1]{\{{#1}\}}
\newcommand\x\times
\newcommand\N{\mathbb{N}}
\newcommand\eset[1]{\{{#1}\}}
\newcommand\esetfor[2]{\eset{{#1} \mathrel{|} {#2}}}
\newcommand\efor[1]{\kw{for}\;{#1}\;\kw{do}\;}
\newcommand\ewhen[1]{\kw{when}\;{#1}\;\kw{do}\;}
\newcommand\efix[1]{\kw{fix}~{#1}~\kw{is}\;}
\newcommand\efixh[1]{\efix{\hilit #1}}

\newcommand\shaded{\color{gray}}
\newcommand\hilit{\color{Rhodamine}}
\newcommand\todo[1]{{\color{red}#1}}
\newcommand\XXX{\todo{XXX}}


\title{Datafun}
\subtitle{A higher-order functional Datalog}
\author{Michael Arntzenius}
\institute{University of Birmingham}
\date{DPA 2019}

\begin{document}
\maketitle

\Large

\begin{frame}{}
  \centering \huge
  \EMPH{caveat}
  \\[1ex]
  \emph{{\color{ForestGreen}theory} \& {\color{DarkOrchid}implementation}}
\end{frame}

\newcommand\whereami[1]{
\begin{frame}
  \centering
  \begin{tabular}%
%{@{}r@{$\;\;\sim\;\;$}l@{}}
{@{}r@{\hskip 1em}l@{}}
%{@{}l@{\hskip 1em}l@{}}
    \EMPH{Datalog} & \EMPH{Datafun}
    \\\midrule
     predicates & finite sets
     \\[.5ex]
     conjunctive queries & set comprehensions
     \\[.5ex]
     \shaded recursive definitions & \shaded fixed points
     \\[.5ex]
     \shaded stratification & \shaded monotonicity types
     %% %% TODO
     %% \\[.5ex]
     %% \shaded declarative
     %% & \shaded pure \& terminating
  \end{tabular}
\end{frame}
}


%% Sets & set comprehensions
\whereami{0}

\begin{frame}
  \EMPH{Datalog}
  \[
  \begin{array}{l}
    \name{edge}(1,2).\\\name{edge}(2,3).\\
    \name{p}(X,Z) \gets \name{edge}(X,Y),\, \name{edge}(Y,Z).
  \end{array}
  \]
  \vspace{0pt} % yes, makes a difference

  \EMPH{Datafun}
  \[
  \begin{array}{l}
    \name{edge}, \name{p} : \tset{\N \x \N}\\
    \name{edge} = \eset{(1,2), (2,3)}\\
    \name{p} =
    \esetfor{(x,z)}{(x,y) \in \name{edge},\, (y,z) \in \name{edge}}
    %% \\\pause
    %% \phantom{\name{p}} = \efor{(x,y_1) \in \name{edge}}
    %% \\
    %% \phantom{\name{p} ={}}\quad\efor{(y_2,z) \in \name{edge}}
    %% \\
    %% \phantom{\name{p} ={}}\quad\quad\ewhen{y_1 = y_2} \eset{(x,z)}
  \end{array}
  \]
  \vspace{1em}
\end{frame}


%% Recursive definitions / fixed points
\whereami{1}

\begin{frame}{}
  \EMPH{Datalog}
  \[
  \begin{array}{l}
    \name{path}(X,Z) \gets \name{edge}(X,Z).\\
    \name{path}(X,Z) \gets \name{edge}(X,Y),\, \name{path}(Y,Z).
  \end{array}
  \]
  \vspace{0pt}

  \EMPH{Datafun}
  \[
  \begin{array}{l}
    \name{path} =
    %% \name{edge} \cup
    %% {}\\\phantom{\name{path} ={}}
    %% \esetfor{(x,z)}{(x,y) \in \name{edge}, (y,z) \in \name{path}}
    %% \\\pause
    %% \phantom{\name{path}} =
    \efixh{p}\\
    \phantom{\name{path} ={}}
    \name{edge} \cup \esetfor{(x,z)}{(x,y) \in \name{edge}, (y,z) \in \hilit p}
  \end{array}
  \]
\end{frame}


%% Stratification / monotonicity
\whereami{2}
\newcommand\tbool{\text{Bool}}
\newcommand\dto\to
\newcommand\mto{\overset{+}{\to}}

\begin{frame}
  \EMPH{Datalog}
  \[ \name{p}(0) \gets {\color{red}\neg}\name{p}(0).\]

  \EMPH{Datafun}
  \[
  \efix{p} \esetfor{0}{\mathop{\color{red}\neg}(0 \in p)}
  \]

  \begin{ceqn}
    \begin{align*}
    {\neg} &: \tbool \mathrel{\color{red}\dto} \tbool\\
    {\cup} &: \tset{A} \x \tset{A} \mathrel{\color{ForestGreen}\mto} \tset{A}
    \end{align*}
  \end{ceqn}
\end{frame}

%% TODO: purity & termination


%% Part II: higher-order programming

\begin{frame}
  \centering\huge
  {II}\\[1ex]
  \emph{Higher-order examples}
\end{frame}

\begin{frame}{Generic transitive closure}
  \[
  \begin{array}{l}
    \uncover<2->{\name{trans} : \tset{A \x A} \dto \tset{A \x A}}
    \\
    \uncover<2->{\name{trans} \;e =} \efixh{p}\\
    \phantom{\name{trans} \;e ={}}
    e \cup
    \esetfor{(x,z)}{(x,y) \in e, (y,z) \in \hilit p}
    \\[1em]\pause
    \name{foo} = \name{trans}\;\name{edges}\\
    \name{bar} = \name{trans}\;(\name{redEdges} \cap \name{greenEdges})\\
    \phantom{\name{bar}\hspace{.56em}} \vdots
  \end{array}
  \]
  \vfill
\end{frame}

\newcommand\regexor{\mathbin{|}}
\newcommand\regexthen{\mathbin{;}}

\begin{frame}{Regular expressions as functions}
  \[
  \begin{array}{l}
    \kw{type}~ \name{String} = \tset{\N \x \name{Char}}\\
    \kw{type}~ \name{Regex} = \name{String} \dto \tset{\N \x \N}
    \\[1em]
    (\regexor), (\regexthen) : \name{Regex} \x \name{Regex} \to \name{Regex}
    \\
    (r_1 \regexor r_2) \;s = r_1\;s \cup r_2\;s\\
    (r_1 \regexthen r_2) \;s = \esetfor{(i,k)}{(i,j) \in r_1\;s,\, (j,k) \in r_2\;s}
    \\[1em]
    (-)^+ : \name{Regex} \to \name{Regex}\\
    r^+ \;s = \name{trans} \;(r\;s)
  \end{array}
  \]
  \vfill
\end{frame}


%% Part III. Semilattices
\begin{frame}
  \centering\huge
  {III}\\[1ex]
  \begin{tabular}{@{}r@{\;}l@{}}
    &\emph{fixed points}
    \\
    {of} &\emph{monotone maps}
    \\
    {on} &\emph{\alt<2>{\hilit semilattices}{%
        finite sets}}
  \end{tabular}
\end{frame}

\newcommand\tmap[2]{\{{#1} \mapsto {#2}\}}
\newcommand\emap[1]{\eset{#1}}
\newcommand\comment[1]{\text{\shaded #1}}

\begin{frame}
  \[ 
  \begin{array}{l}
    \kw{type}\ \name{Distance} = \infty < ... < 3 < 2 < 1 < 0
    \\[1ex]\pause
    \name{edges} : \tmap{\N \x \N}{\name{Distance}}\\
    \name{edges} = \emap{(0,1 \mapsto 3),\, (1,2 \mapsto 2)}
    \\
    \comment{-{}- Otherwise \name{edges} takes $(x,y \mapsto \infty)$.}
    \\[1ex]\pause
    \name{shortest} : \tmap{\N \x \N}{\name{Distance}}\\
    \name{shortest} = \\
    \quad\efixh{s} \name{edges} \vee {}\\
    \quad\phantom{\efixh{s}} \{\,(i,k \mapsto d_1 + d_2)\\
    \quad\phantom{\efixh{s}} \!\mathrel{|} (i,j \mapsto d_1) \in {\hilit s},
    %\\\phantom{\name{shortest} =}\phantom{{}\mathrel{|}{}}
    (j,k \mapsto d_2) \in {\hilit s}\}
  \end{array}
  \]
  %% \[
  %% \begin{array}{l}
  %%   \name{edges} : \tmap{\N \x \N}{\name{Distance}}\\
  %%   \name{edges} = \emap{(0,1) \mapsto 2, (1,2) \mapsto 3}
  %% \end{array}
  %% \]
\end{frame}

\end{document}
