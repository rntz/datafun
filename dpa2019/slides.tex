\documentclass[dvipsnames,fleqn]{beamer}

\usefonttheme{professionalfonts} % using non-standard fonts
\usefonttheme{serif} % Make serif default.

%\PassOptionsToPackage{scaled=1.04}{rntzfont}

\usepackage[source,]{rntzfont}
%\usepackage[newmath,]{rntzfont}
%\usepackage[palatino,newmath,]{rntzfont}
%\usepackage[librebaskerville,newmath,]{rntzfont}\newcommand\EMPH\textbf
%\usepackage[libertine,newmath,]{rntzfont}
%\usepackage{mathpazo}

\providecommand\EMPH\textsc

\usepackage{booktabs}
\usepackage{stmaryrd}
\usepackage{nccmath}
\usepackage{anyfontsize} % suppress warnings about stmaryrd sizes

\setlength{\mathindent}{1em}


\newcommand\kw\textbf
%\renewcommand\gets\shortleftarrow
%\renewcommand\gets{:\mathrel{-}}
\newcommand\name\text
\newcommand\tset[1]{\{{#1}\}}
\newcommand\x\times
\newcommand\N{\mathbb{N}}
\newcommand\eset[1]{\{{#1}\}}
\newcommand\esetfor[2]{\eset{{#1} \mathrel{|} {#2}}}
\newcommand\efor[1]{\kw{for}\;{#1}\;\kw{do}\;}
\newcommand\ewhen[1]{\kw{when}\;{#1}\;\kw{do}\;}

\newcommand\shaded{\color{gray}}


\title{Datafun}
\subtitle{A higher-order functional Datalog}
\author{Michael Arntzenius}
\institute{University of Birmingham}
\date{DPA 2019}

\begin{document}
\maketitle

\Large

\begin{frame}{}
  \centering \huge
  \EMPH{A Caveat}
  \\[1ex]
  \emph{{\color{ForestGreen}theory} vs. {\color{DarkOrchid}implementation}}
\end{frame}

\newcommand\whereami[1]{
\begin{frame}
  \centering
  \begin{tabular}%
%{@{}r@{$\;\;\sim\;\;$}l@{}}
{@{}r@{\hskip 1em}l@{}}
%{@{}l@{\hskip 1em}l@{}}
    \EMPH{Datalog} & \EMPH{Datafun}
    \\\midrule
     predicates & finite sets
     \\[.5ex]
     conjunctive queries & set comprehensions
     \\[.5ex]
     \shaded recursive definitions & \shaded fixed points
     \\[.5ex]
     \shaded stratification & \shaded monotonicity types
     \\[.5ex]
     \shaded declarative
     & \shaded pure \& terminating
  \end{tabular}
\end{frame}
}


%% Sets & set comprehensions
\whereami{0}

\begin{frame}
  \EMPH{Datalog}
  \[
  \begin{array}{l}
    \name{edge}(1,2).\\\name{edge}(2,3).\\
    \name{p}(X,Z) \gets \name{edge}(X,Y),\, \name{edge}(Y,Z).
  \end{array}
  \]
  \vspace{0pt} % yes, makes a difference

  \EMPH{Datafun}
  \[
  \begin{array}{l}
    \name{edge}, \name{p} : \tset{\N \x \N}\\
    \name{edge} = \eset{(1,2), (2,3)}\\
    \name{p} =
    \esetfor{(x,z)}{(x,y) \in \name{edge},\, (y,z) \in \name{edge}}
    %% \\\pause
    %% \phantom{\name{p}} = \efor{(x,y_1) \in \name{edge}}
    %% \\
    %% \phantom{\name{p} ={}}\quad\efor{(y_2,z) \in \name{edge}}
    %% \\
    %% \phantom{\name{p} ={}}\quad\quad\ewhen{y_1 = y_2} \eset{(x,z)}
  \end{array}
  \]
  \vspace{1em}
\end{frame}


%% Recursive definitions / fixed points
\whereami{1}

\newcommand\efix[1]{\kw{fix}\;{#1}\;\kw{is}\;}
\newcommand\hilit{\color{Rhodamine}}

\begin{frame}
  \EMPH{Datalog}
  \[
  \begin{array}{l}
    \name{path}(X,Z) \gets \name{edge}(X,Z).\\
    \name{path}(X,Z) \gets \name{edge}(X,Y),\, \name{path}(Y,Z).
  \end{array}
  \]
  \vspace{0pt}

  \EMPH{Datafun}
  \[
  \begin{array}{l}
    \name{path} =
    %% \name{edge} \cup
    %% {}\\\phantom{\name{path} ={}}
    %% \esetfor{(x,z)}{(x,y) \in \name{edge}, (y,z) \in \name{path}}
    %% \\\pause
    %% \phantom{\name{path}} =
    \efix{\hilit p}\\
    \phantom{\name{path} ={}}
    \name{edge} \cup \esetfor{(x,z)}{(x,y) \in \name{edge}, (y,z) \in \hilit p}
  \end{array}
  \]
  
\end{frame}

\end{document}
