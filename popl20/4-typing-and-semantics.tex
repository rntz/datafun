\section{Typing and Semantics of Core Datafun}
\label{sec:typing-and-semantics}

%In this section, we give the typing and semantics of core Datafun.
\input{fig-typing}

\subsection{Syntax}

The typing rules of core Datafun are given in \cref{fig:core-datafun}. Contexts
are lists of hypotheses $H$; a hypothesis gives the type of either a monotone
variable $\h x A$ or a discrete variable $\hd x A$. Given a context $\G$, we
define the \emph{stripping} operation $\stripcx\G$ which returns a new context
which agrees with $\G$ on discrete hypotheses, but drops all the monotone
hypotheses.

We now give a judgement $\J{e}{\G}{A}$, which is glossed as ``under
hypotheses $\G$, the term $e$ has the type $A$.'' The \rn{Var} and \rn{DVar}
rules say that both monotone hypotheses $\h x A$ and discrete hypotheses
$\hd x A$ justify ascribing the variable $x$ the type $A$. At first glance,
the \rn{Lam} rule is the familiar rule for lambda-abstraction, which
typechecks a lambda-expression $\fnof x e$ a the function type $A \to B$
when the body $e$ typechecks at $B$ in a context extended with $\h x
A$. However, note the subtlety that we assume $x$ is a \emph{monotone}
variable, not a discrete one. (This is the ``right'' choice since in the
category of posets and monotone maps, the exponential object are posets of
monotone functions.) The application rule \rn{App} is standard, though: a
term $e\>e'$ typechecks at $B$ if the function expression $e$ has type
$A \to B$, and the argument expression $e'$ has the type $B$.

The unit rule \rn{Unit} is standard, with the unit value $\etuple{}$ having
the type $1$ in all contexts. Similarly, the rules for pairs, \rn{Pair} and
\rn{Prj} are also standard. A pair $\etuple{e_1, e_2}$ has the type
$A_1 \times A_2$ when $e_1$ has type $A_1$, and $e_2$ has type $A_2$, and
symmetrically a projection $\pi_i(e)$ has type $A_i$ when $e$ has a pair
type. Similarly, the rules for sums, \rn{Inj} and \rn{Case} are standard.
An injection $\inj i e$ has type $A_1 + A_2$ when $e$ has type $A_i$, and
the typing rule for case expressions \rn{Case} says that a case
expression $\ecase{e} (\inj i {x_i} \caseto f_i)_i$ has type $B$, when
$e$ is of sum type $A_1 + A_2$, and each branch $f_1$ and $f_2$ has type $B$
in a context augmented with $\h {x_1} {A_1}$ and $\h {x_2} {A_2}$ respectively.
Note that both of these are once again monotone variables.

The rule \rn{BoxI} says that $\ebox{e}$ has type $\iso A$ when
$e$ has type $A$ in the stripped context $\stripcx\G$. By deleting
all the monotone variables, the rule ensures that $e$ can only
refer to discrete variables. The elimination rule \rn{BoxE} ascribes
the term $\elet{\ebox x = e}f$ the type $B$, when $e$ has type $\iso A$,
and $f$ typechecks at $B$ in a context extended with a \emph{discrete}
hypothesis $\hd x A$.

At this point, the typing rules correspond to standard constructive S4
modal logic. We can get to Datafun by adding a handful of
domain-specific types and operations. The first specialized rule is
the \rn{Split} rule, which says that $\esplit e$ has the type
$\iso A + \iso B$ when $e$ has the type $\iso (A + B)$. This is
syntax\footnote{An alternative syntax, pursued in \citet{datafun},
  would be to give two rules for $\kw{case}$, depending on whether or
  not the scrutinee could be typechecked in a stripped context.} for
the distributive law of box through sum types. The other direction
(getting $\iso (A + B)$ from $\iso A + \iso B$) is already derivable,
as is the isomorphism between $\iso A \times \iso B$ and
$\iso (A \times B)$. We have used all these operation implicitly, to
propagate discretenes into the variables of a pattern inside a box
pattern -- in the pattern $\ebox{\etuple{\inj 1 x, \inj 2 y}}$, we
expect both the variables $x$ and $y$ to be discrete, which is
information we propagate using these coercions. Semantically, all
of these operations are the identity, as we will see in the following
subsection.

This leaves only the rules for manipulating sets and other
semilattices. Recall that sets form a semilattice in the inclusion order,
with the empty set as least element and set union as join, and also that
products of semilattices are semilattices (with order and operations given
pointwise). So we take the \emph{semilattice types} $L$ to be the set type
$\tset A$, as well as units $1$ and products of lattice types
$L_1 \times L_2$.  Then, the \rn{Bot} rule says that the term $\bot$ is the
least element of any semilattice type $L$, and the \rn{Join} rule gives the
type of joins, saying that $e_1 \vee e_2$ is of semilattice type $L$ when
each $e_i$ has type $L$. These constructors work for any semilattice $L$,
but there are rules specialized to sets as well. The typing rule for
eliminating sets, \rn{SetFor}, is \emph{almost} the monadic bind. However,
we generalize it by not requiring the term $\efor{x}{e}{e'}$ to eliminate
into a set type. Instead, we permit $e'$ to be \emph{any} semilattice type,
not just sets. Similarly, the introduction form \rn{Set} is specific to set
types, saying that $\eset{e_i}_{i\in I}$ has type $\tset A$ when each of the
$e_i$ has type $A$. Furthermore, each $e_i$ has to typecheck in the discrete
context, since membership relies on the non-monotonic property of equality.
This can be seen in the \rn{Eq} rule, which checks equality of two terms
$\eeq e f$ only when they are discrete, checking in stripped contexts.
%
Finally, the rule \rn{Fix} for fixed points $\efix e$, takes an endofunction
$e$ of type $\iso (L \to L)$ and yields an expression of type $L$. In addition
to being of semilattice type, we also demand here that $L$ is of finite height,
ensuring that the recursion will terminate.

\subsection{Semantics}

The syntax of core Datafun can be interpreted in $\Poset$, the
category of partially ordered sets and monotone functions between
them. That is, an object $A$ of $\Poset$ is a pair $(A, \leq_A)$
consisting of a set $A$ of elements, and a partial order relation
$\leq_A \subseteq A \times A$ which is reflexive, transitive, and
antisymmetric. A morphism $f : A \to B$ in $\Poset$ is a function on
sets $f : A \to B$ which is monotone.  That is, for all $a$ and $a'$
such that $a \leq_A a'$ we have $f(a) \leq_B f(a')$. The identity
morphism is the identity function on the underlying sets, and
composition of morphisms is just ordinary function composition.
We will typically write composition in diagramamtic
or ``pipeline'' order: given $f : A \to B$ and $g : B \to C$ we
write $(f \then g) : A \to C$.



\input{fig-semantics}




\subsubsection{Cartesian Closed Structure}

The cartesian closed structure of $\Poset$ is largely the
same as in $\kw{Set}$.

\paragraph{Products} Given  partial orders $(A, \leq_A)$ and $(B, \leq_B)$,
we define the poset $(A , \leq_A) \times (B, \leq_B)$ to be
$(A \times B, \leq_{A \times B})$ with the order defined as:

\begin{displaymath}
  (a,b) \leq_{A \times B} (a', b') \iff a \leq_A a' \;\mbox{and}\; b \leq_B b'
\end{displaymath}

The verification that this forms a partial order is routine. To
form the product object, we equip $A \times B$ with the projection
maps $\pi_1 : A \times B \to A$ and $\pi_2 : A \times B \to B$, which are
defined by the first and second projection on the underlying sets
respectively.
%
Given two maps $f : A \to B$ and $g : A \to C$, the universal property
of products is witnessed by $\fork{f,g} : A \to B \times C$, where
\begin{displaymath}
  \fork{f, g} \triangleq a \mapsto \etuple{f(a), g(a)}
\end{displaymath}
%
The verification that these maps are monotone and that the relevant
diagrams commute is routine.

\paragraph{Exponentials} Given partial orders $(A, \leq_A)$ and $(B, \leq_B)$,
we define the poset $(A , \leq_A) \to (B, \leq_B)$ to be $(A \to B, \leq_{A \to B})$
with the order defined as:
%
\begin{displaymath}
  f \leq_{A \to B} g \iff \forall a \in A.\; f(a) \leq_B g(a)
\end{displaymath}
That this gives a partial order is immediate. We form the exponential object by
equipping it with the evaluation map $\eval_{A,B} \in \Poset((A \to B) \times A, B)$,
defined via evaluation on sets:
\begin{displaymath}
  \eval \triangleq (f,x) \mapsto f(x)
\end{displaymath}
%
Given $f : C \times A \to B$, the ``exponential transpose'' (i.e., currying
operation) is defined as:
\begin{eqnarray*}
  \lambda(f) & : & C \to (A \to B) \\
  \lambda(f) & \triangleq & c \mapsto (\fnof{a} f(c,a))
\end{eqnarray*}
Verifying that these maps are monotone and that the relevant
diagrams commute is straightforward.

\paragraph{Coproducts} Given partial orders $(A, \leq_A)$ and $(B, \leq_B)$,
we define the poset $(A , \leq_A) + (B, \leq_B)$ to be $(A + B, \leq_{A + B})$ with
the order defined by (with the understanding that if no clause matches there is
no order relationship):
%
\begin{eqnarray*}
  \inj 1 a \leq_{A+B} \inj 1 a' & \iff & a \leq_A a' \\
  \inj 2 b \leq_{A+B} \inj 2 b' & \iff & b \leq_B b'
\end{eqnarray*}
%
It is easy to check this yields a partial order. We can construct the coproduct
object by equipping this poset with the injections $\inj 1 {} : A \to A + B$
and $\inj 2 {} : B \to A + B$, which are given by the injections on the underlying
sets.
%
Given two maps $f : A \to C$ and $g : B \to C$, the universal property
of coproducts is witnessed by $\krof{f,g} : A + B \to C$, where
\begin{displaymath}
  \krof{f, g} \triangleq x \mapsto \left\{\begin{array}{ll}
                                            f(a) & \mbox{when}\;x = \inj 1 a \\
                                            g(b) & \mbox{when}\;x = \inj 2 b
                                          \end{array}
                                        \right.
\end{displaymath}
It is easy to check the defined maps are monotone and that the relevant diagrams commute.
\subsubsection{The Discreteness Comonad}
Given a poset $(A, \leq_A)$ we define the discreteness operator $\Box(A, \leq_A)$
as $(A, \leq_{\iso A})$, where
\begin{displaymath}
  a \leq_{\iso A} a' \iff a = a'
\end{displaymath}
That is, the discrete order preserves the underlying elements, but reduces the partial order
to mere equality. Given a morphism $f : A \to B$, the functorial
action is defined as:
\begin{displaymath}
  \iso(f) \triangleq f
\end{displaymath}
That is, the action on morphisms just gives back the same underlying function on sets. Checking
that this preserves monotonicity is trivial, as is the preservation of identities and
composition. This functor forms a comonad, with the extraction $\varepsilon_A : \iso A \to A$
and duplication $\delta_A : \iso A \to \iso \iso A$ given by identities on the underlying
sets:
\begin{displaymath}
  \begin{array}{llcll}
  \varepsilon_A & : \iso A \to A & \hspace{2cm} & \delta_A & : \iso A \to \iso \iso A \\
  \varepsilon_A & = a \mapsto a & & \delta_A & = a \mapsto a
  \end{array}
\end{displaymath}
Once we check that the monotonicity requirements are satisfied, this
makes checking the comonad diagrams easy. It is also immediate that $\iso$ is a comonad
monoidal with respect to \emph{both} products and coproducts. That is, $\iso (A \times B)
\simeq \iso A \times \iso B$, and also $\iso (A + B) \simeq \iso A + \iso B$. In both
cases the isomorphism is witnessed in both directions by identity on the underlying elements.
We will write $\morph{dist}^\Box_\times$  to name the map witnessing distributivity of $\iso$ over
products, and $\morph{dist}^\Box_+$  to name the map witnessing distributivity of $\iso$ over coproducts.

\subsubsection{Sets and Lattices} Given a poset $(A, \leq_A)$ we
define the finite powerset poset $\pfinof(A, \leq_A)$ as
$(\pfinof A, \subseteq)$, with subsets of $A$ as elements ordered by
subset inclusion. This is obviously a semilattice, with the least
element $\morph{join}^{\pfinof A}_0$ given by the empty set, and binary join
$\morph{join}^{\pfinof A}_2$ given by union. If $A$ itself is finite, then this is
also a \emph{complete} semilattice.  We can define the following
collection of useful morphisms on sets:
\begin{displaymath}
  \begin{array}{lclclcl}
    \morph{join}^{\pfinof A}_0& : & 1 \to \pfinof(A) & \qquad & \morph{join}^{\pfinof A}_2 & : & \pfinof(A) \times \pfinof(A) \to \pfinof(A) \\
    \morph{join}^{\pfinof A}_0& = & \etuple{} \mapsto \emptyset  &  & \morph{join}^{\pfinof A}_2 & : & \etuple{X, Y} \mapsto X \cup Y \\[1em]
    \morph{singleton} & : & \iso A \to \pfinof{A} & & \morph{isEmpty} & : & \iso \pfinof{A} \to 1 + 1 \\
    \morph{singleton} & = & a \mapsto \esetraw{a}
    & &
    \morph{isEmpty} & = & X \mapsto \left\{ \begin{array}{ll}
                                              \inj 1 {\etuple{}} & \mbox{when}\;X = \emptyset \\
                                              \inj 2 {\etuple{}} & \mbox{otherwise}
                                            \end{array}
                                    \right.
  \end{array}
\end{displaymath}
The $\morph{singleton}$ function takes a value and makes a singleton set out of it. The
domain must be discrete, as otherwise the map will not be monotone (sets are ordered by
inclusion, and set membership relies on equality, not the partial order). Similarly,
the emptiness test $\morph{isEmpty}$ also takes a discrete set-valued argument, because
otherwise the boolean test would not be monotone.

Finally, if $L$ is a complete lattice, and $f : A \times \iso B \to L$, then we can define
we can also define the morphism $\morph{collect}(f) : A \times \pfinof{A} \to L$ as follows:
\begin{displaymath}
 \morph{collect}(f)  = (a, X) \mapsto \bigvee_{b \in X} f(a, b)
\end{displaymath}
We will use this to interpret for-comprehensions, since all the definable lattice
types (sets, and products of lattices) in core Datafun are complete lattices. However,
it is worth noting that the discreteness restrictions on $\morph{singleton}$ mean that
powersets do not quite form a monad in $\Poset$.

\subsubsection{Fixed Points} Given a finite-height semilattice $L$, we can define a fixed
point operation $\efix{} : \iso (L \to L) \to L$ as follows:
\begin{displaymath}
  \efix{} = f \mapsto \bigvee_{n \in \mathbb{N}} f^n(\bot)
\end{displaymath}
A routine inductive argument shows this must yield a least fixed point.

\subsubsection{Interpretation} The semantic interpetation (defined
over typing derivations) is given in \cref{fig:semantics}. We give the
interpretation in combinatory style, and to increase readability, we freely use
$n$-ary products to elide the book-keeping associated with reassociating binary
products. The interpretation itself mostly follows the usual interpretation for
constructive S4~\cite{depaiva-s4}, with what novelty there is occuring in the
interpretation of sets and fixed points. Even there, the semantics is
straightforward, making fairly direct use of the combinators defined above.

\subsection{Metatheory}

If we were presenting core Datafun in isolation, the usual thing to do
would be to prove the soundness of syntactic substitution, show that
syntactic and semantic substitution agree, and then establish the
equational theory. However, that is not our goal in this paper. We
want to prove the correctness of the semi\naive\ translation, which we
will do with a logical relations argument. Since we can harvest almost
all the properties we need from the logical relation, only a small
residue of metatheory needs to be established manually -- indeed, the
only thing we need to prove at this stage is the type-correctness of weakening.

We define the weakening relation $\Gamma \sqsubseteq \Delta$ in
\cref{fig:weakening}. This says that $\Delta$ is a weakening of $\Gamma$, either
because (as usual) it has extra hypotheses (in rule \rn{Drop}), or
(additionally!) because a hypothesis in $\Gamma$ becomes discrete in $\Delta$
(rule \rn{Disc}). The idea is that making a hypothesis discrete only increases
the number of places it can be used.

\begin{lemma}\label{thm:weaken}
  If $\J e \G A$ and $\G \sqsubseteq \D$ then $\J e \D A$.
\end{lemma}

\noindent This follows by the usual induction on typing derivations.

\input{fig-weakening}
