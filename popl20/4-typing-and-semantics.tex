\section{Types and semantics}
\label{sec:typing-and-semantics}

%In this section, we give the typing and semantics of core Datafun.
\input{fig-typing}

\todo{Explain typing of \isempty.}

The syntax of core Datafun is given in \cref{fig:syntax} and its typing rules in
\cref{fig:core-datafun}. Contexts are lists of hypotheses $H$; a hypothesis
gives the type of either a monotone variable $\h x A$ or a discrete variable
$\hd x A$. The stripping operation $\stripcx\G$ drops all monotone hypotheses
from the context $\G$, leaving only the discrete ones.
%
The typing judgement $\J{e}{\G}{A}$ may be glossed as ``under hypotheses $\G$,
the term $e$ has the type $A$''.

The \rn{var} and \rn{dvar} rules say that both monotone hypotheses $\h x A$ and
discrete hypotheses $\hd x A$ justify ascribing the variable $x$ the type $A$.
%
The \rn{lam} rule is the familiar rule for $\fn$-abstraction. However, note that
we introduce the argument variable $\h x A$ as a \emph{monotone} hypothesis, not
a discrete one. (This is the ``right'' choice because in \Poset\ the exponential
object is the poset of monotone functions.)
%
The application rule \rn{app} is standard, as are the rules \rn{unit},
\rn{pair}, \rn{prj}, \rn{inj}, and \rn{case}. As with \rn{lam}, the variables
$\h {x_i}{A_i}$ bound in the case branches $f_i$ are monotone.

\rn{box} says that $\ebox{e}$ has type $\iso A$ when $e$ has type $A$ in the
stripped context $\stripcx\G$. This restricts $e$ to refer only to discrete
variables, ensuring we don't smuggle any information we must treat monotonically
into a discretely-ordered $\iso$ expression. The elimination rule \rn{letbox}
for $(\eletbox x e f)$ allows us to ``cash in'' a boxed expression $e : \iso A$
by binding its result to a discrete variable $\hd x A$ in the body $f$.

At this point, our typing rules correspond to standard constructive S4 modal
logic~\cite{jrml}. We get to Datafun by adding a handful of domain-specific
types and operations. First, \rn{split} rule says that $\esplit e : \iso A +
\iso B$ whenever $e : \iso (A + B)$, distributing box across sum
types.\footnote{An alternative syntax, pursued in \citet{datafun}, would be to
  give two rules for $\kw{case}$, depending on whether or not the scrutinee
  could be typechecked in a stripped context.} The other direction, $\iso A +
\iso B \to \iso (A + B)$, is already derivable, as is the isomorphism $\iso A
\times \iso B \cong \iso (A \times B)$. In the examples we give, we use all
these operations implicitly, to propagate discreteness onto the variables bound
by a box pattern -- in the pattern $\pboxtuple{\inj 1 \dvar x, \inj 2 \dvar y}$,
we expect both the variables $\dvar x$ and $\dvar y$ to be discrete, which is
information we propagate using these coercions. Semantically, all of these
operations are the identity, as we will see in the following subsection.

This leaves only the rules for manipulating sets and other semilattices. Recall
that sets form a semilattice in the inclusion order, with the empty set as least
element and set union as join, and also that products of semilattices are
semilattices (with order and operations given pointwise). So we take the
\emph{semilattice types} $L$ to be the set type $\tset A$, as well as units $1$
and products of lattice types $L_1 \times L_2$. Then, the \rn{bot} rule says
that the term $\bot$ is the least element of any semilattice type $L$, and the
\rn{join} rule gives the type of joins, saying that $e_1 \vee e_2$ is of
semilattice type $L$ when each $e_i$ has type $L$. These constructors work for
any semilattice $L$, but there are rules specialized to sets as well. The typing
rule for eliminating sets, \rn{for}, is \emph{almost} the monadic bind. However,
we generalize it by not requiring the term $\efor{x}{e}{e'}$ to eliminate into a
set type. Instead, we permit $e'$ to be \emph{any} semilattice type, not just
sets. Similarly, the introduction form \rn{set} is specific to set types, saying
that $\esetsub{e_i}{i\in I}$ has type $\tset A$ when each of the $\eisiso{e_i}$
has type $A$. Furthermore, each $\eisiso{e_i}$ has to typecheck in the discrete
context, since membership relies on the non-monotonic property of equality. This
can be seen in the \rn{eq} rule, which checks equality of two terms $\eeq e f$
only when they are discrete, checking in stripped contexts.
%
Finally, the rule \rn{fix} for fixed points $\efix e$, takes an endofunction $e$
of type $\iso (\fixt L \to \fixt L)$ and yields an expression of type $\fixt L$.
In addition to being of semilattice type, we also demand here that $\fixt L$ is
of \todo{finite height}, ensuring that the recursion will terminate.

\subsection{Semantics}

The syntax of core Datafun can be interpreted in $\Poset$, the
category of partially ordered sets and monotone functions between
them. That is, an object $A$ of $\Poset$ is a pair $(A, \leq_A)$
consisting of a set $A$ of elements, and a partial order relation
$\leq_A \subseteq A \times A$ which is reflexive, transitive, and
antisymmetric. A morphism $f : A \to B$ in $\Poset$ is a function on
sets $f : A \to B$ which is monotone.  That is, for all $a$ and $a'$
such that $a \leq_A a'$ we have $f(a) \leq_B f(a')$. The identity
morphism is the identity function on the underlying sets, and
composition of morphisms is just ordinary function composition.
We will typically write composition in diagramamtic
or ``pipeline'' order: given $f : A \to B$ and $g : B \to C$ we
write $(f \then g) : A \to C$.



\input{fig-semantics}




\subsubsection{Cartesian Closed Structure}

The cartesian closed structure of $\Poset$ is largely the
same as in $\kw{Set}$.

\paragraph{Products} Given  partial orders $(A, \leq_A)$ and $(B, \leq_B)$,
we define the poset $(A , \leq_A) \times (B, \leq_B)$ to be
$(A \times B, \leq_{A \times B})$ with the order defined as:

\begin{displaymath}
  (a,b) \leq_{A \times B} (a', b') \iff a \leq_A a' \;\mbox{and}\; b \leq_B b'
\end{displaymath}

The verification that this forms a partial order is routine. To
form the product object, we equip $A \times B$ with the projection
maps $\pi_1 : A \times B \to A$ and $\pi_2 : A \times B \to B$, which are
defined by the first and second projection on the underlying sets
respectively.
%
Given two maps $f : A \to B$ and $g : A \to C$, the universal property
of products is witnessed by $\fork{f,g} : A \to B \times C$, where
\begin{displaymath}
  \fork{f, g} \triangleq a \mapsto \etuple{f(a), g(a)}
\end{displaymath}
%
The verification that these maps are monotone and that the relevant
diagrams commute is routine.

\paragraph{Exponentials} Given partial orders $(A, \leq_A)$ and $(B, \leq_B)$,
we define the poset $(A , \leq_A) \to (B, \leq_B)$ to be $(A \to B, \leq_{A \to B})$
with the order defined as:
%
\begin{displaymath}
  f \leq_{A \to B} g \iff \forall a \in A.\; f(a) \leq_B g(a)
\end{displaymath}
That this gives a partial order is immediate. We form the exponential object by
equipping it with the evaluation map $\eval_{A,B} \in \Poset((A \to B) \times A, B)$,
defined via evaluation on sets:
\begin{displaymath}
  \eval \triangleq (f,x) \mapsto f(x)
\end{displaymath}
%
Given $f : C \times A \to B$, the ``exponential transpose'' (i.e., currying
operation) is defined as:
\begin{eqnarray*}
  \lambda(f) & : & C \to (A \to B) \\
  \lambda(f) & \triangleq & c \mapsto (\fnof{a} f(c,a))
\end{eqnarray*}
Verifying that these maps are monotone and that the relevant
diagrams commute is straightforward.

\paragraph{Coproducts} Given partial orders $(A, \leq_A)$ and $(B, \leq_B)$,
we define the poset $(A , \leq_A) + (B, \leq_B)$ to be $(A + B, \leq_{A + B})$ with
the order defined by (with the understanding that if no clause matches there is
no order relationship):
%
\begin{eqnarray*}
  \inj 1 a \leq_{A+B} \inj 1 a' & \iff & a \leq_A a' \\
  \inj 2 b \leq_{A+B} \inj 2 b' & \iff & b \leq_B b'
\end{eqnarray*}
%
It is easy to check this yields a partial order. We can construct the coproduct
object by equipping this poset with the injections $\inj 1 {} : A \to A + B$
and $\inj 2 {} : B \to A + B$, which are given by the injections on the underlying
sets.
%
Given two maps $f : A \to C$ and $g : B \to C$, the universal property
of coproducts is witnessed by $\krof{f,g} : A + B \to C$, where
\begin{displaymath}
  \krof{f, g} \triangleq x \mapsto \left\{\begin{array}{ll}
                                            f(a) & \mbox{when}\;x = \inj 1 a \\
                                            g(b) & \mbox{when}\;x = \inj 2 b
                                          \end{array}
                                        \right.
\end{displaymath}
It is easy to check the defined maps are monotone and that the relevant diagrams commute.
\subsubsection{The Discreteness Comonad}
Given a poset $(A, \leq_A)$ we define the discreteness operator $\Box(A, \leq_A)$
as $(A, \leq_{\iso A})$, where
\begin{displaymath}
  a \leq_{\iso A} a' \iff a = a'
\end{displaymath}
That is, the discrete order preserves the underlying elements, but reduces the partial order
to mere equality. Given a morphism $f : A \to B$, the functorial
action is defined as:
\begin{displaymath}
  \iso(f) \triangleq f
\end{displaymath}
That is, the action on morphisms just gives back the same underlying function on sets. Checking
that this preserves monotonicity is trivial, as is the preservation of identities and
composition. This functor forms a comonad, with the extraction $\varepsilon_A : \iso A \to A$
and duplication $\delta_A : \iso A \to \iso \iso A$ given by identities on the underlying
sets:
\begin{displaymath}
  \begin{array}{llcll}
  \varepsilon_A & : \iso A \to A & \hspace{2cm} & \delta_A & : \iso A \to \iso \iso A \\
  \varepsilon_A & = a \mapsto a & & \delta_A & = a \mapsto a
  \end{array}
\end{displaymath}
Once we check that the monotonicity requirements are satisfied, this
makes checking the comonad diagrams easy. It is also immediate that $\iso$ is a comonad
monoidal with respect to \emph{both} products and coproducts. That is, $\iso (A \times B)
\simeq \iso A \times \iso B$, and also $\iso (A + B) \simeq \iso A + \iso B$. In both
cases the isomorphism is witnessed in both directions by identity on the underlying elements.
We will write $\morph{dist}^\Box_\times$  to name the map witnessing distributivity of $\iso$ over
products, and $\morph{dist}^\Box_+$  to name the map witnessing distributivity of $\iso$ over coproducts.

\subsubsection{Sets and Lattices} Given a poset $(A, \leq_A)$ we
define the finite powerset poset $\pfinof(A, \leq_A)$ as
$(\pfinof A, \subseteq)$, with subsets of $A$ as elements ordered by
subset inclusion. This is obviously a semilattice, with the least
element $\morph{join}^{\pfinof A}_0$ given by the empty set, and binary join
$\morph{join}^{\pfinof A}_2$ given by union. If $A$ itself is finite, then this is
also a \emph{complete} semilattice.  We can define the following
collection of useful morphisms on sets:
\begin{displaymath}
  \begin{array}{lclclcl}
    \morph{join}^{\pfinof A}_0& : & 1 \to \pfinof(A) & \qquad & \morph{join}^{\pfinof A}_2 & : & \pfinof(A) \times \pfinof(A) \to \pfinof(A) \\
    \morph{join}^{\pfinof A}_0& = & \etuple{} \mapsto \emptyset  &  & \morph{join}^{\pfinof A}_2 & : & \etuple{X, Y} \mapsto X \cup Y \\[1em]
    \morph{singleton} & : & \iso A \to \pfinof{A} & & \morph{isEmpty} & : & \iso \pfinof{A} \to 1 + 1 \\
    \morph{singleton} & = & a \mapsto \esetraw{a}
    & &
    \morph{isEmpty} & = & X \mapsto \left\{ \begin{array}{ll}
                                              \inj 1 {\etuple{}} & \mbox{when}\;X = \emptyset \\
                                              \inj 2 {\etuple{}} & \mbox{otherwise}
                                            \end{array}
                                    \right.
  \end{array}
\end{displaymath}
The $\morph{singleton}$ function takes a value and makes a singleton set out of it. The
domain must be discrete, as otherwise the map will not be monotone (sets are ordered by
inclusion, and set membership relies on equality, not the partial order). Similarly,
the emptiness test $\morph{isEmpty}$ also takes a discrete set-valued argument, because
otherwise the boolean test would not be monotone.

Finally, if $L$ is a complete lattice, and $f : A \times \iso B \to L$, then we can define
we can also define the morphism $\morph{collect}(f) : A \times \pfinof{A} \to L$ as follows:
\begin{displaymath}
 \morph{collect}(f)  = (a, X) \mapsto \bigvee_{b \in X} f(a, b)
\end{displaymath}
We will use this to interpret for-comprehensions, since all the definable lattice
types (sets, and products of lattices) in core Datafun are complete lattices. However,
it is worth noting that the discreteness restrictions on $\morph{singleton}$ mean that
powersets do not quite form a monad in $\Poset$.

\subsubsection{Fixed Points} Given a finite-height semilattice $L$, we can define a fixed
point operation $\efix{} : \iso (L \to L) \to L$ as follows:
\begin{displaymath}
  \efix{} = f \mapsto \bigvee_{n \in \mathbb{N}} f^n(\bot)
\end{displaymath}
A routine inductive argument shows this must yield a least fixed point.

\subsubsection{Interpretation} The semantic interpetation (defined
over typing derivations) is given in \cref{fig:semantics}. We give the
interpretation in combinatory style, and to increase readability, we freely use
$n$-ary products to elide the book-keeping associated with reassociating binary
products. The interpretation itself mostly follows the usual interpretation for
constructive S4~\cite{depaiva-s4}, with what novelty there is occuring in the
interpretation of sets and fixed points. Even there, the semantics is
straightforward, making fairly direct use of the combinators defined above.

\subsection{Metatheory}

If we were presenting core Datafun in isolation, the usual thing to do
would be to prove the soundness of syntactic substitution, show that
syntactic and semantic substitution agree, and then establish the
equational theory. However, that is not our goal in this paper. We
want to prove the correctness of the semi\naive\ translation, which we
will do with a logical relations argument. Since we can harvest almost
all the properties we need from the logical relation, only a small
residue of metatheory needs to be established manually -- indeed, the
only thing we need to prove at this stage is the type-correctness of weakening.

We define the weakening relation $\Gamma \sqsubseteq \Delta$ in
\cref{fig:weakening}. This says that $\Delta$ is a weakening of $\Gamma$, either
because (as usual) it has extra hypotheses (in rule \rn{drop}), or
(additionally!) because a hypothesis in $\Gamma$ becomes discrete in $\Delta$
(rule \rn{disc}). The idea is that making a hypothesis discrete only increases
the number of places it can be used.

\begin{lemma}\label{thm:weaken}
  If $\J e \G A$ and $\G \sqsubseteq \D$ then $\J e \D A$.
\end{lemma}

\noindent This follows by the usual induction on typing derivations.

\input{fig-weakening}
