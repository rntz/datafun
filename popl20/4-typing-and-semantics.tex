\section{Typing and Semantics of Core Datafun}
\label{sec:typing-and-semantics}

In this section, we give the typing and semantics of core Datafun. 
\input{fig-typing}

\subsection{Syntax}

The typing rules of core Datafun are given in Figure~\ref{fig:core-datafun}.
Contexts are lists of hypotheses, and hypotheses are either monotone variables
associated with a type $\h x A$, or they are discrete variables associated
with a type $\hd x A$. Given a context $\G$, we define the \emph{stripping}
operation $\stripcx\G$ which returns a new context which agrees with $\G$
on discrete hypotheses, but drops all the monotone hypotheses.

We now give a judgement $\J{e}{\G}{A}$, which is glossed as ``under
hypotheses $\G$, the term $e$ has the type $A$.'' The \rn{Var} and \rn{DVar}
rules say that both monotone hypotheses $\h x A$ and discrete hypotheses
$\hd x A$ justify ascribing the variable $x$ the type $A$. At first glance,
the \rn{Lam} rule is the familiar rule for lambda-abstraction, which
typechecks a lambda-expression $\fnof x e$ a the function type $A \to B$
when the body $e$ typechecks at $B$ in a context extended with $\h x
A$. However, note the subtlety that we assume $x$ is a \emph{monotone}
variable, not a discrete one. (This is the ``right'' choice since in the
category of posets and monotone maps, the exponential object are posets of
monotone functions.) The application rule \rn{App} is standard, though: a
term $e\>e'$ typechecks at $B$ if the function expression $e$ has type
$A \to B$, and the argument expression $e'$ has the type $B$.

The unit rule \rn{Unit} is standard, with the unit value $\etuple{}$ having
the type $1$ in all contexts. Similarly, the rules for pairs, \rn{Pair} and
\rn{Prj} are also standard. A pair $\etuple{e_1, e_2}$ has the type
$A_1 \times A_2$ when $e_1$ has type $A_1$, and $e_2$ has type $A_2$, and
symmetrically a projection $\pi_i(e)$ has type $A_i$ when $e$ has a pair
type. Similarly, the rules for sums, \rn{Inj} and \rn{Case} are standard.
An injection $\inj i e$ has type $A_1 + A_2$ when $e$ has type $A_i$, and
the typing rule for case expressions \rn{Case} says that a case
expression $\ecase{e} (\inj i {x_i} \caseto f_i)_i$ has type $B$, when
$e$ is of sum type $A_1 + A_2$, and each branch $f_1$ and $f_2$ has type $B$
in a context augmented with $\h {x_1} {A_1}$ and $\h {x_2} {A_2}$ respectively.
Note that both of these are once again monotone variables.

The rule \rn{BoxI} says that $\ebox{e}$ has type $\iso A$ when
$e$ has type $A$ in the stripped context $\stripcx\G$. By deleting
all the monotone variables, the rule ensures that $e$ can only
refer to discrete variables. The elimination rule \rn{BoxE} ascribes
the term $\elet{\ebox x = e}f$ the type $B$, when $e$ has type $\iso A$,
and $f$ typechecks at $B$ in a context extended with a \emph{discrete}
hypothesis $\hd x A$.

At this point, the typing rules correspond to standard constructive S4
modal logic. We can get to Datafun by adding a handful of
domain-specific types and operations. The first specialized rule is
the \rn{Split} rule, which says that $\esplit e$ has the type
$\iso A + \iso B$ when $e$ has the type $\iso (A + B)$. This is
syntax\footnote{An alternative syntax, pursued in \citet{datafun},
  would be to give two rules for $\kw{case}$, depending on whether or
  not the scrutinee could be typechecked in a stripped context.} for
the distributive law of box through sum types. The other direction
(getting $\iso (A + B)$ from $\iso A + \iso B$) is already derivable,
as is the isomorphism between $\iso A \times \iso B$ and
$\iso (A \times B)$. We have used all these operation implicitly, to
propagate discretenes into the variables of a pattern inside a box
pattern -- in the pattern $\ebox{\etuple{\inj 1 x, \inj 2 y}}$, we
expect both the variables $x$ and $y$ to be discrete, which is
information we propagate using these coercions. Semantically, all
of these operations are the identity, as we will see in the following
subsection. 

This leaves only the rules for manipulating sets and other
semilattices. Recall that sets form a semilattice in the inclusion order,
with the empty set as least element and set union as join, and also that
products of semilattices are semilattices (with order and operations given
pointwise). So we take the \emph{semilattice types} $L$ to be the set type
$\tset A$, as well as units $1$ and products of lattice types
$L_1 \times L_2$.  Then, the \rn{Bot} rule says that the term $\bot$ is the
least element of any semilattice type $L$, and the \rn{Join} rule gives the
type of joins, saying that $e_1 \vee e_2$ is of semilattice type $L$ when
each $e_i$ has type $L$. These constructors work for any semilattice $L$,
but there are rules specialized to sets as well. The typing rule for
eliminating sets, \rn{SetFor}, is \emph{almost} the monadic bind. However,
we generalize it by not requiring the term $\efor{x}{e}{e'}$ to eliminate
into a set type. Instead, we permit $e'$ to be \emph{any} semilattice type,
not just sets. Similarly, the introduction form \rn{Set} is specific to set
types, saying that $\eset{e_i}_{i\in I}$ has type $\tset A$ when each of the
$e_i$ has type $A$. Furthermore, each $e_i$ has to typecheck in the discrete
context, since membership relies on the non-monotonic property of equality.
This can be seen in the \rn{Eq} rule, which checks equality of two terms
$\eeq e f$ only when they are discrete, checking in stripped contexts.

Finally, the rule \rn{Fix} for fixed points $\efix e$, takes an endofunction
$e$ of type $\iso (L \to L)$ and yields an expression of type $L$. In addition
to being of semilattice type, we also demand here that $L$ is of finite height,
ensuring that the recursion will terminate. 

\subsection{Semantics }

The syntax of core Datafun can be interpreted in $\Poset$, the
category of partially ordered sets and monotone functions between
them. That is, an object $A$ of $\Poset$ is a pair $(|A|, \leq_A)$
consisting of a set $|A|$ of elements, and a partial order relation
$\leq_A \subseteq |A| \times |A|$ which is reflexive, transitive, and
antisymmetric. A morphism $f : A \to B$ in $\Poset$ is a function
$f : |A| \to |B|$ on the underlying sets which is monotone.  That is,
for all $a$ and $a'$ such that $a \leq_A a'$ we have
$f(a) \leq_B f(a')$.



\input{fig-semantics}

\subsection{Metatheory}

If we were presenting core Datafun in isolation, the usual thing to do
would be to prove the soundness of syntactic substitution, show that
syntactic and semantic substitution agree, and then establish the
equational theory. However, that is not our goal in this paper. We
want to prove the correctness of the semi\naive\ translation, which we
will do with a logical relations argument. Since we can harvest almost
all the properties we need from the logical relation, only a small
residue of metatheoretic need to be established at this -- indeed, the
only thing we need to estabish is the type-correctness of weakening.
