\usepackage{accents}            % for \underaccent
\usepackage{anyfontsize}        % suppress warnings about stmaryrd font size
\usepackage{booktabs}          % for formal tables, \midrule
\usepackage{mathpartir}         % \begin{mathpar}, \infer, etc.
\usepackage{mathtools}          % vertical centered colon, \dblcolon, \Coloneqq
\usepackage{stmaryrd}           % \shortrightarrow, \llbracket, etc.
\usepackage{subcaption}        % for complex figures with subfigures/subcaptions
\usepackage{nccmath}      % fix spacing around AMS math environments like align*
\usepackage{multirow}
\usepackage[outputdir=latex.out]{minted}\newcommand\datalog[1]{\mintinline{prolog}{#1}}

\usepackage{lipsum}       % TODO remove

\hyphenation{semi-na\"ive}

% cleveref must be loaded AFTER hyperref, amsmath, & amsthm.
\usepackage[nameinlink,noabbrev]{cleveref}% other options: capitalise
\newcommand\crefrangeconjunction{--} % use en-dashes for ranges.
\creflabelformat{equation}{#2#1#3} % No parentheses in equation labels.
\crefname{section}{\S\@gobble}{\S\@gobble}

% Use stmry medium as bold since there is no stmry bold.
\SetSymbolFont{stmry}{bold}{U}{stmry}{m}{n}

% Default to vertically centered colons. Doesn't quite work with euler, but
% better than nothing.
\mathtoolsset{centercolon}

%% More space around \cup and \vee.
\let\bincup\cup
\let\binvee\vee
\let\binwedge\wedge
\renewcommand\cup{\mathrel{\bincup}}
\renewcommand\vee{\mathrel{\binvee}}
\renewcommand\wedge{\mathrel{\binwedge}}


%% ---------- Commands ----------
\newcommand\ensuretext[1]{\ifmmode\text{#1}\else{#1}\fi}
\newcommand\todo[1]{\ensuretext{\color{Purple}\textbf{TODO:} #1}}
\newcommand\XXX{\textbf{\color{Purple}XXX}}
\newcommand\naive{na\"ive}
\newcommand\Naive{Na\"ive}

% used to distinguish discrely bound variables, etc.
\newcommand\isocolor{\color{ForestGreen}}

% used for names of functions, primitives, etc. in math mode
\newcommand\name[1]{\text{\itshape #1}}

% derivative variables
\newcommand\da{\mathvar{da}}
\newcommand\db{\mathvar{db}}
\newcommand\dx{\mathvar{dx}}
\newcommand\dy{\mathvar{dy}}
\newcommand\df{\mathvar{df}}
\newcommand\dg{\mathvar{dg}}
\newcommand\ds{\mathvar{ds}}
\newcommand\dgamma{d\gamma}


%% ===== General math & PL notation =====
\newcommand\fn{\texorpdfstring{\ensuremath{\lambda}}{lambda}}
\newcommand\boldfn{\texorpdfstring{\ensuremath{\boldsymbol\lambda}}{lambda}}
\ifdefined\G\renewcommand\G\Gamma\else\newcommand\G\Gamma\fi
\newcommand\g\gamma
\newcommand\D\Delta
\newcommand\DP{\D\Phi}
\newcommand\x\times
\newcommand\pto\rightharpoonup
\newcommand\injc{\mathrm{in}}
\newcommand\inj[1]{\injc_{#1}\,}
\newcommand\bnfor{\mathrel{\,|\,}}
\newcommand\bnfeq\Coloneqq
\newcommand\N{\mathbb{N}}
\newcommand\tuple[1]{\langle{#1}\rangle}
\newcommand\den[1]{\ensuremath{\llbracket{#1}\rrbracket}}
% Space for function application. Between \; and \:.
\newcommand\<{\mskip 4mu plus 4mu minus 1mu}
\renewcommand\<\;
\newcommand\fnspace{\;}
\newcommand\fnof[1]{\fn{#1}.\fnspace}
\newcommand\setfor[2]{\ensuremath{\{#1 \mathrel{|} #2\}}}

\newcommand\quantcolor\relax
%\renewcommand\quantcolor{\color{green}}
\newcommand\quantifierspace{\ }
%\renewcommand\quantifierspace{\ \,}
\newcommand\quantify[1]{({\quantcolor #1})\quantifierspace}
\newcommand\fa[1]{\quantify{\forall #1}}
\newcommand\ex[1]{\quantify{\exists #1}}
\newcommand\faex[2]{\quantify{\forall #1, \exists #2}}
%% \renewcommand\fa[1]{\forall({\quantcolor #1})\quantifierspace}
%% \renewcommand\ex[1]{\exists({\quantcolor #1})\quantifierspace}

\newcommand\subst[2]{{#1}\<\{{#2}\}}
% discrete substitution
\newcommand\substd[2]{\subst{#1}{\isocolor #2}}
\newcommand\substo\mapsto

%% various marked equalities.
\newcommand\stareq{\overset{\boldsymbol\star}{=}}
\newcommand\daggereq{\overset{\dagger}{=}}
\newcommand\stardaggereq{\overset{\boldsymbol\star\dagger}{=}}


%% ===== Semantic and categorical notation =====
\newcommand\iso{{\texorpdfstring{\ensuremath{\square}}{box}}}

\newcommand\cat\textbf
\newcommand\Poset{\cat{Poset}}
\newcommand\initobj{0}
\newcommand\termobj{1}
\newcommand\expto\Rightarrow
\newcommand\then\cdot
\newcommand\catC{\ensuremath{\mathcal{C}}}
\newcommand\id{\name{id}}


%% ===== Datafun syntax =====
\newcommand\tset[1]{\{{#1}\}}
\newcommand\tbool{2}
\newcommand\tunit{1}
\newcommand\tseteq[1]{\tset{\eqt{#1}}}

\newcommand\kw\textbf
\newcommand\prim\name
\newcommand\caseto\shortrightarrow
\newcommand\pwild{\underline{\phantom{a}}}

\newcommand\dvar[1]{{\isocolor #1}}
% I need to mark discrete vs. monotone variables in some
% colorblind/greyscale-printing-safe way. For example:
\renewcommand\dvar[1]{{\isocolor\mathit{#1}}}
%\renewcommand\dvar[1]{{\isocolor\underline{#1}}}
%\renewcommand\dvar[1]{{\isocolor\boldsymbol{#1}}}

% FIXME TODO: However, now I need to go through every place I bind discrete
% variables and make sure it uses \dvar. Every use of \efor, \elet{\ebox...},
% some uses of \ecase, etc.

\newcommand\eqt[1]{\underaccent{\textmd{eq}}{#1}}
\providecommand\fint{}
\renewcommand\fint[1]{\underaccent{\textmd{fin}}{#1}}
\newcommand\acct[1]{\underaccent{\textmd{acc}}{#1}}
\newcommand\fixt[1]{\underaccent{\textmd{fix}}{#1}}

\newcommand\elet[1]{\kw{let}\;{#1}\;\kw{in}\;}
\newcommand\etuple[1]{\langle{#1}\rangle}
\newcommand\Etuple[1]{\left\langle{#1}\right\rangle}
\newcommand\ecase[1]{\kw{case} \;{#1}\; \kw{of}\;}
\newcommand\efix{\prim{fix}\<}
\newcommand\esplit{\prim{split}\<}
\newcommand\isempty{\prim{empty?}}
\newcommand\eisempty[1]{\isempty\<{\isocolor #1}}
\newcommand\fastfix{\prim{semifix}}
\newcommand\eboxvar[1]{\ebox{\dvar{#1}}}
\newcommand\eletbox[2]{\elet{\eboxvar{#1} = {#2}}}

% discrete operators with & without \isocolor
\newcommand\esetraw[1]{\{{#1}\}}
\newcommand\eboxraw[1]{[{#1}]}
\newcommand\eforraw[1]{\kw{for}\:({#1})\fnspace}
\newcommand\eeqraw[2]{{#1} = {#2}}
\newcommand\eifraw[2]{\kw{if}\;{#1}\;\kw{then}\;{#2}\;\kw{else}\;}
\newcommand\eset[1]{\esetraw{\isocolor #1}}
\newcommand\ebox[1]{\eboxraw{\isocolor #1}}
\newcommand\efor[2]{\eforraw{\dvar{#1} \in #2}}
\newcommand\eeq[2]{\eeqraw{\isocolor #1}{\isocolor #2}}
\newcommand\eif[2]{\eifraw{\isocolor #1}{#2}}

%% more surface syntax
\newcommand\efixis[1]{\kw{fix}~#1~\kw{is}\fnspace}
\newcommand\ewhen[1]{\kw{when}\:({#1})\fnspace}
\newcommand\etrue{\prim{true}}
\newcommand\efalse{\prim{false}}


%% ===== Contexts and typing judgments =====
\newcommand\emptycx{\varepsilon}
%\newcommand\J[3]{{#1} \mathrel{\,:\,} {#2} \vdash {#3}}
\newcommand\J[3]{{#2} \vdash {#1} \mathrel{:} {#3}}
\newcommand\Jalign[3]{{#2} &\vdash {#1} \mathrel{:} {#3}}
\newcommand\h[2]{{#1} : {#2}}
\newcommand\freshvar[1]{{\color{Rhodamine}#1}}
\newcommand\hd[2]{\dvar{#1} \dblcolon {#2}}


%% ===== Change theory & seminaive translation stuff =====
\newcommand\dummy{\name{dummy}}
\newcommand\zero{\ensuremath{\boldsymbol 0}}

\newcommand\changesto\leadsto
\newcommand\changescolon\dblcolon
%% \renewcommand\changesto\shortrightarrow
%% \renewcommand\changescolon{:}
\newcommand\changesat[4]{{#2} \changescolon_{#1} {#3} \changesto {#4}}
\newcommand\changes[3]{{#1} \changescolon {#2} \changesto {#3}}
%\renewcommand\changesat[4]{\changes{#2}{#3}{#4} : {#1}}

\newcommand\Deriv\delta
%\newcommand\Deriv{\mathscr{D}}
%\DeclareMathOperator\Deriv{\mathscr{D}}
%\DeclareMathOperator\Deriv{\mathscr{Derive}}
%\renewcommand\Deriv{\mathscr{Derive}\:}
