\section{Implementation and Optimization}
\label{sec:implementation}

\newcommand\rewrites\leadsto

To test whether the $\phi$ translation can produce the asymptotic performance
gains we claim, we have implemented a compiler from a fragment of Datafun
(omitting sum types) to Haskell.
%
We use Haskell's \texttt{Data.Set} to represent Datafun sets, and
typeclasses to implement Datafun's notions of equality and semilattice types.
%
We do no query planning; relational joins, written in Datafun as nested
\kw{for}-loops, are compiled into nested loops.
%
Consequently our performance is worse than any real Datalog engine.
%
However, we do implement the $\phi$ translation, along with the following
optimizations:

\begin{itemize}
\item Propagating $\bot$; for example, rewriting $(e \vee \bot) \rewrites e$ and
  $(\efor{x}{e} \bot) \rewrites \bot$.

\item Inserting $\bot$ in place of semilattice-valued zero changes (for example,
  changes to discrete variables $\delta \dvar x$). This makes $\bot$-propagation
  more effective.

\item Recognising complex zero change expressions; for example, $\delta e \<\phi
  f \<\delta f$ is a zero change if $\delta e$ and $\delta f$ are. This allows
  more zero changes to be replaced by $\bot$, especially in higher-order code
  such as our regular expression example.
  %% TODO: does this actually make a difference?
\end{itemize}

\input{fig-seminaive-vs-naive-graph}

We benchmarked the transitive closure function \name{tc} from
\cref{sec:generic-transitive-closure}, compiled both \naive{}ly and
semi\naive{}ly (i.e. omitting or using $\phi$), against the linear graph
$\setfor{(i,i+1)}{0 \le i \le n}$. We chose transitive closure on a linear graph
because this is a best-case for semi\naive\ evaluation, with a well-understood
asymptotic speedup (discussed in \cref{sec:seminaive-and-ilc}). The results
(\cref{fig:seminaive-vs-naive-graph}) are consistent with our expectation that
$\phi$-translated code, with appropriate optimisation, can perform
asymptotically better than \naive\ evaluation. As with semi\naive\ evaluation in
Datalog, we do not expect this to generalize to all recursive programs.
\todo{discuss what kinds of problems semi\naive\ evaluation produces speedups
  on? (generally, ones which require many iterations, since \naive\ evaluation grows monotonically more expensive with more iterations.) can we cite somebody here -- maybe ``Fixing incremental computation''?}

%% TODO: Discuss when \& why inlining might be helpful.
%% We speculate that \emph{function inlining} would also be a helpful optimisation.
