\section{Implementation and Optimization}
\label{sec:implementation}

\newcommand\rewrites\leadsto

To test whether the $\phi$ translation can produce the asymptotic performance
gains we claim, we have implemented a compiler from a fragment of Datafun
(omitting sum types) to Haskell.
%
We use Haskell's \texttt{Data.Set} to represent Datafun sets, and
typeclasses to implement Datafun's notions of equality and semilattice types.
%
We do no query planning; relational joins, written in Datafun as nested
\kw{for}-loops, are compiled into nested loops.
%
Consequently our performance is worse than any real Datalog engine.
%
However, we do implement the $\phi$ translation, along with the following
optimizations:

\begin{itemize}
\item Propagating $\bot$; for example, rewriting $(e \vee \bot) \rewrites e$ and
  $(\efor{x}{e} \bot) \rewrites \bot$. %% Eliminating \kw{for}-loops generated by
  %% $\phi$ or $\delta$ whose loop bodies are $\bot$ can asymptotically improve
  %% performance.

\item Replacing lattice-valued expressions that produce zero changes (for
  example, changes to discrete variables $\delta \dvar x$) by $\bot$. This makes
  $\bot$-propagation more effective.

\item Recognising complex zero change expressions; for example, $\delta e \<\phi
  f \<\delta f$ is a zero change if $\delta e$ and $\delta f$ are. This allows
  more zero changes to be replaced by $\bot$, especially in higher-order code
  such as our regular expression example. \todo{Does \citet{incremental} discuss
    this?}
\end{itemize}

We benchmarked the transitive closure function \name{tc} from
\cref{sec:generic-transitive-closure}, compiled both \naive{}ly and
semi\naive{}ly (i.e. omitting or using $\phi$), against the linear graph
$\setfor{(i,i+1)}{0 \le i \le n}$. The results
(\cref{fig:seminaive-vs-naive-graph}) are consistent with our expectation that
$\phi$-translated code, with appropriate optimisation, can perform
asymptotically better than \naive\ evaluation.

\todo{graph!}

%% We speculate that \emph{function inlining} would also be a helpful optimisation.

\todo{Discuss when \& why inlining might be helpful.}
