\section{Datalog and Datafun by Example}
\label{sec:datalog-and-datafun}

\subsection{Datalog}

Datalog's syntax is a subset of Prolog's. Programs
are collections of predicate declarations:

\begin{minted}[]{prolog}
  parent(earendil, elrond).
  parent(elrond, arwen).
  parent(arwen, eldarion).

  ancestor(X, Z) ← parent(X, Z).
  ancestor(X, Z) ← ancestor(X, Y), parent(Y, Z).
\end{minted}

This defines two binary relations, \rel{parent} and \rel{ancestor}. Lowercase
terms like \datalog{elrond} and \datalog{arwen} are symbols \emph{a la} Lisp,
and uppercase terms like \datalog{X} and \datalog{Y} are variables.

The \rel{parent} relation declares a set of ground \emph{facts}; we assert that
\datalog{earendil} is the parent of \datalog{elrond}, \datalog{elrond} the
parent of \datalog{arwen}, and so on. The \rel{ancestor} relation is declared as
a pair of \emph{rules}, the first saying $X$ is an ancestor of $Z$ if $X$ is
$Z$'s parent, and the second saying $X$ is an ancestor of $Z$ if there is a
intermediate person $Y$ such that $X$ is $Y$'s ancestor and $Y$ is $Z$'s parent.

% In inference rule form, this program could be rendered as:
%
% \begin{mathpar}
%   \inferrule*[]
%              { }
%              { \mathsf{parent(earendil, elrond)} }
%   \and
%   \inferrule*[]
%              { }
%              { \mathsf{parent(elrond, arwen)} }
%   \and
%   \inferrule*[]
%              { }
%              { \mathsf{parent(arwen, eldarion)} }
%   \\\vspace{1em}
%   \inferrule*[]
%              { \mathsf{parent}(x, y) }
%              { \mathsf{ancestor}(x, y) }
%   \and
%   \inferrule*[]
%              { \mathsf{ancestor}(x, y) \\ \mathsf{parent}(y, z) }
%              { \mathsf{ancestor}(x, z) }
% \end{mathpar}

Semantically, a predicate denotes the set of tuples that satisfy it. Recursive
definitions can be interpreted by viewing the whole program as a relation
transformer, and taking the least fixed point of that function. Datalog imposes
syntactic restrictions which ensure the relation transformer the rules define is
monotone, guaranteeing a unique least fixed point.

\subsection{Datafun}

\input{fig-syntax}

%% Datalog makes it very easy to define relations recursively, but
%% because it is such a small and restricted language, it is not possible
%% to build abstractions over these rules. However, its semantics, given
%% in terms of least fixed points of monotone functions on relations,
%% is extremely elegant, and Datafun arose as an attempt to generalize
%% this semantics.

The idea behind Datafun is that since the semantics of a Datalog program
is a monotone set-valued operator, its natural home is the category
\Poset{} of partial orders and monotone functions. Since \Poset{} is
bicartesian closed, it can interpret the simply-typed \fn-calculus,
which gives us a notation for writing monotone and \emph{higher-order}
functions.
%
This lets us \emph{abstract} over Datalog rules, something not
possible in Datalog itself!
%
In the remainder of this section we reconstruct Datafun hewing closely
to this semantic intuition.

Datafun begins as the simply-typed \fn-calculus with functions ($\fnof
x e$ and $e\<f$), sums ($\inj i e$ and $\ecase{e}{\dots}$), and
products ($\etuple{e,f}$ and $\pi_i\<e$). To this, we add a type of
finite sets\footnote{To implement set types, their elements must
  support decidable equality. In our core calculus, we use a
  subgrammar of ``eqtypes'', and in our implementation (which compiles
  to Haskell) we use typeclass constraints to pick out such types.}
$\tset{\eqt A}$, introduced with set literals $\eset{e_0, \ldots
  e_n}$, and eliminated using Moggi's monadic bind syntax,
$\efor{x}{e_1}{e_2}$, signifying the union over all $\dvar x \in e_1$
of $e_2$.

As long as all primitives are monotone, every definable function is also
monotone. This is necessary for taking fixed points, but may seem too
restrictive. There are many essential non-monotone operations, such as equality
tests $\eeq e f$. For example, $\eset{} = \eset{}$ is true, but if the first
argument is increased to $\esetraw{1}$ then it becomes false, a \emph{decrease}
(in Datafun, $\efalse < \etrue$).

How can we express non-monotone operations while preserving the property that
all functions are monotone? We square this circle by introducing the
\emph{discreteness} type constructor $\iso A$. The elements of $\iso A$ are
\emph{exactly the same} as the elements of $A$, but the order on $\iso A$ is
discrete, $x \le y : \iso A$ iff $x = y$. Monotonicity of a function $\iso A \to
B$ is vacuous: $x = y$ always implies $f(x) \le f(y)$! This lets us encode
ordinary, possibly non-monotone, functions $A \to B$ as monotone functions $\iso
A \to B$. Semantically, $\iso$ is a comonad, and accordingly the syntax we use
for this is a variant of \citet{jrml}'s syntax for constructive S4 modal logic.
We make discrete terms with the introduction form $\ebox{e}$ and eliminate them
with a pattern matching eliminator $\eletbox x e f$. Discrete variables are
colored and italicised $\dvar x$, while monotone variables are uncolored and
upright $x$. Colored terms $\isocolor e$ are restricted to only refer to
discrete variables. So in the equality test $\eeq e f$, the terms $e$ and $f$
must be discrete.

%% TODO: should we note that we really definitely mean □(L → L) and
%% not (□L → L)? Reader may be confused.
Finally, Datafun includes fixed points, $\efix{e}$. The $\prim{fix}$ combinator
takes a function $\iso (\fixt L \to \fixt L)$ and returns its least fixed point.
We impose two restrictions on the fixed point operator to ensure
well-definedness and termination. First, we require that recursion occur at
\emph{semilattice types}, $L$. A join-semilattice is a partial order with a
least element $\bot$ and a least-upper-bound (``join'') operation $\vee$. Finite
sets (with the empty set as least element, and union as join) are an example, as
are tuples of semilattices. As long as the lattice has no infinite ascending
chains, recursion from the bottom element is guaranteed to find the least fixed
point.

%% TODO: ``at box type'' is ambiguous. makes me think of (□A → B)
%% rather than □(A → B).
Second, we require that the recursive function be boxed,
${\color{Rhodamine}\iso}(\fixt L \to \fixt L)$. Since boxed expressions can only
refer to discrete values, and fixed point functions themselves must be monotone,
this has the effect of preventing semantically nested fixed points. We discuss
this in more detail in \cref{sec:nested-fixed-points}. Note that this does
\emph{not} prevent mutual recursion, which can be expressed by taking a fixed
point at product type, nor stratified fixed points \emph{\`a la} Datalog.

%% This blocks (semantically) nested fixed points,
%% and leaves the semantics of Datafun close to that of Datalog, where all
%% recursion happens once, at the level of the whole program.


\subsection{Examples of Datafun Programs}

\input{fig-sugar}

In the examples, we make free use of strings and integers, ordered discretely
($x \le y$ iff $x = y$). We also make use of some syntax sugar in the
definitions:

\begin{enumerate}
\item First, we make free use of curried functions and pattern
  matching. Desugaring these is relatively standard, and so we will
  say little about it, with one exception. Namely, the box-elimination
  form $\eletbox x e e'$ is a pattern matching form, and so we allow
  it to occur inside of patterns. The effect of a box pattern
  $\ebox{p}$ is to ensure that all of the variables bound in the
  pattern $p$ are treated as discrete variables.

\item We mentioned earlier that Datafun's boolean type $\tbool$ is ordered
  $\efalse < \etrue$. This is because we encode booleans as sets of empty
  tuples, $\tset 1$, with $\efalse$ being the empty set $\eset{}$ and $\etrue$
  being the singleton $\esetraw{\etuple{}}$. At semilattice type we also permit
  a ``one-sided'' conditional test, $\ewhen{b}{e}$, which yields $e$ if $b$ is
  \etrue\ and $\bot$ otherwise. Encoding booleans as sets has the advantage that
  $\ewhen{b}{e}$ is monotone in the condition $b$.

\item Finally, we make use of set comprehension notation. The
  desugaring we use is based on the translation of comprehensions to
  the monadic operators~\cite{wadler-monad-comprehensions}.
\end{enumerate}
We summarize (except for pattern matching) the sugaring rules we use in
\cref{fig:sugar}.

\subsubsection{Set\, Operations}

Even before higher-order functions, one of the main benefits of
Datafun relative to Datalog is that it offers the ability to manipulate relations
as first class values. In this subsection we will show how a variety
of standard operations on sets can be represented in Datafun.

\paragraph{Membership Tests} The first operation we consider is the
membership test operation.
\begin{tabbing}
  \qquad\=\+ \kill
  $\name{mem} : \iso A \to \tset A \to \tbool$ \\
  $\name{mem}\;\ebox{x} \; \mathvar{ys} = \efor{y}{\mathvar{ys}} \dvar x = \dvar y$
\end{tabbing}

\noindent
This checks if the input $\dvar x$ is equal to any $\dvar y \in \mathvar{ys}$.
The argument $x$ to $\name{mem}$ is discrete, because an element is in a set or
not -- the test is not monotone in $x$.

\paragraph{Set Intersection}
Using $\name{mem}$, it is possible to define set intersection, by taking the union of
all the singleton sets $\eset{x}$ sets where $x$ is an element of $xs$ also in the set $ys$.

\begin{tabbing}
  \qquad\=\+ \kill
  $\_ \wedge \_ : \tset A \to \tset A \to \tset A$ \\
  $\var{xs} \wedge \var{ys} = \efor{x}{xs}
  \ewhen{\name{mem}\;\eboxvar{x}\;\var{ys}}{\eset{\dvar x}}$
\end{tabbing}

\noindent
Using comprehensions, this could alternately be written as:
\begin{tabbing}
  \qquad\=\+ \kill
  $\var{xs} \wedge \var{ys} = \esetfor{x}{\dvar x \in \var{xs},\, \name{mem}\;\eboxvar{x}\;\var{ys}}$
\end{tabbing}

\paragraph{Relational Composition}
We can also define the composition of two relations in Datafun.
\begin{tabbing}
  \qquad\=\+ \kill
  $\_ \bullet \_$ \quad\:\= $\,:$\;\; \=
  $ \tset{A \times B} \to \tset{B \times C} \to \tset{A \times C}$ \\

  $\mathvar{xs} \bullet \mathvar{ys}$
  \> $=$ \> $\eforraw{\etuple{\dvar a,\dvar b} \in \mathvar{xs}}
  \eforraw{\etuple{\dvar{b'}, \dvar c} \in \mathvar{ys}}
  \ewhen{\dvar b = \dvar{b'}} \esetraw{\etuple{\dvar a,\dvar c}}
  $
  %% \\
  %% \>     \> $\efor{(b',c)}{\mathit{ys}}{}$ \\
  %% \>     \> $\ewhen{b = b'}{\eset{(a,c)}}$
\end{tabbing}
This is basically a transcription of the mathematical definition, where we build
those pairs which agree on their $B$-typed components. It can also be written using
set comprehension as:
\begin{tabbing}
  \qquad\=\+ \kill
  $\_ \bullet \_$ \;\;\;\= $\,:$\;\; \=
  $ \tset{A \times B} \to \tset{B \times C} \to \tset{A \times C}$ \\

  $\var{xs} \bullet \var{ys} =
  \setfor{\etuple{\dvar a, \dvar c}}{
    \etuple{\dvar a, \dvar b} \in \var{xs},
    \etuple{\dvar{b'}, \dvar c} \in \var{ys}, \dvar b = \dvar{b'}}$
\end{tabbing}

\paragraph{Transitive Closure}\label{sec:generic-transitive-closure}
Now, we define the transitive closure of a relation.
\begin{tabbing}
  \qquad\=\+ \kill
  $\name{tc}$ \quad\: \= $\,:$ \;\;\= $\iso{\tset{A \times A}} \to \tset{A \times A}$ \\
  $\name{tc}\;\eboxvar{e}$ \> $=$ \>
  $\efixis{\var{s}}{\dvar{e} \vee (\dvar{e} \bullet \var{s})}$
\end{tabbing}

This definition uses recursion, just like the mathematical definition --
a transitive closure is the least relation containing the original relation $\name{xs}$
and the composition of $\name{xs}$ with the transitive closure. However, one
feature of this definition peculiar to core Datafun is that the argument type
is $\iso \tset{A \times A}$ -- the transitive closure takes a \emph{discrete} relation.
This is because we must use the relation within the fixed point, and so its parameter needs
to be discrete to occur within.


\subsubsection{Combinators for Regular Expression Matching}

\newcommand\tre{\typename{re}}

Datafun permits tightly integrating the higher-order functional and
bottom-up logic programming styles. In this section, we illustrate the
benefits of doing so by showing how to implement a regular expression
matching library in combinator parsing style.  Like combinator parsers
in functional languages, the code is very concise.  However, support
for the relational style ensures we can write \naive\ code
\emph{without} the exponential backtracking cliffs typical of parser
combinators in functional languages.

We assume the existence of a function $\name{pos} : \tstring \to \tset{\tint}$
which takes a string and returns the set of valid indices in that string, and
assume that string indexing is written $s[n]$, as in Java or C. Having done
this, we define the type of regular expression matchers.

\begin{tabbing}
\qquad  $\kw{type}\;\tre\;=\iso \tstring \to \tset{\tint \times \tint}$
\end{tabbing}

A regular expression takes a string (boxed so that it can be used inside fixed
point expressions), and returns a set of pairs of integers. The idea is that if
the regular expression matcher is passed the string argument $s$, then if $(i,
n)$ is one of the returned values, the substring $s_i, s_{i+1}, \ldots, s_{n-1}$
is matched by the regular expression. That is, it is inclusive on the left and
exclusive on the right.

\begin{tabbing}
\qquad \= $\name{sym} : \typename{char} \to \tre$ \+\\
$\name{sym}\;c\;\ebox{s} =\; $\= $\efor{n}{\name{pos}\;s}{\ewhen{s[n] = c}{\eset{(n, n+1)}}}$
\end{tabbing}
The $\name{sym}$ combinator takes a character and returns a set of
substrings by returning the set $(n, n+1)$ where the $n$-th element of
the string $s$ is the character $c$.
%
\begin{tabbing}
\qquad \=   $\name{nil} : \tre$ \+\\
  $\name{nil}\;\ebox{s} = \efor{n}{\name{pos}\;s}{\eset{(n,n)}}$
\end{tabbing}
%
The call $\name{nil}\;\ebox{s}$ yields $(n,n)$ for each position
$n$ in $s$, since an empty substring can start anywhere.
%
\begin{tabbing}
\qquad \=   $\name{seq} : \tre \to \tre \to \tre$ \+\\
  $\name{seq}\;r_1\;r_2\;s = r_1\;s \bullet r_2\;s$
\end{tabbing}
%
The $\name{seq}$ combinator takes two regular expressions $r_1$ and $r_2$
as arguments, applies its argument to both, and takes the relational
composition of the results. Therefore, if the range $(i,j)$ was in the
result of $r_1$, and $(j,k)$ was in the result of $r_2$, then
we will return $(i,k)$, just as desired.
%
\begin{tabbing}
\qquad \=   $\name{bot} : \tre$ \+\\
  $\name{bot}\;\_ = \bot$ \\[1em]

  $\name{alt} : \tre \to \tre \to \tre$ \\
  $\name{alt}\;r_1\;r_2\;s = r_1\;s \vee r_2\;s$
\end{tabbing}
%
We get the empty set of matches from $\name{bot}$, and
$\name{alt}$ unions the matches of its two arguments.
%
\begin{tabbing}
\qquad \=   $\name{star} : \iso\tre \to \tre$ \+\\
  $\name{star}\;\ebox{r}\;\ebox{s} = \name{nil}\;\ebox{s} \vee \name{tc}\;\ebox{r\;\ebox{s}}$
\end{tabbing}
The most interesting regular expression combinator is the Kleene star
operation $\name{star}$.  It uses $\name{nil}$ to get the
reflexive relation on positions, and then takes the transitive closure
of the regular expression it received as an argument using the
$\name{tc}$ operation. This forces its argument to be boxed, since
$\name{tc}$ calculates a fixed point, and only discrete variables can
occur inside of fixed point expressions.\footnote{As a technical note,
  sets of pairs of integers do not form a finite-height lattice, so by
  typing this program is not an acceptable fixed point expression.
  However, since the positions in a string form a finite set,
  semantically it is fine. The original Datafun paper shows how one can
  define bounded fixed points to handle cases like this, so we will not be
  scrupulous.}



\subsubsection{Combinators for Regular Expression Matching, Take 2}

The combinators in the previous section found \emph{all} matches
within a given substring, but often we are not interested in all
matches: we only want to know if a string can match starting at a
particular location. We can easily refactor the combinators above to
work in this style, which illustrates the benefits of tightly
integrating functional and relational styles of programming -- we can
use functions to manage strict input/output divisions, and relations
to manage nondeterminism and search.
%
\begin{tabbing}
\qquad \=  $\kw{type}\;re\;=\iso (\tstring \times \tint) \to \tset{\tint}$ \+
\end{tabbing}
%
Our new type of combinators takes a string and a starting
position, and returns a set of ending positions. In contrast, the earlier type
took a string and returned a set of start/end pairs.
%
\begin{tabbing}
\qquad \=  $\name{sym} : \typename{char} \to \tre$\+ \\
  $\name{sym}\;c\;\ebox{s,n} = \ewhen{s[n] = c}{\eset{n+1}}$
\end{tabbing}
%
$\name{sym}\;c$ checks if $c$ occurs at position
$n$, returning $n+1$ if it does, and the empty
set otherwise.
%
\begin{tabbing}
\qquad \=  $\name{nil} : \tre$\+ \\
  $\name{nil}\;\ebox{s, n} = \eset{n}$ \\[1em]

  $\name{seq} : \tre \to \tre \to \tre$ \\
  $\name{seq}\;r_1\;r_2\;\ebox{s,n} = \efor{m}{r_1\;\ebox{s,n}}{r_2\;[s,m]}$
\end{tabbing}
%
The $\name{nil}$ function simply returns the same index $n$ it received as an
argument, since an empty string matches starting from any position. Sequencing
via $\name{seq}\;r_1\;r_2$ checks first to see the possible ending positions from
matching $r_1$, and carries on with $r_2$ from there.
%
\begin{tabbing}
  \qquad \=
  $\name{bot} : \tre$ \+\\
  $\name{bot}\;\_ = \bot$ \\[1em]

  $\name{alt} : \tre \to \tre \to \tre$ \\
  $\name{alt}\;r_1\;r_2\;\ebox{s,n} =\ x = r_1\;x \vee r_2\;x$
\end{tabbing}
%
We still get the empty set from $\name{bot}$, and $\name{alt}$
still unions the two sets of end positions.
%
\begin{tabbing}
\qquad \=  $\name{star} : \iso\tre \to \tre$\+ \\
  $\name{star}\;\ebox{r}\;\ebox{s, n} = \efixis{\name{self}}{\eset{n} \vee
                                                \efor{m}{\name{self}}{r\;\ebox{s,m}}}$
\end{tabbing}
%
As before, the $\name{star}$ combinator takes a boxed regular expression as an argument,
and for the same reason -- we are implementing sequencing with a fixed point. One thing
worth noting about this definition is that it is \emph{left-recursive} -- the definition
takes the endpoints from the fixed point $\name{self}$, and then continues matching using
the argument $\name{r}$. This should make clear that this is not just plain old functional
programming -- we are genuinely relying upon the fixed point semantics of Datafun.
