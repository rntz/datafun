\section{Datalog and Datafun}
\label{sec:datalog-and-datafun}

n this section, we explain how Datalog works by example, and then explain
how Datafun works by porting and then generalising these examples. 

\subsection{Datalog}

The syntax of Datalog is a subset of Prolog's syntax. Programs
consist of collections of predicate declarations, as follows:
\begin{minted}[]{prolog}
parent(earendil, elrond).
parent(elrond, arwen).
parent(arwen, eldarion).

ancestor(X, Z) ← parent(X, Z).
ancestor(X, Z) ← ancestor(X, Y), parent(Y, Z).
\end{minted}

In this example, we define two binary relations, \datalog{parent(_,_)}
and \datalog{ancestor(_,_)}. Lowercase terms like \datalog{elrond} and
\datalog{arwen} are symbols \emph{a la} Lisp, and uppercase terms like
\datalog{X} and \datalog{Y} are variables.

The \datalog{parent(_, _)} relation declares a relation as a set of
ground \emph{facts}; we explicitly assert that \datalog{earendil} is
the parent of \datalog{elrond}, and \datalog{elrond} the parent of
\datalog{arwen}, and so on. Then, the ancestor relation is declared as
a pair of potentially recursive \emph{rules}, the first asserting that
$X$ is an ancestor of $Z$ if $X$ is $Z$'s parent, and the second
asserting that $X$ is an ancestor of $Z$ if there is a third person
$Y$, such that $X$ is $Y$'s ancestor and $Y$ is $Z$'s parent. In
inference rule form, this program could be rendered as:

\begin{mathpar}
  \inferrule*[]
             { }
             { \mathsf{parent(earendil, elrond)} }
  \and
  \inferrule*[]
             { }
             { \mathsf{parent(elrond, arwen)} }
  \and
  \inferrule*[]
             { }
             { \mathsf{parent(arwen, eldarion)} }
  \\\vspace{1em}
  \inferrule*[]
             { \mathsf{parent}(x, y) }
             { \mathsf{ancestor}(x, y) }
  \and
  \inferrule*[]
             { \mathsf{ancestor}(x, y) \\ \mathsf{parent}(y, z) }
             { \mathsf{ancestor}(x, z) }
\end{mathpar}

Semantically, each predicate can be interpeted as the set of tuples
which satisfy the predicate. Recursive definitions can be interpreted
by seeing the whole program as a function from relations to relations,
and then taking the least fixed point of that function. The syntax of
Datalog is such that the relation transformer the rules define is
always a monotone function on sets, and so this least fixed point
always exists.

\subsection{Datafun}

Datalog makes it very easy to define relations recursively, but
because it is such a small and restricted language, it is not possible
to build abstractions over these rules.  The mathematical observation
that led to the generalization of Datafun is that the semantics of a
Datalog program is the fixed point of a monotone function on
relations, and the category Poset of partial orders and monotone maps
is cartesian closed. So we can build a language in the following
sequence of steps:

\begin{enumerate}
\item We begin with the simply-typed lambda calculus including sums
  and products.
\item We add a type of finite sets $\tset{\eqt A}$.
\item Next, we add a comonadic type $\iso A$, denoting the same elements
  as $A$, but whose partial order is just the equality.
\item Finally, we add a fixed-point operator $\mathit{fix} : \Box(L \to L) \to L$. 
\end{enumerate}





\input{fig-syntax}
