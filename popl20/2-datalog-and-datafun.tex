\section{Datalog and Datafun by Example}
\label{sec:datalog-and-datafun}

\subsection{Datalog}

Datalog's syntax is a subset of Prolog's. Programs are collections of predicate
declarations:

\newcommand\datum[1]{\textsf{#1}}

\begin{code}
  \name{parent}(\datum{aerys}, \datum{rhaegar})\\
  \name{parent}(\datum{rhaegar}, \datum{jon})\\
  \name{parent}(\datum{lyanna}, \datum{jon})\hspace{30em}
  \\[6pt]
  \name{ancestor}(X,Z) \gets \name{parent}(X,Z)\\
  \name{ancestor}(X,Z) \gets \name{parent}(X,Y) \wedge \name{ancestor}(Y,Z)
\end{code}

\noindent
This defines two binary relations, \name{parent} and \name{ancestor}. Lowercase
sans-serif words like \datum{rhaegar} and \datum{lyanna} are symbols \emph{\`a
  la} Lisp, and uppercase characters like $X$ and $Y$ are variables.

The \name{parent} relation is defined as a set of ground facts: we assert that
\datum{aerys} is \datum{rhaegar}'s parent, that \datum{rhaegar} is \datum{jon}'s
parent, and so on. The \name{ancestor} relation is defined by a pair of rules:
first, that $X$ is $Z$'s ancestor if $X$ is $Z$'s parent; second, that $X$ is
$Z$'s ancestor if $X$ has a child $Y$ who is an ancestor of $Z$.

Semantically, a predicate denotes the set of tuples that satisfy it. Recursive
definitions like \name{ancestor} can be interpreted by viewing the whole program
as a relation transformer, and taking the least fixed point of that function.
Datalog imposes syntactic restrictions which ensure the relation transformer the
rules define is monotone, guaranteeing a unique least fixed point.

\subsection{Datafun}

\input{fig-syntax}

%% Datalog makes it very easy to define relations recursively, but
%% because it is such a small and restricted language, it is not possible
%% to build abstractions over these rules. However, its semantics, given
%% in terms of least fixed points of monotone functions on relations,
%% is extremely elegant, and Datafun arose as an attempt to generalize
%% this semantics.

The idea behind Datafun is that since the semantics of a Datalog program
is a monotone set-valued operator, its natural home is the category
\Poset{} of partial orders and monotone functions. Since \Poset{} is
bicartesian closed, it can interpret the simply-typed \fn-calculus,
which gives us a notation for writing monotone and \emph{higher-order}
functions.
%
This lets us \emph{abstract} over Datalog rules, something not
possible in Datalog itself!
%
In the remainder of this section we reconstruct Datafun hewing closely
to this semantic intuition.

Datafun begins as the simply-typed \fn-calculus with functions ($\fnof x e$ and
$e\<f$), sums ($\inj i e$ and $\ecase{e}{\dots}$), and products ($\etuple{e,f}$
and $\pi_i\<e$). To this, we add a type of finite sets\footnote{To implement set
  types, their elements must support decidable equality. In our core calculus,
  we use a subgrammar of ``eqtypes'', and in our implementation (which compiles
  to Haskell) we use typeclass constraints to pick out such types.} $\tset{\eqt
  A}$, introduced with set literals $\eset{e_0, \ldots e_n}$, and eliminated
using Moggi's monadic bind syntax, $\efor{x}{e_1}{e_2}$, signifying the union
over all $\dvar x \in e_1$ of $e_2$.

As long as all primitives are monotone, every definable function is also
monotone. This is necessary for taking fixed points, but may seem too
restrictive. There are many essential non-monotone operations, such as equality
tests $\eeq e f$. For example, $\esetraw{} = \esetraw{}$ is true, but if the
first argument is increased to $\esetraw{1}$ then it becomes false, a
\emph{decrease} (in Datafun, $\efalse < \etrue$).

How can we express non-monotone operations while preserving the property that
all functions are monotone? We square this circle by introducing the
\emph{discreteness} type constructor $\iso A$. The elements of $\iso A$ are
exactly the same as those of $A$, but the order on $\iso A$ is discrete, $x \le
y : \iso A$ iff $x = y$. Monotonicity of a function $\iso A \to B$ is vacuous:
$x = y$ always implies $f(x) \le f(y)$! This lets us encode ordinary, possibly
non-monotone, functions $A \to B$ as monotone functions $\iso A \to B$.
Semantically, $\iso$ is a comonad, and accordingly the syntax we use for this is
a variant of \citet{jrml}'s syntax for constructive S4 modal logic. We make
discrete terms with the introduction form $\ebox{e}$ and eliminate them with a
pattern matching eliminator $\eletbox x e f$. Discrete variables are colored and
italicised $\dvar x$, while monotone variables are uncolored and upright $x$.
\todo{Colored terms $\isocolor e$ are restricted to only refer to discrete
  variables.} So in the equality test $\eeq e f$, the terms $e$ and $f$ must be
discrete.

%% TODO: should we note that we really definitely mean □(L → L) and
%% not (□L → L)? Reader may be confused.
Finally, Datafun includes fixed points, $\efix{e}$. The $\prim{fix}$ combinator
takes a function $\iso (\fixt L \to \fixt L)$ and returns its least fixed point.
We impose two restrictions on the fixed point operator to ensure
well-definedness and termination. First, we require that recursion occur at
\emph{semilattice types}, $L$. A join-semilattice is a partial order with a
least element $\bot$ and a least-upper-bound (``join'') operation $\vee$. Finite
sets (with the empty set as least element, and union as join) are an example, as
are tuples of semilattices. As long as the lattice has no infinite ascending
chains, recursion from the bottom element is guaranteed to find the least fixed
point.

%% TODO: ``at box type'' is ambiguous. makes me think of (□A → B)
%% rather than □(A → B).
Second, we require that the recursive function be boxed,
$\iso(\fixt L \to \fixt L)$. Since boxed expressions can only
refer to discrete values, and fixed point functions themselves must be monotone,
this has the effect of preventing semantically nested fixed points. We discuss
this in more detail in \cref{sec:nested-fixed-points}. Note that this does
\emph{not} prevent mutual recursion, which can be expressed by taking a fixed
point at product type, nor stratified fixed points \emph{\`a la} Datalog.

%% This blocks (semantically) nested fixed points,
%% and leaves the semantics of Datafun close to that of Datalog, where all
%% recursion happens once, at the level of the whole program.


\subsection{Examples of Datafun Programs}

\input{fig-sugar}

In the examples, we make free use of strings and integers, ordered discretely
($x \le y$ iff $x = y$). We also make use of some syntax sugar in the
definitions:

\begin{enumerate}
\item First, we make free use of curried functions and pattern
  matching. Desugaring these is relatively standard, and so we will
  say little about it, with one exception. Namely, the box-elimination
  form $\eletbox x e e'$ is a pattern matching form, and so we allow
  it to occur inside of patterns. The effect of a box pattern
  $\pbox{\isocolor p}$ is to ensure that all of the variables bound in the
  pattern $\isocolor p$ are treated as discrete variables.

\item We mentioned earlier that Datafun's boolean type $\tbool$ is ordered
  $\efalse < \etrue$. This is because we encode booleans as sets of empty
  tuples, $\tset 1$, with $\efalse$ being the empty set $\esetraw{}$ and
  $\etrue$ being the singleton $\esetraw{\etuple{}}$. At semilattice type we
  also permit a ``one-sided'' conditional test, $\ewhen{b}{e}$, which yields $e$
  if $b$ is \etrue\ and $\bot$ otherwise. Encoding booleans as sets has the
  advantage that $\ewhen{b}{e}$ is monotone in the condition $b$.

\item Finally, we make use of set comprehension notation. The
  desugaring we use is based on the translation of comprehensions to
  the monadic operators~\cite{wadler-monad-comprehensions}.
\end{enumerate}
We summarize (except for pattern matching) the sugaring rules we use in
\cref{fig:sugar}.

\subsubsection{Set\, Operations}

Even before higher-order functions, one of the main benefits of
Datafun relative to Datalog is that it offers the ability to manipulate relations
as first class values. In this subsection we will show how a variety
of standard operations on sets can be represented in Datafun.

\paragraph{Membership Tests} The first operation we consider is the
membership test operation.
\begin{tabbing}
  \qquad\=\+ \kill
  $\name{mem} : \iso A \to \tset A \to \tbool$ \\
  $\name{mem} \;\pboxvar{x} \;\var{ys} = \efor{y}{\var{ys}} \eeq{\dvar x}{\dvar y}$
\end{tabbing}

\noindent
This checks if the input $\dvar x$ is equal to any $\dvar y \in \var{ys}$. The
argument $x$ to $\name{mem}$ is discrete, because an element is in a set or not
-- the test is not monotone in $\dvar x$.

\paragraph{Set Intersection}
Using $\name{mem}$, it is possible to define set intersection, by taking the
union of all the singleton sets $\esetraw{\dvar x}$ where $\dvar x$ is an
element of both $\var{xs}$ and $ys$.

\begin{tabbing}
  \qquad\=\+ \kill
  $\_ {\cap} \_ : \tset A \to \tset A \to \tset A$ \\
  $\var{xs} \cap \var{ys} = \efor{x}{xs}
  \ewhen{\name{mem}\;\eboxvar{x}\;\var{ys}}{\eset{\dvar x}}$
\end{tabbing}

\noindent
Using comprehensions, this could alternately be written as:
\begin{tabbing}
  \qquad\=\+ \kill
  $\var{xs} \cap \var{ys} = \esetfor{x}{\dvar x \in \var{xs},\, \name{mem}\;\eboxvar{x}\;\var{ys}}$
\end{tabbing}

\paragraph{Relational Composition}
We can also define the composition of two relations in Datafun.

\begin{tabbing}
  \qquad\=\+ \kill
  $\_ {\bullet} \_$ \quad\quad\= $\,:$\;\; \=
  $ \tset{A \times B} \to \tset{B \times C} \to \tset{A \times C}$ \\

  $\var{xs} \mathrel{\bullet} \var{ys}$
  \> $=$ \> $\eforraw{\etuple{\dvar a,\dvar b} \in \var{xs}}
  \eforraw{\etuple{\dvar{b'}, \dvar c} \in \var{ys}}
  \ewhen{\eeq{\dvar b}{\dvar{b'}}} \eset{\etuple{\dvar a,\dvar c}}
  $
  %% \\
  %% \>     \> $\efor{(b',c)}{\mathit{ys}}{}$ \\
  %% \>     \> $\ewhen{b = b'}{\eset{(a,c)}}$
\end{tabbing}

\noindent
This is basically a transcription of the mathematical definition, where we build
those pairs which agree on their $B$-typed components. It can also be written
using set comprehension as:

\begin{tabbing}
  \qquad\=\+ \kill
  $\_ \bullet \_$ \;\;\;\= $\,:$\;\; \=
  $ \tset{A \times B} \to \tset{B \times C} \to \tset{A \times C}$ \\

  $\var{xs} \bullet \var{ys} =
  \esetfor{\etuple{\dvar a, \dvar c}}{
    \etuple{\dvar a, \dvar b} \in \var{xs},
    \etuple{\dvar{b'}, \dvar c} \in \var{ys}, \eeq{\dvar b}{\dvar{b'}}}$
\end{tabbing}

\paragraph{Transitive Closure}\label{sec:generic-transitive-closure}
Now, we define the transitive closure of a relation.
\begin{tabbing}
  \qquad\=\+ \kill
  $\name{trans}$ \quad\: \= $\,:$ \;\;\= $\iso{\tset{A \times A}} \to \tset{A \times A}$ \\
  $\name{trans} \;\pboxvar{e}$ \> $=$ \>
  $\efixis{s}{\dvar{e} \vee (\dvar{e} \bullet s)}$
\end{tabbing}

This definition uses recursion, just like the mathematical definition --
a transitive closure is the least relation containing the original relation $\name{xs}$
and the composition of $\name{xs}$ with the transitive closure. However, one
feature of this definition peculiar to core Datafun is that the argument type
is $\iso \tset{A \times A}$ -- the transitive closure takes a \emph{discrete} relation.
This is because we must use the relation within the fixed point, and so its parameter needs
to be discrete to occur within.


\subsubsection{Combinators for Regular Expression Matching}
\label{sec:regex-combinators}

\newcommand\tre{\typename{re}}

Datafun permits tightly integrating the higher-order functional and
bottom-up logic programming styles. In this section, we illustrate the
benefits of doing so by showing how to implement a regular expression
matching library in combinator parsing style.  Like combinator parsers
in functional languages, the code is very concise.  However, support
for the relational style ensures we can write \naive\ code
\emph{without} the exponential backtracking cliffs typical of parser
combinators in functional languages.

We assume the existence of a function $\name{pos} : \tstring \to \tset{\tint}$
which takes a string and returns the set of valid indices in that string, and
assume that string indexing is written $s[n]$, as in Java or C. Having done
this, we define the type of regular expression matchers.

\begin{tabbing}
\qquad  $\kw{type}\;\tre\;=\iso \tstring \to \tset{\tint \times \tint}$
\end{tabbing}

A regular expression takes a string (boxed so that it can be used inside fixed
point expressions), and returns a set of pairs of integers. The idea is that if
the regular expression matcher is passed the string argument $s$, then if
$\etuple{i,n}$ is one of the returned values, the substring $s_i, s_{i+1},
\ldots, s_{n-1}$ is matched by the regular expression. That is, it is inclusive
on the left and exclusive on the right.

\begin{tabbing}
\qquad \= $\name{sym} : \iso\typename{char} \to \tre$ \+\\
$\name{sym} \;\pboxvar{c} \;\pboxvar{s} =\; $\=
$\efor{n}{\name{pos}\;\dvar s}{\ewhen{\eeq{\dvar{s}[\dvar{n}]}{\dvar c}}{\eset{\etuple{\dvar n, \dvar n+1}}}}$
\end{tabbing}

\noindent
The $\name{sym}$ combinator takes a character and returns a set of substrings by
returning the set $(\dvar n, \dvar n+1)$ where the $\dvar n$\textsuperscript{th}
element of the string $\dvar s$ is the character $\dvar c$.

\begin{tabbing}
\qquad \=   $\name{nil} : \tre$ \+\\
  $\name{nil}\;\pboxvar{s} = \efor{n}{\name{pos}\;\dvar s}{\eset{\etuple{\dvar n,\dvar n}}}$
\end{tabbing}

\noindent
Then $(\name{nil} \;s)$ yields $\etuple{n,n}$ for each position $n$ in $s$,
since an empty substring can start anywhere.

\begin{tabbing}
\qquad \=   $\name{seq} : \tre \to \tre \to \tre$ \+\\
  $\name{seq}\;r_1\;r_2\;s = r_1\;s \bullet r_2\;s$
\end{tabbing}

\noindent
The $\name{seq}$ combinator takes two regular expressions $r_1$ and $r_2$
as arguments, applies its argument to both, and takes the relational
composition of the results. Therefore, if the range $(i,j)$ was in the
result of $r_1$, and $(j,k)$ was in the result of $r_2$, then
we will return $(i,k)$, just as desired.

\begin{tabbing}
\qquad \=   $\name{bot} : \tre$ \+\\
  $\name{bot}\;\_ = \bot$ \\[1em]

  $\name{alt} : \tre \to \tre \to \tre$ \\
  $\name{alt}\;r_1\;r_2\;s = r_1\;s \vee r_2\;s$
\end{tabbing}

\noindent
We get the empty set of matches from $\name{bot}$, and
$\name{alt}$ unions the matches of its two arguments.

\begin{tabbing}
\qquad \=   $\name{star} : \iso\tre \to \tre$ \+\\
  $\name{star}\;\pboxvar{r}\;\pboxvar{s} = \name{nil}\;\eboxvar{s} \vee \name{trans}\;\ebox{\dvar r\;\eboxvar{s}}$
\end{tabbing}

\noindent
The most interesting regular expression combinator is the Kleene star operation
$\name{star}$. It uses $\name{nil}$ to get the reflexive relation on positions,
and then takes the transitive closure of the regular expression it received as
an argument using the $\name{trans}$ operation. This forces its argument to be
boxed, since $\name{trans}$ calculates a fixed point, and only discrete
variables can occur inside of fixed point expressions.\footnote{As a technical
  note, sets of pairs of integers do not form a \todo{finite-height} lattice, so
  by typing this program is not an acceptable fixed point expression. However,
  since the positions in a string form a finite set, semantically it is fine.
  The original Datafun paper shows how one can define bounded fixed points to
  handle cases like this, so we will not be scrupulous.}


\subsubsection{Combinators for Regular Expression Matching, Take 2}

The combinators in the previous section found \emph{all} matches
within a given substring, but often we are not interested in all
matches: we only want to know if a string can match starting at a
particular location. We can easily refactor the combinators above to
work in this style, which illustrates the benefits of tightly
integrating functional and relational styles of programming -- we can
use functions to manage strict input/output divisions, and relations
to manage nondeterminism and search.

\begin{tabbing}
\qquad \=  $\kw{type}\;\tre\;=\iso (\tstring \times \tint) \to \tset{\tint}$ \+
\end{tabbing}

\noindent
Our new type of combinators takes a string and a starting
position, and returns a set of ending positions. In contrast, the earlier type
took a string and returned a set of start/end pairs.

\begin{tabbing}
\qquad \=  $\name{sym} : \iso\typename{char} \to \tre$\+ \\
  $\name{sym} \;\pboxvar c \;\pboxtuple{\dvar s, \dvar n} = \ewhen{\eeq{\dvar s[\dvar n]}{\dvar c}}{\eset{\dvar n+1}}$
\end{tabbing}

\noindent
$\name{sym}\;c$ checks if $c$ occurs at position $n$, yielding $\esetraw{n+1}$
if it does, and the empty set otherwise.

\begin{tabbing}
\qquad \=  $\name{nil} : \tre$\+ \\
  $\name{nil}\;\pboxtuple{\dvar s, \dvar n} = \eset{\dvar n}$
\\[.5\baselineskip]
  $\name{seq} : \tre \to \tre \to \tre$ \\
  $\name{seq}\;r_1\;r_2 \;\pboxtuple{\dvar s,\dvar n} = \efor{m}{r_1\;\eboxtuple{\dvar s,\dvar n}}{r_2\;\eboxtuple{\dvar s,\dvar m}}$
\end{tabbing}

\noindent
The $\name{nil}$ function simply returns the same index $n$ it received as an
argument, since an empty string matches starting from any position. Sequencing
via $\name{seq}\;r_1\;r_2$ checks first to see the possible ending positions from
matching $r_1$, and carries on with $r_2$ from there.

\begin{tabbing}
  \qquad \=
  $\name{bot} : \tre$ \+\\
  $\name{bot}\;\_ = \bot$ \\[1em]

  $\name{alt} : \tre \to \tre \to \tre$ \\
  $\name{alt}\;r_1\;r_2\;x =\ r_1\;x \vee r_2\;x$
\end{tabbing}

\noindent
We still get the empty set from $\name{bot}$, and $\name{alt}$
still unions the two sets of end positions.

\begin{tabbing}
\qquad \=  $\name{star} : \iso\tre \to \tre$\+ \\
  $\name{star}\;\pboxvar{r}\;\pboxtuple{\dvar s, \dvar n} = \efixis{s}{\bigl(\eset{\dvar n} \vee \efor{m}{\dvar s}{\dvar r\;\eboxtuple{\dvar s,\dvar m}}\bigr)}$
\end{tabbing}

\noindent
As before, the $\name{star}$ combinator takes a boxed regular expression as an
argument, and for the same reason -- we are implementing sequencing with a fixed
point. One thing worth noting about this definition is that it is
\emph{left-recursive} -- the definition takes the endpoints from the fixed point
$\name{self}$, and then continues matching using the argument $\name{r}$. This
should make clear that this is not just plain old functional programming -- we
are genuinely relying upon the fixed point semantics of Datafun.
