\section{Datalog and Datafun}
\label{sec:datalog-and-datafun}

n this section, we explain how Datalog works by example, and then explain
how Datafun works by porting and then generalising these examples. 

\subsection{Datalog}

The syntax of Datalog is a subset of Prolog's syntax. Programs
consist of collections of predicate declarations, as follows:
\begin{minted}[]{prolog}
parent(earendil, elrond).
parent(elrond, arwen).
parent(arwen, eldarion).

ancestor(X, Z) ← parent(X, Z).
ancestor(X, Z) ← ancestor(X, Y), parent(Y, Z).
\end{minted}

In this example, we define two binary relations, \datalog{parent(_,_)}
and \datalog{ancestor(_,_)}. Lowercase terms like \datalog{elrond} and
\datalog{arwen} are symbols \emph{a la} Lisp, and uppercase terms like
\datalog{X} and \datalog{Y} are variables.

The \datalog{parent(_, _)} relation declares a relation as a set of
ground \emph{facts}; we explicitly assert that \datalog{earendil} is
the parent of \datalog{elrond}, and \datalog{elrond} the parent of
\datalog{arwen}, and so on. Then, the ancestor relation is declared as
a pair of potentially recursive \emph{rules}, the first asserting that
$X$ is an ancestor of $Z$ if $X$ is $Z$'s parent, and the second
asserting that $X$ is an ancestor of $Z$ if there is a third person
$Y$, such that $X$ is $Y$'s ancestor and $Y$ is $Z$'s parent. In
inference rule form, this program could be rendered as:

\begin{mathpar}
  \inferrule*[]
             { }
             { \mathsf{parent(earendil, elrond)} }
  \and
  \inferrule*[]
             { }
             { \mathsf{parent(elrond, arwen)} }
  \and
  \inferrule*[]
             { }
             { \mathsf{parent(arwen, eldarion)} }
  \\\vspace{1em}
  \inferrule*[]
             { \mathsf{parent}(x, y) }
             { \mathsf{ancestor}(x, y) }
  \and
  \inferrule*[]
             { \mathsf{ancestor}(x, y) \\ \mathsf{parent}(y, z) }
             { \mathsf{ancestor}(x, z) }
\end{mathpar}

Semantically, each predicate can be interpeted as the set of tuples
which satisfy the predicate. Recursive definitions can be interpreted
by seeing the whole program as a function from relations to relations,
and then taking the least fixed point of that function. The syntax of
Datalog is such that the relation transformer the rules define is
always a monotone function on sets, and so this least fixed point
always exists.

\subsection{Datafun}

Datalog makes it very easy to define relations recursively, but
because it is such a small and restricted language, it is not possible
to build abstractions over these rules. However, its semantics, given
in terms of least fixed points of monotone functions on relations,
is extremely elegant, and Datafun arose as an attempt to generalize
this semantics.

The key idea behind Datafun is that if the semantics of a Datalog
program is a montone set-valued operator, then the natural home for
that semantics is in the category Poset, of partial orders and
monotone functions. Since this category is cartesian closed, then it
can interpret the simply-typed lambda calculus, which gives us a
notation for writing monotone functions.

So Datafun begins as the simply-typed lambda calculus with sums
and products. To this, we add a type of finite sets $\tset{\eqt A}$,
which are introduced with set literals $\eset{e_0, \ldots e_n}$, and
and can be eliminated using (a slight generalization of) monad
comprehension syntax $\efor{x}{e}{e'}$. 


\begin{enumerate}
\item We begin with the simply-typed lambda calculus including sums
  and products. Syntactically, this 
\item We add a type of finite sets 
\item Next, we add a comonadic type $\iso A$, denoting the same elements
  as $A$, but whose partial order is just the equality.
\item Finally, we add a fixed-point operator $\mathit{fix} : \Box(L \to L) \to L$. 
\end{enumerate}





\input{fig-syntax}
