\section{Datalog and Datafun, informally}
\label{sec:datalog-and-datafun}

\subsection{Datalog}

Datalog's syntax is a subset of Prolog's. Programs are collections of predicate
declarations:

\newcommand\datum[1]{\textsf{#1}}

\begin{code}
  \name{parent}(\datum{aerys}, \datum{rhaegar})\\
  \name{parent}(\datum{rhaegar}, \datum{jon})\\
  \name{parent}(\datum{lyanna}, \datum{jon})
  \\[6pt]
  \name{ancestor}(X,Z) \gets \name{parent}(X,Z)\\
  \name{ancestor}(X,Z) \gets \name{parent}(X,Y) \wedge \name{ancestor}(Y,Z)
\end{code}

\noindent
This defines two binary relations, \name{parent} and \name{ancestor}. Lowercase
sans-serif words like \datum{aerys} and \datum{rhaegar} are symbols \`a la
Lisp, and uppercase characters like $X,Y,Z$ are variables.
%
The \name{parent} relation is defined as a set of ground facts: we assert that
\datum{aerys} is \datum{rhaegar}'s parent, that \datum{rhaegar} is \datum{jon}'s
parent, and so on. The \name{ancestor} relation is defined by a pair of rules:
first, that $X$ is $Z$'s ancestor if $X$ is $Z$'s parent; second, that $X$ is
$Z$'s ancestor if $X$ has a child $Y$ who is an ancestor of $Z$.

Semantically, a predicate denotes the set of tuples that satisfy it. Compared to
Prolog, one of the key restrictions Datalog imposes is that these sets are
always \emph{finite}. This helps keep proof search decidable, allowing for a
variety of implementation strategies. In practice, most Datalog engines use
bottom-up evaluation instead of Prolog's top-down backtracking search.

Recursive definitions like \name{ancestor} give rise to the set of facts
deducible from the rules defining them. More formally, we can view these rules
as defining a relation transformer and producing its least fixed point. For this
to make sense, these rules must be \emph{stratified}: a recursive definition
cannot refer to itself beneath a negation. For example, the liar paradox is
prohibited:

\begin{code}
  \quad\name{liar}() \gets \neg \name{liar}().
  \qquad\color{Red}\text{\scshape\ding{55}\: not valid datalog}
\end{code}

\noindent
Stratification ensures the transformer the rules define is monotone,
guaranteeing a unique least fixed point.


\subsection{Datafun}

\input{fig-syntax}

The idea behind Datafun is to capture the essence of Datalog in a typed,
higher-order, functional setting.
%
Since the key restriction that makes Datalog tractable --- stratification ---
requires tracking \emph{monotonicity}, we locate Datafun's semantics in the
category \Poset\ of partial orders and monotone maps.
%
Since \Poset\ is bicartesian closed, it can interpret the simply typed
\fn-calculus, giving us a notation for writing monotone and higher-order
functions.
%
This lets us \emph{abstract} over Datalog rules, something not
possible in Datalog itself!
%
In the remainder of this section we reconstruct Datafun hewing closely
to this semantic intuition.

Datafun begins as the simply-typed \fn-calculus with functions ($\fnof x e$ and
$e\<f$), sums ($\inj i e$ and $\ecase{e}{\dots}$), and products ($\etuple{e,f}$
and $\pi_i\<e$).
%
To represent relations, we add a type of finite sets\footnote{To implement set
  types, their elements must support decidable equality. In our core calculus,
  we use a subgrammar of ``eqtypes'', and in our implementation (which compiles
  to Haskell) we use typeclass constraints to pick out such types.} $\tset{\eqt
  A}$, introduced with set literals $\eset{e_0, \ldots e_n}$, and eliminated
using Moggi's monadic bind syntax, $\efor{x}{e_1}{e_2}$, signifying the union
over all $\dvar x \in e_1$ of $e_2$.
%
Since we are working in \Poset, each type comes with a partial order on it; sets
are ordered by inclusion, $x \le y : \tseteq{A} \iff x \subseteq y$.

As long as all primitives are monotone, every definable function is also
monotone. This is necessary for defining fixed points, but may seem too
restrictive. There are many useful non-monotone operations, such as equality
tests $\eeq e f$. For example, $\esetraw{} = \esetraw{}$ is true, but if the
first argument increases to $\esetraw{1}$ it becomes false, a \emph{decrease}
(as we'll see later, in Datafun, $\efalse < \etrue$).

How can we express non-monotone operations if all functions are monotone?
%
We square this circle by introducing the \emph{discreteness} type constructor,
$\iso A$.
%
The elements of $\iso A$ are the same as those of $A$, but the partial order on
$\iso A$ is discrete, $x \le y : \iso A \iff x = y$.
%
Monotonicity of a function $\iso A \to B$ is vacuous: $x = y$ implies $f(x) \le
f(y)$ by reflexivity!
%
In this way we represent ordinary, possibly non-monotone, functions $A \to B$ as
monotone functions $\iso A \to B$.

Semantically, $\iso$ is a monoidal comonad or necessity modality, and so we base
our syntax on \citet{jrml}'s syntax for the necessity fragment of constructive
S4 modal logic.
%
This involves distinguishing two kinds of variable: discrete variables $\dvar x$
are italic and {\isocolor\isocolorname}, while monotone variables $x$ are
upright and black.
%
Discrete variables may be used wherever they're in scope, but crucially,
monotone variables are hidden within non-monotone expressions.
%
For example, in an equality test $\eeq e f$, the terms $e$ and $f$ cannot refer
to monotone variables bound outside the equality expression.
%
We highlight such expressions with a
\adjustbox{bgcolor=isobg}{\isobgname\ background}.
%
Putting this all together, we construct the type $\iso A$ with the non-monotone
introduction form $\ebox{e}$ and eliminate it by pattern-matching, $\eletbox x e
f$, giving access to a discrete variable $\dvar{x}$.

%% TODO: should we note that we really definitely mean □(L → L) and
%% not (□L → L)? Reader may be confused.
Finally, Datafun includes fixed points, $\efix{e}$. The $\prim{fix}$ combinator
takes a function $\iso (\fixt L \to \fixt L)$ and returns its least fixed point.
Besides monotonicity of the function, we impose two restrictions on the fixed
point operator to ensure well-definedness and termination. First, we require
that recursion occur at \emph{semilattice types with no infinite ascending
  chains}, $\fixt L$. A join-semilattice is a partial order with a least element
$\bot$ and a least upper bound operation $\vee$ (``join''). Finite sets (with
the empty set as least element, and union as join) are an example, as are tuples
of semilattices. As long as the semilattice has no infinite ascending chains,
recursion from the bottom element is guaranteed to find the least fixed point.

Second, we require that the recursive function be boxed, $\iso(\fixt L \to \fixt
L)$. Since boxed expressions can only refer to discrete values, and fixed point
functions themselves must be monotone, this has the effect of preventing
semantically nested fixed points. We discuss this in more detail in
\cref{sec:nested-fixed-points}. Note that this does not prevent mutual
recursion, which can be expressed by taking a fixed point at product type, nor
stratified fixed points \`a la Datalog.


\section{Datafun by example}

\input{fig-sugar}

For the sake of brevity and clarity, the examples that follow make use of some
syntax sugar:

\begin{enumerate}

\item We mentioned earlier that Datafun's boolean type $\tbool$ is ordered
  $\efalse < \etrue$. This is because we encode booleans as sets of empty
  tuples, $\tset 1$, with $\efalse$ being the empty set $\esetraw{}$ and
  $\etrue$ being the singleton $\esetraw{\etuple{}}$. At semilattice type we
  also permit a ``one-sided'' conditional test, $\ewhen{b}{e}$, which yields $e$
  if $b$ is \etrue\ and $\bot$ otherwise. Encoding booleans as sets has the
  advantage that $\ewhen{b}{e}$ is monotone in the condition $b$.

\item We make use of set comprehensions, which can be desugared into the monadic
  operators \kw{for} and \kw{when} in the usual
  way~\cite{wadler-monad-comprehensions}.

\item It is convenient to treat $\prim{fix}$ as a binding form, $\efixis x e$,
  rather than supplying a function, $\efix\ebox{\fnof x e}$.

\item Finally, we make free use of curried functions and pattern matching.
  Desugaring these is relatively standard, and so we will say little about it,
  with one exception: the box-elimination form $\eletbox x e e'$ is a pattern
  matching form, and so we allow it to occur inside of patterns. The effect of a
  box pattern $\pbox{\isocolor p}$ is to ensure that all of the variables bound
  in the pattern $\isocolor p$ are treated as discrete variables.

\end{enumerate}

\noindent
We summarize (except for pattern matching) the desugaring rules we use in
\cref{fig:sugar}.


\subsection{Set operations}

Even before higher-order functions, one of the main benefits of
Datafun relative to Datalog is that it offers the ability to manipulate relations
as first class values. In this subsection we will show how a variety
of standard operations on sets can be represented in Datafun.

\paragraph{Membership Tests} The first operation we consider is the
membership test operation.
\begin{tabbing}
  \qquad\=\+ \kill
  $\name{mem} : \iso A \to \tset A \to \tbool$ \\
  $\name{mem} \;\pboxvar{x} \;\var{ys} = \efor{y}{\var{ys}} \eeq{\dvar x}{\dvar y}$
\end{tabbing}

\noindent
This checks if the input $\dvar x$ is equal to any $\dvar y \in \var{ys}$. The
argument $x$ to $\name{mem}$ is discrete, because an element is in a set or not
-- the test is not monotone in $\dvar x$.

\paragraph{Set Intersection}
Using $\name{mem}$, it is possible to define set intersection, by taking the
union of all the singleton sets $\esetraw{\dvar x}$ where $\dvar x$ is an
element of both $\var{xs}$ and $ys$.

\begin{tabbing}
  \qquad\=\+ \kill
  $\_ {\cap} \_ : \tset A \to \tset A \to \tset A$ \\
  $\var{xs} \cap \var{ys} = \efor{x}{xs}
  \ewhen{\name{mem}\;\eboxvar{x}\;\var{ys}}{\eset{\dvar x}}$
\end{tabbing}

\noindent
Using comprehensions, this could alternately be written as:
\begin{tabbing}
  \qquad\=\+ \kill
  $\var{xs} \cap \var{ys} = \esetfor{x}{\dvar x \in \var{xs},\, \name{mem}\;\eboxvar{x}\;\var{ys}}$
\end{tabbing}

\paragraph{Relational Composition}
We can also define the composition of two relations in Datafun.

\begin{tabbing}
  \qquad\=\+ \kill
  $\_ {\bullet} \_$ \quad\quad\= $\,:$\;\; \=
  $ \tset{A \times B} \to \tset{B \times C} \to \tset{A \times C}$ \\

  $\var{xs} \mathrel{\bullet} \var{ys}$
  \> $=$ \> $\eforraw{\etuple{\dvar a,\dvar b} \in \var{xs}}
  \eforraw{\etuple{\dvar{b'}, \dvar c} \in \var{ys}}
  \ewhen{\eeq{\dvar b}{\dvar{b'}}} \eset{\etuple{\dvar a,\dvar c}}
  $
  %% \\
  %% \>     \> $\efor{(b',c)}{\mathit{ys}}{}$ \\
  %% \>     \> $\ewhen{b = b'}{\eset{(a,c)}}$
\end{tabbing}

\noindent
This is basically a transcription of the mathematical definition, where we build
those pairs which agree on their $B$-typed components. It can also be written
using set comprehension as:

\begin{tabbing}
  \qquad\=\+ \kill
  $\_ \bullet \_$ \;\;\;\= $\,:$\;\; \=
  $ \tset{A \times B} \to \tset{B \times C} \to \tset{A \times C}$ \\

  $\var{xs} \bullet \var{ys} =
  \esetfor{\etuple{\dvar a, \dvar c}}{
    \etuple{\dvar a, \dvar b} \in \var{xs},
    \etuple{\dvar{b'}, \dvar c} \in \var{ys}, \eeq{\dvar b}{\dvar{b'}}}$
\end{tabbing}

\paragraph{Transitive Closure}\label{sec:generic-transitive-closure}
Now, we define the transitive closure of a relation.
\begin{tabbing}
  \qquad\=\+ \kill
  $\name{trans}$ \quad\: \= $\,:$ \;\;\= $\iso{\tset{A \times A}} \to \tset{A \times A}$ \\
  $\name{trans} \;\pboxvar{e}$ \> $=$ \>
  $\efixis{s}{\dvar{e} \vee (\dvar{e} \bullet s)}$
\end{tabbing}

This definition uses recursion, just like the mathematical definition --
a transitive closure is the least relation containing the original relation $\name{xs}$
and the composition of $\name{xs}$ with the transitive closure. However, one
feature of this definition peculiar to core Datafun is that the argument type
is $\iso \tset{A \times A}$ -- the transitive closure takes a \emph{discrete} relation.
This is because we must use the relation within the fixed point, and so its parameter needs
to be discrete to occur within.


\subsection{Regular expression combinators}
\label{sec:regex-combinators}

\newcommand\tre{\typename{re}}

Datafun permits tightly integrating the higher-order functional and
bottom-up logic programming styles. In this section, we illustrate the
benefits of doing so by showing how to implement a regular expression
matching library in combinator parsing style.  Like combinator parsers
in functional languages, the code is very concise.  However, support
for the relational style ensures we can write \naive\ code
\emph{without} the exponential backtracking cliffs typical of parser
combinators in functional languages.

We assume the existence of a function $\name{pos} : \tstring \to \tset{\tint}$
which takes a string and returns the set of valid indices in that string, and
assume that string indexing is written $s[n]$, as in Java or C. Having done
this, we define the type of regular expression matchers.

\begin{tabbing}
\qquad  $\kw{type}\;\tre\;=\iso \tstring \to \tset{\tint \times \tint}$
\end{tabbing}

A regular expression takes a string (boxed so that it can be used inside fixed
point expressions), and returns a set of pairs of integers. The idea is that if
the regular expression matcher is passed the string argument $s$, then if
$\etuple{i,n}$ is one of the returned values, the substring $s_i, s_{i+1},
\ldots, s_{n-1}$ is matched by the regular expression. That is, it is inclusive
on the left and exclusive on the right.

\begin{tabbing}
\qquad \= $\name{sym} : \iso\typename{char} \to \tre$ \+\\
$\name{sym} \;\pboxvar{c} \;\pboxvar{s} =\; $\=
$\efor{n}{\name{pos}\;\dvar s}{\ewhen{\eeq{\dvar{s}[\dvar{n}]}{\dvar c}}{\eset{\etuple{\dvar n, \dvar n+1}}}}$
\end{tabbing}

\noindent
The $\name{sym}$ combinator takes a character and returns a set of substrings by
returning the set $(\dvar n, \dvar n+1)$ where the $\dvar n$\textsuperscript{th}
element of the string $\dvar s$ is the character $\dvar c$.

\begin{tabbing}
\qquad \=   $\name{nil} : \tre$ \+\\
  $\name{nil}\;\pboxvar{s} = \efor{n}{\name{pos}\;\dvar s}{\eset{\etuple{\dvar n,\dvar n}}}$
\end{tabbing}

\noindent
Then $(\name{nil} \;s)$ yields $\etuple{n,n}$ for each position $n$ in $s$,
since an empty substring can start anywhere.

\begin{tabbing}
\qquad \=   $\name{seq} : \tre \to \tre \to \tre$ \+\\
  $\name{seq}\;r_1\;r_2\;s = r_1\;s \bullet r_2\;s$
\end{tabbing}

\noindent
The $\name{seq}$ combinator takes two regular expressions $r_1$ and $r_2$
as arguments, applies its argument to both, and takes the relational
composition of the results. Therefore, if the range $(i,j)$ was in the
result of $r_1$, and $(j,k)$ was in the result of $r_2$, then
we will return $(i,k)$, just as desired.

\begin{tabbing}
\qquad \=   $\name{bot} : \tre$ \+\\
  $\name{bot}\;\_ = \bot$ \\[1em]

  $\name{alt} : \tre \to \tre \to \tre$ \\
  $\name{alt}\;r_1\;r_2\;s = r_1\;s \vee r_2\;s$
\end{tabbing}

\noindent
We get the empty set of matches from $\name{bot}$, and
$\name{alt}$ unions the matches of its two arguments.

\begin{tabbing}
\qquad \=   $\name{star} : \iso\tre \to \tre$ \+\\
  $\name{star}\;\pboxvar{r}\;\pboxvar{s} = \name{nil}\;\eboxvar{s} \vee \name{trans}\;\ebox{\dvar r\;\eboxvar{s}}$
\end{tabbing}

\noindent
The most interesting regular expression combinator is the Kleene star operation
$\name{star}$. It uses $\name{nil}$ to get the reflexive relation on positions,
and then takes the transitive closure of the regular expression it received as
an argument using the $\name{trans}$ operation. This forces its argument to be
boxed, since $\name{trans}$ calculates a fixed point, and only discrete
variables can occur inside of fixed point expressions.\footnote{As a technical
  note, sets of pairs of integers do not form a \todo{finite-height} lattice, so
  by typing this program is not an acceptable fixed point expression. However,
  since the positions in a string form a finite set, semantically it is fine.
  The original Datafun paper shows how one can define bounded fixed points to
  handle cases like this, so we will not be scrupulous.}


\subsection{Regular expression combinators, take 2}

The combinators in the previous section found \emph{all} matches
within a given substring, but often we are not interested in all
matches: we only want to know if a string can match starting at a
particular location. We can easily refactor the combinators above to
work in this style, which illustrates the benefits of tightly
integrating functional and relational styles of programming -- we can
use functions to manage strict input/output divisions, and relations
to manage nondeterminism and search.

\begin{tabbing}
\qquad \=  $\kw{type}\;\tre\;=\iso (\tstring \times \tint) \to \tset{\tint}$ \+
\end{tabbing}

\noindent
Our new type of combinators takes a string and a starting
position, and returns a set of ending positions. In contrast, the earlier type
took a string and returned a set of start/end pairs.

\begin{tabbing}
\qquad \=  $\name{sym} : \iso\typename{char} \to \tre$\+ \\
  $\name{sym} \;\pboxvar c \;\pboxtuple{\dvar s, \dvar n} = \ewhen{\eeq{\dvar s[\dvar n]}{\dvar c}}{\eset{\dvar n+1}}$
\end{tabbing}

\noindent
$\name{sym}\;c$ checks if $c$ occurs at position $n$, yielding $\esetraw{n+1}$
if it does, and the empty set otherwise.

\begin{tabbing}
\qquad \=  $\name{nil} : \tre$\+ \\
  $\name{nil}\;\pboxtuple{\dvar s, \dvar n} = \eset{\dvar n}$
\\[.5\baselineskip]
  $\name{seq} : \tre \to \tre \to \tre$ \\
  $\name{seq}\;r_1\;r_2 \;\pboxtuple{\dvar s,\dvar n} = \efor{m}{r_1\;\eboxtuple{\dvar s,\dvar n}}{r_2\;\eboxtuple{\dvar s,\dvar m}}$
\end{tabbing}

\noindent
The $\name{nil}$ function simply returns the same index $n$ it received as an
argument, since an empty string matches starting from any position. Sequencing
via $\name{seq}\;r_1\;r_2$ checks first to see the possible ending positions from
matching $r_1$, and carries on with $r_2$ from there.

\begin{tabbing}
  \qquad \=
  $\name{bot} : \tre$ \+\\
  $\name{bot}\;\_ = \bot$ \\[1em]

  $\name{alt} : \tre \to \tre \to \tre$ \\
  $\name{alt}\;r_1\;r_2\;x =\ r_1\;x \vee r_2\;x$
\end{tabbing}

\noindent
We still get the empty set from $\name{bot}$, and $\name{alt}$
still unions the two sets of end positions.

\begin{tabbing}
\qquad \=  $\name{star} : \iso\tre \to \tre$\+ \\
  $\name{star}\;\pboxvar{r}\;\pboxtuple{\dvar s, \dvar n} = \efixis{s}{\bigl(\eset{\dvar n} \vee \efor{m}{\dvar s}{\dvar r\;\eboxtuple{\dvar s,\dvar m}}\bigr)}$
\end{tabbing}

\noindent
As before, the $\name{star}$ combinator takes a boxed regular expression as an
argument, and for the same reason -- we are implementing sequencing with a fixed
point. One thing worth noting about this definition is that it is
\emph{left-recursive} -- the definition takes the endpoints from the fixed point
$\name{self}$, and then continues matching using the argument $\name{r}$. This
should make clear that this is not just plain old functional programming -- we
are genuinely relying upon the fixed point semantics of Datafun.
