\section{Datalog and Datafun}
\label{sec:datalog-and-datafun}

n this section, we explain how Datalog works by example, and then explain
how Datafun works by porting and then generalising these examples. 

\subsection{Datalog}

The syntax of Datalog is a subset of Prolog's syntax. Programs
consist of collections of predicate declarations, as follows:
\begin{minted}[]{prolog}
parent(earendil, elrond).
parent(elrond, arwen).
parent(arwen, eldarion).

ancestor(X, Z) ← parent(X, Z).
ancestor(X, Z) ← ancestor(X, Y), parent(Y, Z).
\end{minted}

In this example, we define two binary relations, \datalog{parent(_,_)}
and \datalog{ancestor(_,_)}. Lowercase terms like \datalog{elrond} and
\datalog{arwen} are symbols \emph{a la} Lisp, and uppercase terms like
\datalog{X} and \datalog{Y} are variables.

The \datalog{parent(_, _)} relation declares a relation as a set of
ground \emph{facts}; we explicitly assert that \datalog{earendil} is
the parent of \datalog{elrond}, and \datalog{elrond} the parent of
\datalog{arwen}, and so on. Then, the ancestor relation is declared as
a pair of potentially recursive \emph{rules}, the first asserting that
$X$ is an ancestor of $Z$ if $X$ is $Z$'s parent, and the second
asserting that $X$ is an ancestor of $Z$ if there is a third person
$Y$, such that $X$ is $Y$'s ancestor and $Y$ is $Z$'s parent. In
inference rule form, this program could be rendered as:

\begin{mathpar}
  \inferrule*[]
             { }
             { \mathsf{parent(earendil, elrond)} }
  \and
  \inferrule*[]
             { }
             { \mathsf{parent(elrond, arwen)} }
  \and
  \inferrule*[]
             { }
             { \mathsf{parent(arwen, eldarion)} }
  \\\vspace{1em}
  \inferrule*[]
             { \mathsf{parent}(x, y) }
             { \mathsf{ancestor}(x, y) }
  \and
  \inferrule*[]
             { \mathsf{ancestor}(x, y) \\ \mathsf{parent}(y, z) }
             { \mathsf{ancestor}(x, z) }
\end{mathpar}

Semantically, each predicate can be interpeted as the set of tuples
which satisfy the predicate. Recursive definitions can be interpreted
by seeing the whole program as a function from relations to relations,
and then taking the least fixed point of that function. The syntax of
Datalog is such that the relation transformer the rules define is
always a monotone function on sets, and so this least fixed point
always exists.

\subsection{Datafun}

\input{fig-syntax}

Datalog makes it very easy to define relations recursively, but
because it is such a small and restricted language, it is not possible
to build abstractions over these rules. However, its semantics, given
in terms of least fixed points of monotone functions on relations,
is extremely elegant, and Datafun arose as an attempt to generalize
this semantics.

The key idea behind Datafun is that if the semantics of a Datalog
program is a montone set-valued operator, then the natural home for
that semantics is in the category Poset, of partial orders and
monotone functions. Since this category is cartesian closed, then it
can interpret the simply-typed lambda calculus, which gives us a
notation for writing monotone functions.

So Datafun begins as the simply-typed lambda calculus with functions ($\fnof{x}{e}$
and $f\<e$), sums ($\inj i e$ and $\ecase{e} (\inj i x_i \caseto f_i)_{i\in\{1,2\}}$)
and products ($(\etuple{e_1, e_2}$ and $\pi_i e$). To this, we add a type of finite
sets\footnote{To implement set types, their elements must support decidable equality.
  In our core calculus, we use a subgrammar of
  ``eqtypes'', and in our implementation (which compiles to Haskell) we use typeclass
  constraints to pick out such types.}
$\tset{\eqt A}$, which are introduced with set literals $\eset{e_0, \ldots e_n}$, 
and can be eliminated using (a slight generalization of) Moggi's monadic
bind syntax $\efor{x}{e}{e'}$.

As long as all the primitives of the calculus, every definable
function is also monotone, which is a property essential for taking
fixed points, but it is also very restrictive. There are many
essential oeprations which are naturally non-monotone, such as
equality tests $\eeq e f$. For example, $\eset{} = \eset{}$ is true,
but if the first argument is increased to $\esetraw{1}$ then it
becomes false, a \emph{decrease} (in Datafun, $\efalse < \etrue$).
\todo{Talk about this with Michael\ldots}

So we need to define operations which are non-monotonic, without
destroying the property that types enforce monotonicity checking. We
square this circle by introducing the \emph{discreteness} type
constructor $\iso A$. The idea is that the elements of $\iso A$ are
\emph{exactly the same} as the elements of $A$, except that the
partial order relation on $\iso A$ is simply the equality on $A$ --
that is, this is a \emph{discrete} partial order. So the monotonicity
condition for a function of type $\iso A \to B$ becomes vacuous: it
just says that given equal inputs the equal outputs must lie in the
order relation of $B$, which is automatically satisfied (since partial
orders are reflexive). This lets us encode ordinary functions in terms
of monotone ones. Semantically, discreteness forms a comonad, and
accordingly the syntax we use for this is a variant of \citet{jrml}'s
syntax for constructive S4 modal logic. We make discrete terms with
the introduction form $\ebox{e}$ and eliminate them with a pattern
matching eliminator $\eletbox x e f$. Variables are colored and
italicised $\dvar x$ to indicate that they are discrete, and uncolored
and upright $x$ to indicate they are monotonic, and discrete terms
$\isocolor e$ are restricted to only refer to discrete variables.

Finally, Datafun include a fixed point operator $\efixis{x}{e}$. 

\subsection{Examples of Datafun Programs}

In the examples, we make free use of strings and integers, ordered
with the trivial discrete order ($x \leq y$ if and only if they are
equal).

\subsubsection{Syntactic\, Sugar}

In our examples, we freely use set comprehensions, noting that they
elaborate easily into

\subsubsection{Relational Composition}

\begin{tabbing}
  $\_ \bullet \_$ \;\;\;\= $\,:$\;\; \=
  $ \tset{A \times B} \to \tset{B \times C} \to \tset{A \times C}$ \\

  $\mathit{xs} \bullet \mathit{ys}$ \> $=$ \> $\efor{(a,b)}{\mathit{xs}}{}$ \\
                                    \>     \> $\efor{(b',c)}{\mathit{ys}}{}$ \\
                                    \>     \> $\eif{b = b'}{\eset{(a,c)}}{\bot}$
\end{tabbing}

\todo{Check use of equality with Michael\ldots}

\subsubsection{Generic Transitive Closure}


\begin{tabbing}
  $\name{tc}$ \qquad \= $\,:$ \;\;\= $\iso{\tset{A \times A}} \to \tset{A \times A}$ \\
  $\name{tc}\;\ebox{\mathit{xs}}$ \> $=$ \> $\efixis{\name{self}}{\name{xs} \vee \name{xs} \bullet\name{self}}$ 
\end{tabbing}

\subsubsection{Regular Expression Combinators}


\begin{tabbing} 
  $\kw{type}\;re\;=\iso \kw{string} \to \tset{\kw{int} \times \kw{int}}$  \\[1em]
  
  $\name{sym} : \iso \kw{char} \to \kw{re}$ \\
  $\name{sym}\;\ebox{c}\;\ebox{s} = $\= $\efor{n}{\name{pos}\;s}{}$ \\
                                     \> $\eif{s[n] = c}{\eset{(n, n+1)}}{\bot}$ \\[1em]

  $\name{nil} : \kw{re}$ \\
  $\name{nil}\;\ebox{s} = \efor{n}{\name{pos}\;s}{\eset{(n,n)}}$ \\[1em]

  $\name{seq} : \kw{re} \to \kw{re} \to \kw{re}$ \\
  $\name{seq}\;r_1\;r_2\;s = r_1\;s \bullet r_2\;s$ \\[1em]
  
  $\name{bot} : \kw{re}$ \\
  $\name{bot}\;\_ = \bot$ \\[1em]

  $\name{alt} : \kw{re} \to \kw{re} \to \kw{re}$ \\
  $\name{alt}\;r_1\;r_2\;s = r_1\;s \vee r_2\;s$ \\[1em]

  $\name{star} : \iso\kw{re} \to \kw{re}$ \\
  $\name{star}\;\ebox{r}\;\ebox{s} = \name{tc}\;\ebox{r\;\ebox{s}}$ \\
\end{tabbing}
