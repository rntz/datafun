\section{Datalog and Datafun}
\label{sec:datalog-and-datafun}

n this section, we explain how Datalog works by example, and then explain
how Datafun works by porting and then generalising these examples. 

\subsection{Datalog}

The syntax of Datalog is a subset of Prolog's syntax. Programs
consist of collections of predicate declarations, as follows:
\begin{minted}[]{prolog}
parent(earendil, elrond).
parent(elrond, arwen).
parent(arwen, eldarion).

ancestor(X, Z) ← parent(X, Z).
ancestor(X, Z) ← ancestor(X, Y), parent(Y, Z).
\end{minted}

In this example, we define two binary relations, \datalog{parent(_,_)}
and \datalog{ancestor(_,_)}. Lowercase terms like \datalog{elrond} and
\datalog{arwen} are symbols \emph{a la} Lisp, and uppercase terms like
\datalog{X} and \datalog{Y} are variables.

The \datalog{parent(_, _)} relation declares a relation as a set of
ground \emph{facts}; we explicitly assert that \datalog{earendil} is
the parent of \datalog{elrond}, and \datalog{elrond} the parent of
\datalog{arwen}, and so on. Then, the ancestor relation is declared as
a pair of potentially recursive \emph{rules}, the first asserting that
$X$ is an ancestor of $Z$ if $X$ is $Z$'s parent, and the second
asserting that $X$ is an ancestor of $Z$ if there is a third person
$Y$, such that $X$ is $Y$'s ancestor and $Y$ is $Z$'s parent. In
inference rule form, this program could be rendered as:

\begin{mathpar}
  \inferrule*[]
             { }
             { \mathsf{parent(earendil, elrond)} }
  \and
  \inferrule*[]
             { }
             { \mathsf{parent(elrond, arwen)} }
  \and
  \inferrule*[]
             { }
             { \mathsf{parent(arwen, eldarion)} }
  \\\vspace{1em}
  \inferrule*[]
             { \mathsf{parent}(x, y) }
             { \mathsf{ancestor}(x, y) }
  \and
  \inferrule*[]
             { \mathsf{ancestor}(x, y) \\ \mathsf{parent}(y, z) }
             { \mathsf{ancestor}(x, z) }
\end{mathpar}

Semantically, each predicate can be interpeted as the set of tuples
which satisfy the predicate. Recursive definitions can be interpreted
by seeing the whole program as a function from relations to relations,
and then taking the least fixed point of that function. The syntax of
Datalog is such that the relation transformer the rules define is
always a monotone function on sets, and so this least fixed point
always exists.

\subsection{Datafun}

\input{fig-syntax}

Datalog makes it very easy to define relations recursively, but
because it is such a small and restricted language, it is not possible
to build abstractions over these rules. However, its semantics, given
in terms of least fixed points of monotone functions on relations,
is extremely elegant, and Datafun arose as an attempt to generalize
this semantics.

The idea undergirding Datafun is that if the semantics of a Datalog
program is a montone set-valued operator, then the natural home for
that semantics is in the category Poset, of partial orders and
monotone functions. Since this category is cartesian closed, then it
can interpret the simply-typed lambda calculus, which gives us a
notation for writing monotone functions. We can now give a
reconstruction of Datafun hewing very closely to this semantic
intuition.

So Datafun begins as the simply-typed lambda calculus with functions ($\fnof{x}{e}$
and $f\<e$), sums ($\inj i e$ and $\ecase{e} (\inj i x_i \caseto f_i)_{i\in\{1,2\}}$)
and products ($(\etuple{e_1, e_2}$ and $\pi_i e$). To this, we add a type of finite
sets\footnote{To implement set types, their elements must support decidable equality.
  In our core calculus, we use a subgrammar of
  ``eqtypes'', and in our implementation (which compiles to Haskell) we use typeclass
  constraints to pick out such types.}
$\tset{\eqt A}$, which are introduced with set literals $\eset{e_0, \ldots e_n}$, 
and can be eliminated using (a slight generalization of) Moggi's monadic
bind syntax $\efor{x}{e}{e'}$.

As long as all the primitives of the calculus, every definable
function is also monotone, which is a property essential for taking
fixed points, but it is also very restrictive. There are many
essential oeprations which are naturally non-monotone, such as
equality tests $\eeq e f$. For example, $\eset{} = \eset{}$ is true,
but if the first argument is increased to $\esetraw{1}$ then it
becomes false, a \emph{decrease} (in Datafun, $\efalse < \etrue$).
\todo{Talk about this with Michael\ldots}

So we need to define operations which are non-monotonic, without
destroying the property that types enforce monotonicity checking. We
quare this circle by introducing the \emph{discreteness} type
constructor $\iso A$. The idea is that the elements of $\iso A$ are
\emph{exactly the same} as the elements of $A$, except that the
partial order relation on $\iso A$ is simply the equality on $A$ --
that is, this is a \emph{discrete} partial order. So the monotonicity
condition for a function of type $\iso A \to B$ becomes vacuous: it
just says that given equal inputs the equal outputs must lie in the
order relation of $B$, which is automatically satisfied (since partial
orders are reflexive). This lets us encode ordinary functions in terms
of monotone ones. Semantically, discreteness forms a comonad, and
accordingly the syntax we use for this is a variant of \citet{jrml}'s
syntax for constructive S4 modal logic. We make discrete terms with
the introduction form $\ebox{e}$ and eliminate them with a pattern
matching eliminator $\eletbox x e f$. Variables are colored and
italicised $\dvar x$ to indicate that they are discrete, and uncolored
and upright $x$ to indicate they are monotonic, and discrete terms
$\isocolor e$ are restricted to only refer to discrete variables.

Finally, Datafun include a fixed point operator $\efix{e}$. The $\efix$
combinator takes a function argument of type $\iso (L \to L)$ and
returns the least fixed point of that function. We impose two
restrictions on the fixed point operator to ensure well-definedness
and termination.  First, we require that recursion occur at
\emph{semilattice types}.  A join-semilattice is a partial order with
a least element and a join operation for calculating least upper
bounds. Sets (with the empty set as least element, and union as join)
are an example, as are tuples of semilattices. As long as the lattice
has no infinite ascending chains, recursion from the bottom element
is guaranteed to find the least fixed point.

Furthermore, we require that the recursive function be supplied at box
type. Since boxed expressions can only refer to discrete values, this
means that the only monotone variable the fixed point can refer to is
its fixed point. This ends up blocking (semantically) nested fixed points,
and leaves the semantics of Datafun close to that of Datalog, where all
recursion happens once, at the level of the whole program. 


\subsection{Examples of Datafun Programs}

In the examples, we make free use of strings and integers, ordered
with the trivial discrete order ($x \leq y$ if and only if they are
equal).

\subsubsection{Syntactic\, Sugar}

In the following examples, we make 

\subsubsection{Relational Composition}

\begin{tabbing}
  $\_ \bullet \_$ \;\;\;\= $\,:$\;\; \=
  $ \tset{A \times B} \to \tset{B \times C} \to \tset{A \times C}$ \\

  $\mathit{xs} \bullet \mathit{ys}$ \> $=$ \> $\efor{(a,b)}{\mathit{xs}}{}$ \\
                                    \>     \> $\efor{(b',c)}{\mathit{ys}}{}$ \\
                                    \>     \> $\ewhen{b = b'}{\eset{(a,c)}}$
\end{tabbing}

\todo{Check use of equality with Michael\ldots}

\subsubsection{Generic Transitive Closure}


\begin{tabbing}
  $\name{tc}$ \qquad \= $\,:$ \;\;\= $\iso{\tset{A \times A}} \to \tset{A \times A}$ \\
  $\name{tc}\;\ebox{\mathit{xs}}$ \> $=$ \> $\efixis{\name{self}}{\name{xs} \vee \name{xs} \bullet\name{self}}$ 
\end{tabbing}

\subsubsection{Combinators for Regular Expression Matching}

Datafun permits tightly integrating the higher-order functional and
bottom-up logic programming styles. In this section, we illustrate the
benefits of doing so by showing how to implement a regular expression
matching library in combinator parsing style.  Like combinator parsers
in functional languages, the code is very concise.  Unlike typical
functional parser combinators, though, support for the relational
style ensures we can write \naive\ code \emph{without} the exponential
backtracking cliffs typical of parser combinator libraries in
functional languages.

Below, we assume the existence of a function
$\name{pos} : \kw{string} \to \tset{\kw{int}}$ which takes a string
$s$ and returns the set of valid indices in that string, and assume
that the character at position $n$ can be extracted from the string
$s$ with the expression $s[n]$, as in Java or C. Having done this, we define
the type of regular expression matchers.
\begin{tabbing} 
\qquad  $\kw{type}\;re\;=\iso \kw{string} \to \tset{\kw{int} \times \kw{int}}$  
\end{tabbing}
This type takes a string (at boxed type, so that it can be used inside
fixed point expressions), and then returns a set of pairs of integers. The
idea is that if the regular expression matcher is passed the string
argument $s$, then if $(i, n)$ is one of the returned values, then the
substring $s_i, s_{i+1}, \ldots, s_{n-1}$ is matched by the regular expression.
That is, it is inclusive on the left and exclusive on the right. 

\begin{tabbing}
\qquad \= $\name{sym} : \kw{char} \to \kw{re}$ \+\\
$\name{sym}\;c\;\ebox{s} =\; $\= $\efor{n}{\name{pos}\;s}{\ewhen{s[n] = c}{\eset{(n, n+1)}}}$ 
\end{tabbing}
The $\name{sym}$ combinator takes a character and returns a set of
substrings by returning the set $(n, n+1)$ where the $n$-th element of
the string $s$ is the character $c$.
%
\begin{tabbing}
\qquad \=   $\name{nil} : \kw{re}$ \+\\
  $\name{nil}\;\ebox{s} = \efor{n}{\name{pos}\;s}{\eset{(n,n)}}$
\end{tabbing}
%
The $\name{nil}$ combinator reports the set $(n,n)$ for every position
$n$ in the string, because an empty string can start at every position in
the string. 
%
\begin{tabbing}
\qquad \=   $\name{seq} : \kw{re} \to \kw{re} \to \kw{re}$ \+\\
  $\name{seq}\;r_1\;r_2\;s = r_1\;s \bullet r_2\;s$
\end{tabbing}
% 
The $\name{seq}$ combinator takes two regular expressions $r_1$ and $r_2$
as arguments, applies the string $s$ to both, and then takes the relational
composition of the results. This means that if the range $(i,j)$ was in the
recognized set of $r_1$, and $(j,k)$ was in the recognized set of $r_2$, then
we will return $(i,k)$, just as desired. 
%
\begin{tabbing}
\qquad \=   $\name{bot} : \kw{re}$ \+\\
  $\name{bot}\;\_ = \bot$ \\[1em]

  $\name{alt} : \kw{re} \to \kw{re} \to \kw{re}$ \\
  $\name{alt}\;r_1\;r_2\;s = r_1\;s \vee r_2\;s$
\end{tabbing}
%
The $\name{bot}$ combinator just returns the empty set of matches, and the
$\name{alt}$ combinator takes the union of the matches of its two arguments. 
%
\begin{tabbing}
\qquad \=   $\name{star} : \iso\kw{re} \to \kw{re}$ \+\\
  $\name{star}\;\ebox{r}\;\ebox{s} = \name{nil}\;\ebox{s} \vee \name{tc}\;\ebox{r\;\ebox{s}}$ 
\end{tabbing}
The most interesting regular expression combinator is the Kleene star operation $\name{star}$.
This just uses $\name{nil}$ to get the reflexive relation on positions, and then takes the
transitive closure of the regular expression it received as an argument using the $\name{tc}$
operation. This forces its argument to be boxed, since $\name{tc}$ calculates a fixed point,
and only discrete arguments can occur inside of 


\subsubsection{Regular Expression Combinators, 2}
\begin{tabbing} 
  $\kw{type}\;re\;=\iso (\kw{string} \times \kw{int}) \to \tset{\kw{int}}$  \\[1em]
  
  $\name{sym} : \iso \kw{char} \to \kw{re}$ \\
  $\name{sym}\;\ebox{c}\;\ebox{s,n} = \ewhen{s[n] = c}{\eset{n+1}}$ \\[1em]

  $\name{nil} : \kw{re}$ \\
  $\name{nil}\;\ebox{s, n} = \eset{n}$ \\[1em]

  $\name{seq} : \kw{re} \to \kw{re} \to \kw{re}$ \\
  $\name{seq}\;r_1\;r_2\;\ebox{s,n} =\ x = r_1\;x \vee r_2\;x$ \\[1em]

  $\name{star} : \iso\kw{re} \to \kw{re}$ \\
  $\name{star}\;\ebox{r}\;\ebox{s, n} = \efixis{\name{self}}{\eset{n} \vee 
                                                \efor{m}{\name{self}}{r\;\ebox{s,m}}}$ \\
\end{tabbing}
