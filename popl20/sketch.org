* 1. Introduction
- Datalog is good (cite its many uses, databases, program analysis, etc.)
  
- but in practice it always needs extensions
  and it can involve boilerplate

- Datafun generalizes Datalog to a functional language
  to support further extension (eg. semilattices)
  and avoid boilerplate via higher-order programming

- State of the art eval strategy for Datalog is seminaive evaluation

- Folklore and recent work (cite: Picallo) says seminaive evaluation exploits
  *derivatives*.

- The Incremental Lambda Calculus shows how to take derivatives of functional
  programs.

- We adapt this work to Datafun and define a seminaive program transformation.
  As in Datalog, this can produce asymptotic speedups (eg. on transitive
  closure).

** Contributions
- phi/delta transformation

Compared to:
1. Datalog: we're higher-order

2. Incremental lambda calculus:
   - handle sum types
   - adapt for poset semantics & increasing changes
   - □ lets us be more specific about what is _allowed_ to change.
   - goal is not incremental computation /per se/ but faster fixed points

3. Picallo papers:

   Fixing incremental computation gives _some_ cases where function changes exist,
   but not in general. We have a different notion of function changes (closer to
   the Inc. λ-calculus') and so for us they always exist.

   Later work (the FOSSACS stuff) constructs a *closed* category but does not
   show how to apply this as a program transform / speedup. Possible future
   work!

4. Automatic differentiation:
   - we use □ to avoid need for higher-order derivatives

* 2. Datalog & Datafun
First explain Datalog. Then explain Datafun by analogy:

predicates = finite sets
queries = set comprehensions
recursion = fixed points
stratification = monotonicity types

Motivate non-monotonicity via set membership or similar (check ICFP16 paper).
Explain □: monotone functions □A → B = all functions A → B.

Informally go through any non-obvious syntax of Datafun (as in ICFP16 paper) &
explain what it means.

* 3. Seminaive evaluation
Example: transitive closure. adapt explanation (with citation) from "Fixing
Incremental Computation".

How does seminaive eval generalize to a functional language with (fix f)?
Well, fix f computes:

    x_0 = ⊥
    x_{i+1} = f x_i

What we really want is to compute the difference between steps, as in:

    x_0  = ⊥        x_{i+1}  = x_i ∪ dx_i
    dx_0 = f ⊥      dx_{i+1} = f' x_i dx_i

Call this fast-fix (f,f'). This computes same sequence as (fix f) as long as f x
∪ f' x dx = f (x ∪ dx). This (swapping ∪ for ⊕) is the defining property of a
derivative in the incremental λ-calculus!

Explain inc λ-calculus as we apply it. Every A gets a ΔA and an ⊕.

    Δ{A} = {A}                ⊕ = ∪
    Δ(A × B) = ΔA × ΔB        ⊕ is pointwise
    Δ(A → B) = □A → ΔA → ΔB   (f ⊕ df) (x ⊕ dx) = f x ⊕ df x dx

intuition for Δ(A → B): derivative takes as input a "tangent at a point", □A × ΔA.

-- MISSING CONNECTION --

Show what our transformation does (after optimizations) to transitive closure, &
how it corresponds with Datalog version.

** Further examples of seminaive evaluation
- generic transitive closure
- regular expressions

* 4. Type theory & semantics of Datafun
explain type theory & semantics in Poset
also explain desugaring and pattern matching

* 5. The seminaive transformation
- φ/δ
- logical relation
- fundamental theorem
- coincidence at base types

* 6. Implementation & results
- discuss implementation briefly
- explain optimizations necessary (propagating ⊥)
- give graph for performance

* 7. Related (& future) work
