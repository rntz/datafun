\section{The \texorpdfstring{$\boldsymbol\phi$}{\textphi} and \texorpdfstring{$\boldsymbol\delta$}{\textdelta} Transformations}
\label{sec:transformations}

Recall our strategy from \cref{sec:seminaive-strategy}: we aim to define two
static transformations.
%
First, a speed-up transform $\phi e$, which will replace $\efix f$ by
$\fastfix\<(f,f')$ to compute fixed points semi\naive{}ly.
%
But to find the derivative $f'$ of $f$ we'll need a second transform, called
$\delta e$.
%
Since a derivative is a zero-change, can $\delta e$ simply find the
\emph{zero-change} to $e$? Unfortunately, this is not strong enough. For
example, the derivative of $\fnof x e$ depends on how $e$ changes as its free
variable $x$ changes --- which is not necessarily a zero-change.
%
To compute derivatives (zero-changes), we need to solve the general problem of
computing \emph{changes}.
%
Therefore we model $\delta e$ on the incremental \fn-calculus' $\Deriv$
transform \citep{incremental}: $\delta e$ will determine how $\phi e$ changes as
its free variables change.\footnote{In order to make their mutual recursion
  work, $\delta e$ incrementalizes $\phi e$, not $e$. We'll see why this is
  necessary later. \todo{insert forward ref.}}

In fact, viewing expressions $e$ as functions of their free variables, $\delta
e$ will denote the \emph{derivative} of the function $\phi e$ denotes.
%
And just as the derivative of a unary function $f\<x$ has \emph{two} arguments,
$\df\<x\<\dx$, the derivative of an expression $e$ with $n$ variables $x_1,
\dots, x_n$ will have $2n$ variables: the original $x_1, \dots, x_n$ and their
changes $\dx_1, \dots, \dx_n$.\footnote{We assume throughout the paper as a
  matter of notational convenience that source programs contain no variables
  starting with the letter \emph{d}.} This already suggests part of $\delta$'s
definition: $\delta x = \dx$ and $\delta\dvar x = \dvar\dx$.

%% \newcommand\mvar[1]{{\color{black}#1}}
%% $\phi(\efixis x e) = \fastfix\<\ebox{\etuple{\fnof{\mvar x}\phi e,\ \fnof{\eboxvar x} \fnof{\mvar\dx} \delta e}}$

\input{fig-DeltaPhi}

But before defining the rest of $\delta$, let's return to our primary purpose:
what is $\phi(\efix e)$? Clearly it involves \fastfix.
%
We also need the derivative of the function $e$ computes, but as we've just
discussed, $\delta e$ yields how $e$ changes.
%
Since derivatives are zero-changes, function changes and derivatives coincide if
\emph{the function cannot change}.
%
This is why the typing rule for $\efix e$ (\todo{xref}) requires that $e : \iso(\fixt L
\to \fixt L)$: the use of $\iso$ prevents $e$ from changing.
%
So the key strategy of our speed-up transformation is to {\bfseries\boldmath
  augment expressions of type ${\iso A}$ with their zero-changes.}
%
To do this we need a type translation corresponding to $\phi$; let's call it
$\Phi$. Source expressions $e : A$ become sped-up expressions $\phi e : \Phi A$.
In particular, if $e : \iso A$ then $\phi e$ has type $\Phi(\iso A) = \iso(\Phi
A \x \DP A)$.
%
Evaluating $\phi e$ should produce a pair $\ebox{\etuple{x,\dx}}$ where $x :
\Phi A$ is the sped-up result and $\dx : \DP A$ is a zero-change to $x$.

We define $\Phi A$ and recapitulate $\D A$ in \cref{fig:DeltaPhi}.
%
On types other than $\iso A$, $\Phi$ simply distributes.
%
It's worth noting that:

\begin{lemma}\label{thm:phi-eqt}
  $\Phi\eqt A = \eqt A$.
\end{lemma}
\begin{proof}
  Induct on $\eqt A$.
\end{proof}

\noindent This means that sped-up programs do nothing to first-order data.

\todo{Key ideas not yet covered:
  \begin{itemize}
  \item We're using derivatives of a sped-up program so we use $\DP$ everywhere
    not $\D$.

  \item Give typing rules \& semantics for \fastfix. Semantics does not depend on
    \fastfix\ being given a derivative; it's well-defined regardless.
  \end{itemize}}


\todo{Explain \cref{fig:DeltaPhi}. Then explain corresponding context transformations:}
\begin{align*}
  \D(\h x A) &= \h \dx {\D A} & \D(\hd x A) &= \emptycx\quad\text{(the empty context)}
  \\
  \Phi(\h x A) &= \h x {\Phi A} & \Phi(\hd x A) &= \hd x {\Phi A}, \hd \dx {\DP A}
  \\
  \iso{(\h x A)} &= \hd x A & \iso{(\hd x A)} &= \hd x A
\end{align*}

\noindent
Intuitively, $\iso\G$, $\D\G$, and $\Phi\G$ mirror the effect of
$\iso$, $\D$, and $\Phi$ on the semantics of $\G$:

\nopagebreak[2]
%% This is a hack to make up for not having a \multirow that works inside align*
%% & co without producing warnings.
\begin{center}
  \(\displaystyle \den{\iso\G} = \iso\den\G \)
  %
  \hfil
  %
  %% TODO: needs more vertical space?
  \(\displaystyle\begin{aligned}
    \den{\D(\h x A)} &\cong \den{\D A}
    \\
    \den{\D(\hd x A)} &\cong \den{\D \iso A}
  \end{aligned}\)
  %
  \hfil
  %
  \(\displaystyle\begin{aligned}
    \den{\Phi(\h x A)} &\cong \den{\Phi A}
    \\
    \den{\Phi(\hd x A)} &\cong \den{\Phi \iso A}
  \end{aligned}\)
\end{center}

%% \nopagebreak[2]
%% \begin{align*}
%%   \multirow{2}{*}{\den{\iso \G} = \iso\den\G}
%%   &&
%%   \den{\D(\h x A)} &\cong \den{\D A}
%%   &
%%   \den{\Phi(\h x A)} &\cong \den{\Phi A}
%%   \\
%%   &&
%%   \den{\D(\hd x A)} &\cong \den{\D \iso A}
%%   &
%%   \den{\Phi(\hd x A)} &\cong \den{\Phi \iso A}
%% \end{align*}

\noindent
These defined, we can state the sense in which $\phi$ and $\delta$ are
type-correct:

\begin{theorem}[Type-correctness]
  \label{thm:type-correct}
  If $\J e \G A$, then
  %% \[ \J {\phi e} {\Phi\G} {\Phi A}
  %% \quad\text{and}\quad
  %% \J {\delta e} {\iso{\Phi\G}, \DP\G} {\DP A}
  %% \]
  \begin{align*}
    \Jalign {\phi e} {\Phi\G} {\Phi A}\\
    \Jalign {\delta e} {\iso{\Phi\G}, \DP\G} {\DP A}
  \end{align*}
\end{theorem}

\begin{proof}
  By induction on typing derivations; see appendix. \XXX
\end{proof}

\noindent To get the hang of these context and type transformations, suppose $\J
e {\h x A, \hd y B} C$. Then \cref{thm:type-correct} tells us:

\nopagebreak[2]
\begin{align*}
  \Jalign {\phi e} {\h x {\Phi A}, \hd y {\Phi B}, \hd \dy {\DP B}} {\Phi C}
  \\
  \Jalign {\delta e} {\hd x {\Phi A}, \h\dx{\DP A}, \hd y {\Phi B}, \hd \dy {\DP B}} {\DP C}
\end{align*}

\todo{Explain how uses of $\phi$ in $\delta e$ involve weakening, and how this
  justifies their use in discrete contexts (hilighted in {\color{Rhodamine}pink}), eg. in $\delta(e\<f) = \delta e \<\eboxraw{\phi f} \<\delta f$.}

\todo{explain implementation of \zero{} via \dummy{}.}

\input{fig-phi-delta}
