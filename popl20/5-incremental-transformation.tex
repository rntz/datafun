\section{The \boldphi\ and \bolddelta\ Transformations}
\label{sec:transformations}

We use two static transformations, $\phi$ and $\delta$. Their definitions are
given in \cref{fig:phi,fig:delta} respectively, but rather than diving straight
in, we \XXX.

The speed-up transform $\phi e$ computes fixed points semi\naive{}ly by
replacing $\efix f$ by $\fastfix\<({f,f'})$.
%
But to find the derivative $f'$ of $f$ we'll need a second transform, called
$\delta e$.
%
Since a derivative is a zero change, can $\delta e$ simply find a zero change to
$e$?
%
Unfortunately, this is not strong enough.
%
For example, the derivative of $\fnof x e$ depends on how $e$ changes as its
free variable $x$ changes --- which is not necessarily a zero change.
%
To compute derivatives, we need to solve the general problem of computing
\emph{changes}.
%
So, modelled on the incremental \fn-calculus' $\Deriv$ \citep{incremental},
$\delta e$ will compute how $\phi e$ changes as its free variables
change.%
%% \footnote{In order to make their mutual recursion work, $\delta e$
%%   incrementalizes $\phi e$, not $e$. We'll see why this is necessary later.
%%   \todo{insert forward ref.}}

However, to speed up $\efix e$ we don't want the change to $e$; we want its
derivative.
%
Since derivatives are zero-changes, function changes and derivatives coincide if
\emph{the function cannot change}.
%
This is why the typing rule for $\efix e$ (\todo{xref}) requires that $e : \iso(\fixt L
\to \fixt L)$: the use of $\iso$ prevents $e$ from changing!
%
So the key strategy of our speed-up transformation is to {\bfseries\boldmath
  decorate expressions of type ${\iso A}$ with their zero-changes.}
%
This makes derivatives available exactly where we need them: at \prim{fix}
expressions.


\subsection{Typing \boldphi\ and \bolddelta}

\input{fig-DeltaPhi}

In order to decorate expressions with extra information, $\phi$ also needs to
decorate their types. In \cref{fig:DeltaPhi} we give a type translation $\Phi A$
capturing this.
%
In particular, if $e : \iso A$ then $\phi e$ will have type $\Phi(\iso A) =
\iso(\Phi A \x \DP A)$.
%
The idea is that evaluating $\phi e$ will produce a pair
$\eboxraw{\etuple{x,\dx}}$ where $x : \Phi A$ is the sped-up result and $\dx :
\DP A$ is a zero-change to $x$.
%
Thus, if $e : \iso(\fixt L \to \fixt L)$, then $\phi e$ will compute
$\eboxraw{\etuple{f,f'}}$, where $f'$ is the derivative of $f$.

On types other than $\iso A$, there is no information we need to add, so $\Phi$
simply distributes.
%
In particular, source programs and sped-up programs agree on the shape of
first-order data:

\begin{lemma}\label{thm:phi-eqt}
  $\Phi\eqt A = \eqt A$.
\end{lemma}
\begin{proof}
  Induct on $\eqt A$.
\end{proof}

For reasons that we'll discuss later \todo{fwdref}, $\phi$ and $\delta$ are
mutually recursive; to make this work, $\delta e$ must find the change to $\phi
e$ rather than $e$.
%
So if $e : A$ then $\phi e : \Phi A$ and $\delta e : \DP A$.
%
However, so far we have neglected to say what $\phi$ and $\delta$ do to typing
contexts.
%
To understand this, it's helpful to look at what $\Phi$ and $\DP$ do to
functions and to $\iso$.
%
This is because expressions denote functions of their free variables.
%
Moreover, in Datafun free variables come in two flavors, monotone and discrete, and discrete variables are semantically $\iso$-ed.

If we view expressions as functions of their free variables, $\delta e$ will
denote the \emph{derivative} of the function $\phi e$ denotes.
%
And just as the derivative of a unary function $f\<x$ has \emph{two} arguments,
$\df\<x\<\dx$, the derivative of an expression $e$ with $n$ variables $x_1,
\dots, x_n$ will have $2n$ variables: the original $x_1, \dots, x_n$ and their
changes $\dx_1, \dots, \dx_n$.%
%
\footnote{We assume throughout the paper as a matter of notational convenience
  that source programs contain no variables starting with the letter \emph{d}.}
%
However, this says nothing yet about monotonicity or discreteness.
%
To make this precise, we'll use three context transformations, named according
to the analogous type operators $\iso$, $\Phi$, and $\Delta$:
%% %
%% We define these pointwise by their action on singleton contexts (they all
%% preserve empty contexts and distribute across context union):

\begin{align*}
  \iso{(\h x A)} &= \hd x A & \iso{(\hd x A)} &= \hd x A
  \\
  \Phi(\h x A) &= \h x {\Phi A} & \Phi(\hd x A) &= \hd x {\Phi A}, \hd \dx {\DP A}
  \\
  \D(\h x A) &= \h \dx {\D A}
  & \D(\hd x A) &= \emptycx \quad\text{\small(the empty context)}
\end{align*}

%% \begin{align*}
%%   \iso{(\h x A)} &= \hd x A & \iso{(\hd x A)} &= \hd x A
%%   \\
%%   \Phi(\h x A) &= \h x {\Phi A} & \Phi(\hd x A) &= \hd x {\Phi A}, \hd \dx {\DP A}
%%   \\
%%   \D(\h x A) &= \h \dx {\D A} & \D(\hd x A) &= \emptycx\quad\text{(the empty context)}
%% \end{align*}

\noindent
%% (All three preserve empty contexts and distribute over union; e.g. $\Phi\emptycx
%% = \emptycx$ and $\Phi(\G_1,\G_2) = \Phi\G_1, \Phi\G_2$.)
(Otherwise all three operators distribute; e.g.\ $\iso\emptycx = \emptycx$ and
$\iso(\G_1,\G_2) = \iso\G_1, \iso\G_2$.)

Intuitively, $\iso\G$, $\Phi\G$, and $\D\G$ mirror the effect of
$\iso$, $\Phi$, and $\D$ on the semantics of $\G$:

\begin{align*}
  \den{\iso\G} &\cong \iso\den\G
  &
  \begin{aligned}
    \den{\Phi(\h x A)} &\cong \den{\Phi A}
    \\
    \den{\Phi(\hd x A)} &\cong \den{\Phi \iso A}
  \end{aligned}
  &&
  \begin{aligned}
    \den{\D(\h x A)} &\cong \den{\D A}
    \\
    \den{\D(\hd x A)} &\cong \den{\D \iso A}
  \end{aligned}
\end{align*}

%% \begin{align*}
%%   \multirow{2}{*}{\den{\iso \G} = \iso\den\G}
%%   &&
%%   \den{\D(\h x A)} &\cong \den{\D A}
%%   &
%%   \den{\Phi(\h x A)} &\cong \den{\Phi A}
%%   \\
%%   &&
%%   \den{\D(\hd x A)} &\cong \den{\D \iso A}
%%   &
%%   \den{\Phi(\hd x A)} &\cong \den{\Phi \iso A}
%% \end{align*}

\noindent
These defined, we can state the types of $\phi e$ and $\delta e$:

\begin{theorem}[Well-typedness]
  \label{thm:type-correct}
  If $\J e \G A$, then
  \begin{align*}
    \Jalign {\phi e} {\Phi\G} {\Phi A}\\
    \Jalign {\delta e} {\iso{\Phi\G}, \DP\G} {\DP A}
  \end{align*}
\end{theorem}

\begin{proof}
  By induction on typing derivations; see appendix. \XXX
\end{proof}

\noindent As expected if we view expressions as functions of their free
variables, if we pretend $\G$ is a type, these correspond to $\Phi(\G \to A)$
and $\DP(\G \to A)$ respectively:

\begin{align*}
  \Phi(\G \to A) &= \Phi\G \to \Phi A
  & \DP(\G \to A) &= \iso\Phi\G \to \DP\G \to \DP A
\end{align*}

\noindent
To get the hang of these context and type transformations, suppose $\J
e {\hd x A, \h y B} C$. Then \cref{thm:type-correct} tells us:

\begin{align*}
  \Jalign{\phi e} {\hd x{\Phi A},\, \hd \dx {\DP A},\, \h y {\Phi B}} {\Phi C}
  \\
  \Jalign{\delta e} {\hd x{\Phi A},\, \hd\dx{\DP A},\, \hd y{\Phi B}, \h\dy{\DP B}} {\DP C}
\end{align*}

We now have enough information to tackle the definitions of $\phi$ and $\delta$
given in \cref{fig:phi,fig:delta}. In the remainder of this section, we'll
examine the most interesting and important parts of these definitions in detail.

\input{fig-phi-delta}


\subsection{Fixed points}

The whole purpose of $\phi$ and $\delta$ is to speed up fixed points, so let's
start there. In a fixed point expression $\efix e$, we know $e : \iso(\fixt L
\to \fixt L)$. Consequently the type of $\phi e$ is

\begin{align*}
  \Phi(\iso(\fixt L \to \fixt L))
  &= \iso(\Phi(\fixt L \to \fixt L) \x \DP(\fixt L \to \fixt L))\\
  &= \iso((\Phi\fixt L \to \Phi\fixt L)
  \x (\iso\Phi \fixt L \to \DP \fixt L \to \DP \fixt L))
  \\
  &= \iso((\fixt L \to \fixt L) \x (\iso\fixt L \to \D \fixt L \to \D\fixt L)
  & \text{by \cref{thm:phi-eqt}, }\Phi\fixt L = \fixt L
  \\
  &= \iso((\fixt L \to \fixt L) \x (\iso\fixt L \to \fixt L \to \fixt L)
  & \text{by \cref{lem:DeltaL}, }\Delta \fixt L = \fixt L
\end{align*}

\noindent
The behavior of $\phi e$ is to compute a boxed pair $\eboxraw{\etuple{f,f'}}$,
where $f : \fixt L \to \fixt L$ is a sped-up function and $f' : \iso\fixt L \to
\fixt L \to \fixt L$ is its derivative. This is exactly what we need to call
\fastfix. Therefore $\phi(\efix e) = \fastfix\<\phi e$.
%
However, if we're going to use $\fastfix$ in the output of $\phi$, we ought to
give it a typing rule and semantics:

\begin{align*}
  \infer{
    \J{e}{\G}{\iso((\fixt L \to \fixt L) \x (\iso\fixt L \to \fixt L \to \fixt L)}
  }{\J{\fastfix\<e}{\G}{\fixt L}}
  &&
  \begin{aligned}
    \den{\fastfix\<e}\<\g &= \fastfix \<(f, f')
    \\
    \text{where}~ & (f,f') = \den{e}\<\g
  \end{aligned}
\end{align*}

As for $\delta(\efix e)$, since $e$ can't change (having $\iso$ type), neither
can $\efix e$ (or $\fastfix\<\phi e$). All we need is a zero change at type
$\fixt L$; by \cref{lem:DeltaL}, $\bot$ suffices.

%% \todo{Give typing rules and semantics for \fastfix. Semantics does not depend on
%%   \fastfix\ being given a derivative; it's well-defined regardless.}


\subsection{Variables, \boldfn, and application}

At the core of a functional language are variables, \fn, and application. The
$\phi$ translation leaves these alone, simply distributing over subexpressions.
On variables, $\delta$ yields the corresponding change variables. On functions
and application, $\delta$ is more interesting:

\begin{align*}
  \DP(A \to B) &= \iso\Phi A \to \DP A \to \DP B
  &
  \delta(\fnof x e) &= \fnof{\eboxvar x} \fnof\dx \delta e
  &
  \delta(e\<f) &= \delta e \<\ebox{\color{Rhodamine}\phi f} \<\delta f
\end{align*}

The intuition behind $\delta(\fnof x e) = \fnof{\eboxvar x} \fnof\dx \delta e$
is that a function change takes two arguments, a base point $\dvar x$ and a
change $\dx$, and yields the change in the result of the function, $\delta e$.
However, we are given an argument of type $\iso \Phi A$, but consulting
\cref{thm:type-correct} for the type of $\delta e$, we need a discrete variable
$\hd x {\Phi A}$, so we use pattern-matching to unbox our argument.

The intuition behind $\delta(e\<f) = \delta e \<\ebox{\phi f} \<\delta f$ is
much the same: $\delta e$ needs two arguments, the original input $\phi f$ and
its change $\delta f$, to return the change in the function's output. Moreover,
it's discrete in its first argument, so we need to box it, $\ebox{\phi f}$.

One might wonder why this type-checks, since $\phi e$ and $\delta e$ don't use
the same typing context.
%
We're even boxing $\phi f$, hiding all monotone variables; consequently, it gets
the context $\stripcxraw{\iso\Phi\G, \DP\G}$.
%
However, $\iso$ makes every variable discrete, and $\stripcxraw{-}$ leaves
discrete variables alone, so this includes \emph{at least} $\iso\Phi\G$. The
context $\phi f$ needs is $\Phi\G$. Since $\iso$ only makes a context stronger,
we're safe.
%
To emphasize this, we've marked all \emph{discrete} uses of $\phi e$ inside
$\delta e$ in \hilite{pink}.
%
The same argument applies (all the more easily) when $\phi e$ is used in a
monotone rather than a discrete position.

\todo{Discuss self-maintainable functions, citing \citet{incremental}.}


\subsection{The discreteness comonad, \iso}

\todo{Discuss $\ebox{e}$ and $\eletbox x e f$. Explain why $\delta e$ can be
  used inside $\phi e$ in discrete position, highlighted in
  {\color{Rhodamine}pink}.}


\subsection{Case analysis, \prim{split}, and \name{dummy}}

\todo{explain \name{dummy}}


\subsection{Semilattices and comprehensions}

\todo{explain use of \name{dummy} to implement \zero.}

%% %% TODO: should we include this? I think the point is pretty well-made already.
%% \noindent
%% These correspond respectively to $\Phi$ and $\DP$ applied to $\iso A \to B \to
%% C$:
%%
%% \begin{align*}
%%   \Phi(\iso A \to B \to C)
%%   &= \iso (\Phi A \x \DP A) \to \Phi B \to \Phi C
%%   \\
%%   \DP(\iso A \to B \to C)
%%   &= \D(\iso (\Phi A \x \DP A) \to \Phi B \to \Phi C)\\
%%   &= \iso (\iso (\Phi A \x \DP A))
%%   \to \D(\iso (\Phi A \x \DP A))
%%   \to \D(\Phi B \to \Phi C)\\
%%   &\cong \iso (\Phi A \x \DP A)
%%   \to \tunit
%%   \to \iso\Phi B \to \DP B \to \DP C\\
%%   &\cong \iso \Phi A \to \iso \DP A \to \iso\Phi B \to \DP B \to \DP C
%% \end{align*}


\subsection{Leftovers}

\todo{Ideas not yet covered:
  \begin{itemize}
  \item things that can't change because they're discrete, like $\delta(\efix
    e)$, $\delta(\eeq e f)$, $\delta{\eset{e_i}_i}$ --- or maybe leave those for
    later?
\end{itemize}}
