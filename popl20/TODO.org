* Sketch of paper
1. Lead with faster-fix and how it eg. speeds up transitive closure
   from O(n^2) to O(n).


* Theorems to put in paper
âŸ¦-âŸ§ : Datafun â†’ Poset is the standard semantics.
â¦ƒ-â¦„ : Datafun â†’ Î”Poset is the change semantics.
ğ“¤ : Î”Poset â†’ Poset is the forgetful functor.
For A : Î”Poset, ğ“¤A : Poset is the value poset
and Î”A : Poset is the change poset.

1. ğ“¤â¦ƒ-â¦„ = âŸ¦-âŸ§
2. Î”â¦ƒAâ¦„ = âŸ¦Î”AâŸ§
3. The logical relations proof.


* Potential examples

1. path(X,Y) â† edge(X,Y)
   path(X,Z) â† edge(X,Y), path(Y,Z)

   1a) how it evaluates in naive Datafun
   1b) why is this bad?
   1c) what you might write in OCaml or Haskell to do this faster manually.
   1d) rewrite OCaml code to expose faster-fix & incremental components
   1e) show what Datafun's Ï†-transform does to the naive Datafun code

   Show that seminaive evaluation turns this from O(nÂ²?) to O(n) or whatever.

2. Some example which we use to demonstrate connection to Datalog seminaive evaluation. (Sells idea as having more general applicability.)

    2a) Show Datalog version of transitive closure
    2b) how seminaive evaluation of the transitive closure changes the set of known facts over time
    2c) How this corresponds exactly to Datafun version w/ incremental path & faster-fix.

3. Example using functions over relations: Generic transitive closure, & what
   Ï†-transform does to that.

   3a) Generic transitive closure (see below).
   3b) The Ï†-transform of it, post-optimisation.
   3c) Explain how this generalizes Datalog's seminaive evaluation.

4. Regular expressions! In two ways. See March 2019 notebook.

** Example 3
type pre-Ï†: â–¡{â„• Ã— â„•} â†’ {â„• Ã— â„•}
type post-Ï†: â–¡({â„• Ã— â„•} Ã— {â„• Ã— â„•}) â†’ {â„• Ã— â„•}

Ï†(Î»x. let [edge] = x in fix [Î»path. edge âˆª edge â€¢ path])
= Î»x dx.
  let [edge, dedge] = x in
  Ï†(fix [Î»path. edge âˆª edge â€¢ path])
= Î»[edge, dedge] _. fastfix Ï†[Î»path. edge âˆª edge â€¢ path]
= Î»[edge, dedge] _.
  fastfix (Ï†(Î»path. edge âˆª edge â€¢ path),
           Î´(Î»path. edge âˆª edge â€¢ path))
= Î»[edge, dedge] _.
  fastfix (Î»path. edge âˆª Ï†(edge â€¢ path),
           Î»path dpath. Î´edge âˆª Î´(edge â€¢ path))
= Î»[edge, dedge] _.
  fastfix (Î»path. edge âˆª Ï†(edge â€¢ path),
           Î»path dpath. dedge âˆª Î´(edge â€¢ path))
(with optimizations)
= Î»[edge, _] _.
  fastfix ((Î»path. edge âˆª Ï†(edge â€¢ path)),
           (Î»path dpath. edge â€¢ dpath))

fastfix : â–¡((A -> A) Ã— (A Ã— Î”A â†’ Î”A)) â†’ A
fastfix (f,df) = loop âŠ¥ (f âŠ¥)
  where loop x dx = if dx â‰¤ x then x else
                    loop (x âˆª dx) (df x dx)

Î´(edge â€¢ path)
= Î´{(x,z) | (x,y) âˆˆ edge, (y,z) âˆˆ path}
= Î´(for (x,y âˆˆ edge) for (y2,z âˆˆ path) when (y = y2) {(x,z)})
= (for (x,y âˆˆ dedge)
   let ... in for (y2,z âˆˆ path) let ... in when (y = y2) {(x,z)})
âˆª for (x,y âˆˆ edge âˆª dedge) let ... in
  Î´(for (y2,z âˆˆ path) when (y = y2) {(x,z)})
= (for (x,y âˆˆ dedge)
   let ... in for (y2,z âˆˆ path) let ... in when (y = y2) {(x,z)})
âˆª for (x,y âˆˆ edge âˆª dedge) let ... in
    (for (y2,z âˆˆ dpath) let ... in when (y = y2) {(x,z)})
  âˆª (for (y2,z âˆˆ path âˆª dpath) let ... in
     Î´(when (y=y2) {(x,z)}))
= (for (x,y âˆˆ dedge)
   let ... in for (y2,z âˆˆ path) let ... in when (y = y2) {(x,z)})
âˆª for (x,y âˆˆ edge âˆª dedge) let ... in
    (for (y2,z âˆˆ dpath) let ... in when (y = y2) {(x,z)})
  âˆª (for (y2,z âˆˆ path âˆª dpath) let ... in
     if y=y2 then {} else
     when (false) {(x,z)} âˆª {}
= (for (x,y âˆˆ dedge) for (y2,z âˆˆ path) when (y = y2) {(x,z)})
âˆª for (x,y âˆˆ edge âˆª dedge)
  for (y2,z âˆˆ dpath) when (y = y2) {(x,z)}
= (dedge â€¢ path) âˆª ((edge âˆª dedge) â€¢ dpath)
(because dedge is empty)
= edge â€¢ dpath

Î´(when (M) N) = if Ï†M then Î´N else when (Î´M) Ï†N âˆª Î´N

Î´(for (x in M) N)
= for (x in Î´M) let dx = 0 x in Ï†N
âˆª for (x in Ï†M âˆª Î´M) let dx = 0 x in Î´N

Ï†(for (x in M) N) = for (x in Ï†M) let dx = 0x in Ï†N

4. Î´(M âˆ© N) â‰¡ (M âˆ© Î´N) âˆª (Î´M âˆ© N) âˆª (Î´M âˆ© Î´N)
   if you optimize enough

* Roads not taken
There were a lot of choices we made that could have been made differently. I'd
like to have a section in the paper on them if there's room. In particular, we
could have, in no particular order:

1. Normalized first, then do seminaive transform only on first-order Datafun.

2. Used "change monoids" a la unpublished(?) Picallo & Michael PJ &c paper.

3. Tried to handle nested fixed points. This would involve 2nd and higher
   derivatives; could lazily compute them? Apply Paolo Giarrusso's thesis work?
   We didn't do this because it seems hard and Datalog can't do it.

4. Included a normal incrementalization/derivative transform, not just the
   seminaive incrementalization/derivative transform.

5. Augmented our target language with dependent types (to specify "zero change
   for a value") and quotients to try to make Î¦â–¡A more closely model the
   semantics.

6. Used two _separate_ comonads, one for discreteness, one for preventing nested
   fixed points. But then we'd have to think about how they interact! Future
   work?

7. Only stored zero changes for _functions_, not for everything inside a boxed
   type. This seems related to letting Î¦(A_eq) = A_eq. Or perhaps having
   separate Î”â–¡ and Î”.

8. We chose to let Î”â–¡A = 1. It's possible letting Î”â–¡A = â–¡Î”A would also work,
   although I'm not sure. For example, then Î”Î¦â–¡A = Î”â–¡(Î¦A Ã— Î”Î¦A) = â–¡(Î”Î¦A Ã— Î”Î”Î¦A),
   which just feels icky. However, it does considerably simplify Ï†(split e) and
   Î´(split e)! eg. Î´(split e) = split Î´e.

9. The finite set type, {-}, can conceptually be separated into Fâ–¡A, where F is
   the "free semilattice" functor. So why don't we do this - in our semantics at
   least, if not in our syntax?

   This would break our semantics into smaller components; for example, the
   requirement that given (f : Î“ Ã— â–¡A â†’ L) we can construct (f^* : Î“ Ã— {A} â†’ L)
   can be satisfied by functoriality and tensorial strength of F and its
   initiality property as the free semilattice. It would also simplify our
   typing rules: the intro & elim rules for FA are the same as for {A} but
   monotone where {A} is discrete, neatly separating discreteness from
   "set"-ness.

   Unfortunately, it turns out this separation works in Poset, but not in
   Î”Poset. What is Î”FA? It's really not clear. Since Î”{A} = {A}, we want Î”Fâ–¡A to
   be something like Fâ–¡A, but there's no compositional way to do that. We could
   settle for Î”Fâ–¡A = Fâ–¡(A Ã— Î”A) if we let Î”FA = Fğ•A and let âŠ• = âˆ¨. But then what
   is the derivative of gen? The obvious one is gen' x dx = gen(x âŠ• dx). But âŠ•
   is a *partial* function, so this doesn't work!

   Although it's possible there is some way to make this work, in my experience
   trying to separate {-} into Fâ–¡ turned out to be a messy maze of dead-ends.

10. Make â–¡A an eqtype. The problem with this is showing that Ï†(e âˆ¨ f : {â–¡A})
    respects the logical relation, since Î¦ will add zero change information to
    each element of the set, but a given value may have more than one valid
    zero change. Various possible approaches here.

   OLD UN-UPDATED REASONS:

8. We have finite set types {-} in our syntax, but separate {A} into Fâ–¡A in our
   semantics. Why not put F directly into our syntax? This simplifies our typing
   rules; it has the same intro & elim as {-} but without getting discreteness
   involved! However, this creates two complications:

   - First, then Î¦{A} = Î¦Fâ–¡A = Fâ–¡(Î¦A Ã— Î”Î¦A). So now our sets carry around extra,
     seemingly unnecessary information. However, this is actually exactly the
     information we need to reconstruct in Ï†(for ...)! However, we _know_ that
     this extra information is a *zero change*, and our current scheme exposes
     this information to the optimizer (XXX DOES OUR OPTIMIZER USE IT?), while
     this scheme would not make it quite so obvious.

   - Second, letting â†“e be the intro for FA, what is Î´â†“e? Unlike {e}, it's not
     âŠ¥, because e *can* change. It's also not â†“Î´e; this doesn't typecheck,
     because Î”A â‰  A. Instead, the best I can think of is â†“(Ï†e âŠ• Î´e), (which,
     incidentally, requires defining the âŠ• operator in Datafun). But then what
     is Î´{e}? It's

         Î´{e} = Î´â†“[e] = â†“(Ï†[e] âŠ• Î´[e]) = â†“[Ï†e,Î´e]

     which is annoying, because we _know_ it's safe to let Î´{e} = âŠ¥. So this
     becomes an additional optimization, rather than a consequence of our translation.

   Neither of these are deal-breakers, but they are annoying.

* Syntax sugar / conveniences

sets          â†’ downsets + discreteness
{eâ‚...eâ‚™}     â†’ {[eâ‚]} âˆ¨ ... âˆ¨ {[eâ‚™]}
discrete case â†’ splitsum
if-then-else  â†’ case & isEmpty
true,false    â†’ {[()]}, âŠ¥
when          â†’ for & sets of units
(fix x.e)     â†’ fix (box (Î»x.e))
eâ‚ = eâ‚‚       â†’ box eâ‚ = box eâ‚‚

explain why booleans-as-sets-of-units is helpful
(ie. use "when")
