\section{Proving the Semi\naive\ Transformation Correct}

We have given a program transformation which computes a change on a
term $e$ given a change in its free variables, by giving a function
$\delta(e)$ computing the change in $e$, and another function
$\phi(e)$ using the change to optimize $e$. To state the correctness
of $\delta()$ and $\phi()$, we need to show that $\phi(e)$ preserves
the meaning of $e$, and that
$\delta(e)$ correctly sends $e$ with one set of bindings for its free
variables to $e$ with the changed bindings.
%
Since Datafun supports higher-order functions, we cannot directly
prove that the semantics is preserved. Instead, we will need to
formalize the intended relationship of $\phi e$ and $\delta e$ using a
logical relation, and then use that relation to prove an
\emph{adequacy theorem} saying that the semantics is preserved for
first-order types.

So inductively on types $A$, letting $a,b \in \den{A}$,
$x,y \in \den{\Phi A}$, and $\dx \in \den{\DP A}$, we define a five
place relation $\weirdat{A}{\dx}{x}{a}{y}{b}$, which may be glossed as
``$x,y$ speed up $a,b$ respectively, and $\dx$ changes $x$ into $y$''.
The definition is given in \cref{fig:logical-relation}. Units,
products and sums essentially mimic the definition of change
structures we give in \cref{sec:change-structures}. At set types
$\tset{A}$, a change is a set of values to add to the
starting set. It is also the case that values and their
sped-up versions are equal, because we engineered the definition of
$\Phi(A)$ to be the identity on equality types.

Since the box type $\Box A$ represents values which do not change, the
only valid change is the unit value, which takes a value and a sped-up
value to the very same value and sped-up value. However, the sped-up
version of a value is taken to be a \emph{pair} of a value and a
change, and the change is a zero-change for that value at type $A$.
This ensures that at a boxed function type, we will always have a
derivative (i.e. a zero-change) available.
%
Speaking of functions, the relation at the type $A \to B$ works very
much the way one would expect from the incremental lambda calculus.
$\df$ is a valid change from $f_\phi$ to $g_\phi$ (with $f$ and $g$ as the
respective slow versions), when, given any
change $dx$ sending $x$ to $y$ (with $a$ and $b$ as respective sped-up
versions), we have that $\df\,x\dx$ is a valid change sending
$f_\phi\,x$ to $g_\phi\,y$ (with $f\,a$ and $g\,b$ as the respective
slow versions).

The logical relation is defined on closed terms, and so
before we can state the fundamental theorem, we have to extend
the relation to contexts $\G$ and substitutions, letting
$\rho,\rho' \in \den{\G}$, $\g,\g' \in \den{\Phi\G}$, and
$\dgamma \in \den{\DP\G}$:

\nopagebreak[1]
\begin{align*}
  \weirdat{\G}{\dgamma}{\g}{\rho}{\g'}{\rho'}
  &\iff \fa{\h x A \in \G} \weirdat{A}{\dgamma_{\dx}}{\g_x}{\rho_x}{\g'_x}{\rho'_x}
  \\
  &\hphantom{{}\iff{}} \hspace*{-13.2pt} \wedge \fa{\hd x A \in \G}
  \weirdat{\iso A}
          {\etuple{}}
          {(\g_{\dvar \dx}, \g_{\dvar x})}
          {\rho_{\dvar x}}
          {(\g'_{\dvar\dx}, \g'_{\dvar x})}
          {\rho'_{\dvar x}}
\end{align*}
\noindent
With that in place, we can state the fundamental theorem, showing that
$\phi$ and $\delta$ generate expressions which satisfy this logical
relation:

\begin{theorem}[Fundamental Property]
  If $\J e \G A$ and $\weirdat{\G}{\dgamma}{\g}{\rho}{\g'}{\rho'}$ then
  \[\weirdat{A}{\den{\delta e} \<\tuple{\g,\dgamma}}{\den{\phi
      e}\<\g}{\den{e}\<\rho}{\den{\phi e}\<\g'}{\den{e}\<\rho'}\]
\end{theorem}


\begin{figure}
\begin{align*}
  \weirdat{\tunit}{\tuple{}}{\tuple{}}{\tuple{}}{\tuple{}}{\tuple{}}
  &\iff \top
  \\
  \weirdat{\tseteq A}{\dx}{x}{a}{y}{b}
  &\iff (x,y,x \cup \dx) = (a,b,y)
  \\
  \weirdat{\iso A}{\tuple{}}{(x,\dx)}{a}{(y,\dy)}{b}
  &\iff (a,x,\dx) = (b,y,\dy) \wedge \weirdat{A}{\dx}{x}{a}{y}{b}
  \\
  \weirdat{A_1 \x A_2}{\vec{\dx}}{\vec x}{\vec a}{\vec y}{\vec b}
  &\iff \fa{i} \weirdat{A_i}{\dx_i}{x_i}{a_i}{y_i}{b_i}
  \\
  \weirdat{A_1 + A_2}{\inj i \dx}{\inj j x}{\inj k a}{\inj l y}{\inj m b}
  &\iff i = j = k = l = m \wedge \weirdat{A_i}{\dx}{x}{a}{y}{b}
  \\
  \weirdat{A \to B}{\df}{f_\phi}{f}{g_\phi}{g}
  &\iff
  \fa{\weirdat{A}{\dx}{x}{a}{y}{b}}\\
  &\hphantom{{}\iff{}}
  \weirdat{B}{\df\<x\<\dx}{f_\phi\<x}{f\<a}{g_\phi\<y}{g_\phi\<b}
\end{align*}
  \caption{Definition of the logical relation}
  \label{fig:logical-relation}
\end{figure}

This theorem follows by a structural induction on typing derivations
as usual, but a number of lemmas need to be proved in order to
establish the fundamental theorem.

First, we prove a pair of lemmas about the behaviour of the logical
relation at equality types. Both of these follow by induction on the
structure of equality types.

\begin{lemma}[Equality Changes]
For all equality types $\eqt A$, we have that $\weirdat{\eqt A}{\dx}{x}{a}{y}{b}$ implies $x = a$ and $y = b$.
\end{lemma}

\begin{lemma}[Dummy Changes]
  For all equality types $\eqt A$, we have that $\weirdat{\eqt A}{\dummy(x)}{x}{x}{x}{x}$.
\end{lemma}

%% FIXME: broken reference
The equality changes lemma shows that at equality types, the sped-up
version of a value is the value itself. We then show a relational
analogue of Lemma~\ref{lem:dummy-change}, that the $\dummy$ function
calculates a zero change for all equality types. This justifies the
use of $\zero$ to notate uses of $\dummy$ in the $\phi$ and $\delta$
translations.

The lemma involves the lattice types, showing that a change for a
lattice type $L$ is something that can be joined on to it:

\begin{lemma}[Semilattice Changes]
  At lattice types $L$, we have that $\Delta L = L$ and $\weirdat{L}{\dx}{x}{a}{y}{b}$ if and only if $x = a$ and $y = b = x \vee_L \dx$
\end{lemma}
\begin{proof}
  This follows by induction on the structure of $L$. The first
  property is a consequence of the fact that all lattice types are
  equality types. The first two properties of the bi-implication are a
  corollary of the equality changes lemma, and the third property
  follows from the fact that it is true by definition for set types,
  and that products work pointwise.
\end{proof}

This lemma is used in the proofs of the fundamental theorem in all the
cases involving lattice types -- we use it in the cases for the least
element $\bot$, the join $e \vee e'$, for-comprehensions
$\efor x e f$, and the fixed point operator $\prim{fix}\< e$.

Similarly, we also need to prove theorems about context manipulations
to establish the soundness of the rules for the box type. First, we
show that all valid changes for a discrete context (i.e., a context
with only discrete variables) send terms to themselves.

\begin{lemma}[Discrete Contexts Don't Change]
  If $\weirdat{\stripcx{\G}}{\tuple{}}{\gamma}{\rho}{\gamma'}{\rho'}$ then $\gamma = \gamma'$ and $\rho = \rho'$.
\end{lemma}

We state this lemma by quantifying over all contexts and then
stripping because we use it in the proof of the next lemma, which
says that for any valid context change, its effect on the discrete
part is a no-op:

\todo{Define strip}

\begin{lemma}[Context Stripping]
  If $\weirdat{\G}{\dg}{\gamma}{\rho}{\gamma'}{\rho'}$
  then $\weirdat{\stripcx{\G}}{\tuple{}}{\strip(\g)}{\strip(\rho)}{\strip(\g')}{\strip(\rho')}$.
\end{lemma}

This lemma is used in all the cases of the fundamental theorem
involving discrete expressions -- equality $\eeq{e_1}{e_2}$, set
constructors like $\esetsub{e_i}{i}$, emptiness tests $\eisempty e$,
and box introduction $\ebox e$.



Once the fundamental theorem has been established, we can specialize
it to closed terms and equality types, Then, the equality changes
lemma implies adequacy -- that first-order closed programs compute the
same result when $\phi$-translated:

\begin{theorem}[Adequacy of the Translation]
  If $\J e {\emptycx} {\eqt A}$ then $\den{e} = \den{\phi e}$.
\end{theorem}

%% \nopagebreak[2]
%% \vspace{-\baselineskip}
%% \begin{mathpar}
%%   \weirdat{\tunit}{\tuple{}}{\tuple{}}{\tuple{}}{\tuple{}}{\tuple{}}

%%   \weirdat{\tseteq A}{\dx}{x}{x}{x \cup \dx}{x \cup \dx}

%%   \infer{\weirdat{A}{\dx}{x}{a}{x}{a}}{
%%     \weirdat{\iso A}{\tuple{}}{(x,\dx)}{a}{(x,\dx)}{a}}

%%   \infer{\fa{i} \weirdat{A_i}{\dx_i}{x_i}{a_i}{y_i}{b_i}}{
%%     \weirdat{A_1 \x A_2}{\vec{\dx}}{\vec x}{\vec a}{\vec y}{\vec b}}

%%   \infer{\weirdat{A_i}{\dx}{x}{a}{y}{b}}{
%%     \weirdat{A_1 + A_2}{\inj i \dx}{\inj i x}{\inj i a}{\inj i y}{\inj i b}}

%%   \infer{\fa{\weirdat{A}{\dx}{x}{a}{y}{b}}
%%     \weirdat{B}{\df\<x\<\dx}{f\<x}{f_s\<a}{g\<y}{g_s\<b}
%%   }{
%%     \weirdat{A \to B}{\df}{f}{f_s}{g}{g_s}}
%% \end{mathpar}
